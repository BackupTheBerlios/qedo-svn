//
// generated by Qedo
//

#include "DCI_RepositoryImpl.h"


// BEGIN USER INSERT SECTION file
// END USER INSERT SECTION file


namespace DCI {


// BEGIN USER INSERT SECTION RepositorySessionImpl
//##########################################################

MDE::Deployment::Property_ptr 
RepositorySessionImpl::convert_prop(const Components::ConfigValue* prop){
	string name(prop->name());
	string type;
	string value;
	::Property::any2string(prop->value(), type, value);
	//create Property
	DEBUG_OUT2("RepositorySessionImpl::convert_prop() add property=", name);
	DEBUG_OUT3(type, " <-type value-> ", value);
	return _property_ref->create_property(name.c_str(), value.c_str(), type.c_str());
}

void
RepositorySessionImpl::add_props(MDE::Deployment::PropOwner_ptr owner, Components::ConfigValues_var config){
for(unsigned long idx=0; idx < config->length(); idx++)
	owner->add_prop(this->convert_prop((*config)[idx])); 
}

void
RepositorySessionImpl::add_conf_props(MDE::Deployment::ComponentInstantiation_ptr comp, Components::ConfigValues_var config){
	for(unsigned long idx=0; idx < config->length(); idx++)
	comp->add_conf_prop(this->convert_prop((*config)[idx])); 
}

void
RepositorySessionImpl::add_def_props(MDE::Deployment::HomeInstantiation_ptr home, Components::ConfigValues_var config){
	for(unsigned long idx=0; idx < config->length(); idx++)
	home->add_comp_default_prop(this->convert_prop((*config)[idx])); 
}

void
RepositorySessionImpl::add_comp_rule(MDE::Deployment::ComponentInstantiation_ptr comp, Qedo::RuleData rule){
	DEBUG_OUT2("RepositorySessionImpl::add_conf_rule() name=", rule.name);
	DEBUG_OUT3(rule.condition.language, " <-lang condition code-> ", rule.condition.code);
	DEBUG_OUT3(rule.action.language, " <-lang action code-> ", rule.action.code);
	DEBUG_OUT2("interval=", rule.interval);
	//create rule 
	MDE::Deployment::Rule_var rep_rule= 
		_rule_ref->create_rule(rule.name.c_str(), rule.condition.code.c_str(), rule.condition.language.c_str(), rule.action.code.c_str(), rule.action.language.c_str(), rule.interval);
	//add to componentInstantiation
	comp->add_the_rule(rep_rule);
}

void
RepositorySessionImpl::add_comp_reg(MDE::Deployment::ComponentInstantiation_ptr comp, const string regname){
	DEBUG_OUT2("	add registration to nameservice under ", regname);
	//create rule 
	MDE::Deployment::RegisterComponentInstance_var rep_reg= 
		_registerComponentInstance_ref->create_register_component_instance(MDE::Deployment::NAMING, regname.c_str());
	//add to componentInstantiation
	comp->add_registration(rep_reg);
}

//##########################################################
//##########################################################
MDE::Deployment::ContainedFile_ptr 
RepositorySessionImpl::create_containedFile(const char* filepath, const char* codetype, const char* entrypoint, const char* entrypointusage){

	string filename = Qedo::getFileName(filepath); 
	DEBUG_OUT2("RepositorySessionImpl::create_containedFile() filename=", filename);
	//TODO: delete size in model 
	//create ContainedFile 
	MDE::Deployment::ContainedFile_var contFile = 
		_containedFile_ref->create_contained_file(filename.c_str(), "", 0, "", "", 
												  codetype, entrypoint, entrypointusage);
	//upload file to repository
	DEBUG_OUT2("RepositorySessionImpl::create_containedFile() upload file=", filepath);
	CORBA::OctetSeq_var octSeq = new CORBA::OctetSeq();
	::RepUtils::get_file(filepath, octSeq);
	contFile->save_file(octSeq);
	return contFile._retn();
};
//##########################################################
MDE::Deployment::DeploymentUnit_ptr 
RepositorySessionImpl::get_deploymentUnit(const char* uuid, const char* componentfileid, dependencyMap* dep_map) {

	DEBUG_OUT2("RepositorySessionImpl::get_deploymentUnit() uuid=", uuid);

	MDE::Deployment::DeploymentUnit_var rep_deployment_unit;
	//lookup first
	rep_deployment_unit = _deploymentUnit_ref->lookup(uuid);
	if ( !CORBA::is_nil(rep_deployment_unit)) {
		DEBUG_OUT("RepositorySessionImpl::get_deploymentUnit() already in repository!");
	}
	else {
		if(strcmp(componentfileid,"")==0) {
			NORMAL_ERR2("RepositorySessionImpl::get_deploymentUnit(): could not find uuid=",uuid)
			throw ::DCI::InvalidArchive();
		};

		// create DeploymentUnit
		DEBUG_OUT("RepositorySessionImpl::get_deploymentUnit() have to create...");

		//get componentfile
		//std::map < std::string, std::string > ::iterator it_implMap;
		//for ( it_implMap = _assData.implementationMap_.begin( ) ; it_implMap != _assData.implementationMap_.end( ) ; it_implMap++ ) {
		//	cout << (*it_implMap).first << " - "<<(*it_implMap).second << endl;
		//}
		//it_implMap = _assData.implementationMap_.find( componentfileid );
		//if ( it_implMap == _assData.implementationMap_.end( ) ) {
		//	cerr << "ComponentFileId: " << componentfileid << " not found in ImplementationMap of Assembly!" << endl;
		//	throw ::DCI::InvalidArchive();
		//}

		//get ComponentImplementationData
		std::string temppath = _temppath_comp+"\\"+uuid;
		Qedo::makeDir(temppath);
		temppath += "\\";
		Qedo::ComponentImplementationData compimpldata; 
		compimpldata.uuid = uuid;
		Qedo::CSDReader csdreader;
	//	csdreader.readCSD((*it_implMap).second, &compimpldata, temppath);	//component archive should already been extracted by readCAD()!!
		csdreader.readCSD(componentfileid, &compimpldata, temppath);	//component archive should already been extracted by readCAD()!!
		//create DeploymentUnit
		std::cout << "   create DeploymentUnit: "<< uuid << "\n";
		
		rep_deployment_unit = _deploymentUnit_ref->create_deployment_unit(true, uuid, "", "", "", "");

		MDE::Deployment::ContainedFile_ptr rep_contained_file;
		//executor
		DEBUG_OUT("		read executor...");
		rep_contained_file = create_containedFile((temppath+compimpldata.executor_module).c_str(), "DLL", 
												compimpldata.executor_entry_point.c_str(), "executor");
		rep_deployment_unit->add_contained_file(rep_contained_file);
		
		//servant
		DEBUG_OUT("		read servant...");
		rep_contained_file = create_containedFile((temppath+compimpldata.servant_module).c_str(), "DLL", 
												compimpldata.servant_entry_point.c_str(), "servant");
		rep_deployment_unit->add_contained_file(rep_contained_file);

		//artifacts -> containedFiles TODO DependentFile ??
		DEBUG_OUT("		read artifacts...");
		std::vector < string >	::iterator it_artif;
		for ( it_artif = compimpldata.artifacts.begin( ) ; it_artif != compimpldata.artifacts.end( ) ; it_artif++ ) {
			rep_contained_file = create_containedFile((temppath+(*it_artif)).c_str(), "EXE", "", "");
			rep_deployment_unit->add_contained_file(rep_contained_file);
		}

		DEBUG_OUT("		read dependencies...");
        dependencyMap ::iterator it_map;
		std::vector < string >	::iterator it_dep;
		for ( it_dep = compimpldata.softpkg_dependencies.begin( ) ; it_dep != compimpldata.softpkg_dependencies.end( ) ; it_dep++ ) {
			it_map = (*dep_map).find(uuid);
			if ( it_map == (*dep_map).end( ) ) {
				CorbaIdlTypes::StringSet s;
				s.length(1); 
				s[0] = CORBA::string_dup((*it_dep).c_str());
				DEBUG_OUT("			add entry to impl_map: " << *it_dep << " to entry: "<< uuid << " in dep_map...");
				(*dep_map)[uuid] = s;
			}
			else {
				//if exist, add
				unsigned long sidx=0;
				for ( ; sidx < (*it_map).second.length(); sidx++ )
					if(strcmp((*it_map).second[sidx], (*it_dep).c_str()) == 0){
						DEBUG_OUT("			uuid: " << *it_dep << " already in entry in dep_map...");
						break;
					}
				if(sidx==(*it_map).second.length()) { // not found
					(*it_map).second.length(sidx+1); 
					(*it_map).second[sidx] = CORBA::string_dup((*it_dep).c_str());
					DEBUG_OUT("			add uuid: " << *it_dep << " to entry: "<< uuid << " in dep_map...");
				}
			}
		}
		
		//implementation properties
		DEBUG_OUT("		create implementation properties...");
		Components::ConfigValues_var config = new Components::ConfigValues();
		config->length(1);
		CORBA::Any any;
		any <<= compimpldata.component.kind.c_str();
		config.inout()[0] = new Qedo::ConfigValue_impl("CONTAINER_TYPE", any);
		add_props(rep_deployment_unit, config);

		//move comparch for further reference
		string save_comp_archivepath = _mda_etc_var+"\\repo-files\\"+uuid+".ZIP";
		int result = rename( componentfileid, save_comp_archivepath.c_str());
		if( result != 0 )
			NORMAL_ERR2("RepositorySessionImpl::get_deploymentUnit(): could not rename ",componentfileid)
		else
			DEBUG_OUT2( "RepositorySessionImpl::get_deploymentUnit(): save componentarchieve to ", save_comp_archivepath);

		Qedo::removeDir(_temppath_comp); // cleanup comp archive dir 
		//TODO only ??
		//Qedo::removeDir(temppath);
	}
	return rep_deployment_unit._retn();
};
//##########################################################
MDE::Deployment::ConnectionEnd_ptr 
RepositorySessionImpl::create_connectionEnd(PortType porttype, Qedo::PortData* port, const MDE::Deployment::Assembly_ptr ass)
{
	MDE::Deployment::ConnectionEnd_ptr rep_ConnectionEnd;
	MDE::Deployment::ConnectionEndKind kind = MDE::Deployment::COMPONENTINTERFACE;

	switch (port->ref.kind) {

		case Qedo::COMPONENTID :
//		case Qedo::COMPONENTSUPPORTEDID :

			MDE::Deployment::ConnectionEndKind kind;
			//if(port->ref.kind == Qedo::COMPONENTSUPPORTEDID)
			//	kind = MDE::Deployment::COMPONENTSUPPORTEDINTERFACE;
			//else {
				kind = MDE::Deployment::COMPONENTINTERFACE;
				switch (porttype) {
					case USER :
						break;
					case PROVIDER :
						break;
					case CONSUMER :
						break;
					case PUBLISHER :
						kind = MDE::Deployment::EVENTCHANNELPORT;
						break;
					case EMITTER :
						kind = MDE::Deployment::EVENTPORT;
						break;
				};
//			};
			rep_ConnectionEnd =	_connectionEnd_ref->create_connection_end(
					kind, port->name.c_str());
			rep_ConnectionEnd->set_int_comp_inst(ass->lookup_component_instantiation(port->ref.name.c_str()));
			break;

		case Qedo::HOMEID :
			rep_ConnectionEnd =	_connectionEnd_ref->create_connection_end(
					MDE::Deployment::HOMEINTERFACE, port->name.c_str());
			rep_ConnectionEnd->set_int_home_inst(ass->lookup_home_instantiation(port->ref.name.c_str()));
			break;

		case Qedo::OBJECTREF :
		case Qedo::NAMING :
		case Qedo::TRADER :
		case Qedo::FINDER :

			rep_ConnectionEnd =	_connectionEnd_ref->create_connection_end(
					MDE::Deployment::SIMPLEINTERFACE, port->name.c_str());

			MDE::Deployment::FinderService_ptr rep_FinderService;
			MDE::Deployment::FinderServiceKind skind;
			string objref;
			
			if(port->ref.kind == Qedo::OBJECTREF) {
				objref = port->ref.name.c_str();
			}
			else {
				switch(port->ref.kind) {
				case Qedo::NAMING:
					skind = MDE::Deployment::NAMING;
					std::cout << "   add FinderService (NAMING, "<< port->ref.name.c_str() << ")...\n";
					break;
				case Qedo::TRADER:
					skind = MDE::Deployment::TRADING;
					std::cout << "   add FinderService (TRADING, "<< port->ref.name.c_str() << ")...\n";
					break;
				case Qedo::FINDER:
					skind = MDE::Deployment::HOMEFINDER;
					std::cout << "   add FinderService (HOMEFINDER, "<< port->ref.name.c_str() << ")...\n";
					break;
				}
				rep_FinderService = _finderService_ref->create_finder_service(skind, port->ref.name.c_str());
			}
			MDE::Deployment::ExternalInstance_ptr rep_ExternalInstance = 
				_externalInstance_ref->create_external_instance( rep_FinderService, objref.c_str());
			rep_ConnectionEnd->set_ext_inst(rep_ExternalInstance);
			break;
	};
	return rep_ConnectionEnd;
}
//##########################################################
//##########################################################
void
RepositorySessionImpl::initialize()
{
	DEBUG_OUT( "RepositorySessionImpl::initialize(): start...");
	_mda_etc_var = Qedo::getEnvironment ( "MDA_ETC" );
	std::string myRef;
	if (!_mda_etc_var.empty())
	{
		myRef = _mda_etc_var + "\\RepositoryRoot.ref";
	} 
	else 
	{
		NORMAL_ERR("RepositorySessionImpl::initialize(): MDA_ETC environment variable not found !");
		throw CORBA::SystemException();
	}
	std::ifstream in;
	in.open ( myRef.c_str() );
	if ( ! ( in.is_open () ) ) 
	{
		NORMAL_ERR3("RepositorySessionImpl::initialize(): ", myRef, " repository reference is not found!");
		throw CORBA::SystemException();
	}

	DEBUG_OUT2( "RepositorySessionImpl::initialize(): using repository reference at: ", myRef);
	char ref_[2048];
	in >> ref_;
	in.close ();

	// TODO: CORBA::ORB_var orb = context_->resolve_service_reference("ORB");
	int dummy = 0;
	CORBA::ORB_var orb = CORBA::ORB_init (dummy, 0);
	CORBA::Object_var obj_;

	if ( strcmp ( ref_, "" ) != 0 )
			obj_ = orb->string_to_object ( ref_ );
	else
	{
		NORMAL_ERR2("RepositorySessionImpl::initialize(): repository reference not valid!", ref_);
		throw CORBA::SystemException();
	}

	if( CORBA::is_nil ( obj_.in () ) ) 
	{
		NORMAL_ERR("RepositorySessionImpl::initialize(): String to Object by ORB initialization failed!");
		throw CORBA::SystemException();
	}

	DEBUG_OUT( "RepositorySessionImpl::initialize(): narrowing ...");
	M2C::MOFRepository::RepositoryRoot_var repositoryRoot_ref_ = 
		M2C::MOFRepository::RepositoryRoot::_narrow ( obj_ );
	if( CORBA::is_nil ( repositoryRoot_ref_ ) ) 
	{
		NORMAL_ERR("RepositorySessionImpl::initialize(): repository reference nil!");
		throw CORBA::SystemException();
	}

	//get deployment package from repository
	Reflective::RefPackageSet_var package_set_ =
		repositoryRoot_ref_->get_root_packages ();

	//empty repository -> initialize
	if ( package_set_->length () == 0 ) 
	{
		DEBUG_OUT( "RepositorySessionImpl::initialize(): initialize Repository ..." );
		obj_ = repositoryRoot_ref_->get_root_package_factory ();
		if( CORBA::is_nil ( obj_ ) ) 
		{
			NORMAL_ERR("RepositorySessionImpl::initialize(): package factory reference nil!");
			throw CORBA::SystemException();
		}
		MDE::MDEPackageFactory_var package_fac_ = MDE::MDEPackageFactory::_narrow ( obj_ );
		if( CORBA::is_nil ( package_fac_ ) ) 
		{
			NORMAL_ERR("RepositorySessionImpl::initialize(): package factory reference nil!");
			throw CORBA::SystemException();
		}
		obj_ = package_fac_->create_mde_package ();
		if ( CORBA::is_nil ( obj_ ) ) 
		{
			NORMAL_ERR("RepositorySessionImpl::initialize(): mde package reference nil!");
			throw CORBA::SystemException();
		}
		package_set_ =	repositoryRoot_ref_->get_root_packages ();
	}

	if ( package_set_->length () != 1 )
	{
		NORMAL_ERR("RepositorySessionImpl::initialize(): RootPackage number invalid!");
		throw CORBA::SystemException();
	}

	MDE::MDEPackage_var mde_package_ = MDE::MDEPackage::_narrow ( (*package_set_)[0] );

	if ( CORBA::is_nil ( mde_package_ ) ) 
	{
		NORMAL_ERR("RepositorySessionImpl::initialize(): mde package reference nil! Is repository running???");
		throw CORBA::SystemException();
	}

	obj_ = mde_package_->deployment_ref();

	//reference to deployment-root-package
	_deployment_pkg_ref = MDE::Deployment::DeploymentPackage::_narrow ( obj_ );
	if ( CORBA::is_nil ( _deployment_pkg_ref ) ) {
		NORMAL_ERR("RepositorySessionImpl::initialize(): deployment package factory reference nil!");
		throw CORBA::SystemException();
	}

	//Initialize internal references
	DEBUG_OUT( "RepositorySessionImpl::initialize(): initialize internal references...");
	//Model
	_assembly_ref = _deployment_pkg_ref->assembly_ref ();
	_deploymentUnit_ref = _deployment_pkg_ref->deployment_unit_ref();
	_containedFile_ref = _deployment_pkg_ref->contained_file_ref();
	_dependentFile_ref = _deployment_pkg_ref->dependent_file_ref();
	_configuration_ref = _deployment_pkg_ref->configuration_ref();
	_installation_ref = _deployment_pkg_ref->installation_ref();
	_processCollocation_ref = _deployment_pkg_ref->process_collocation_ref();
	_homeInstantiation_ref = _deployment_pkg_ref->home_instantiation_ref();
	_connection_ref = _deployment_pkg_ref->connection_ref();
	_componentInstantiation_ref = _deployment_pkg_ref->component_instantiation_ref();
	_registerComponentInstance_ref = _deployment_pkg_ref->register_component_instance_ref();
	_connectionEnd_ref = _deployment_pkg_ref->connection_end_ref();
	_externalInstance_ref = _deployment_pkg_ref->external_instance_ref();
	_finderService_ref = _deployment_pkg_ref->finder_service_ref();
	_property_ref = _deployment_pkg_ref->property_ref();
	_rule_ref = _deployment_pkg_ref->rule_ref();

/*	_providesDef_ref = componentIDL_pkg_ref_->provides_def_ref();
	_usesDef_ref = componentIDL_pkg_ref_->uses_def_ref();
	_consumesDef_ref = componentIDL_pkg_ref_->consumes_def_ref();
	_publishesDef_ref = componentIDL_pkg_ref_->publishes_def_ref();
	_emitsDef_ref = componentIDL_pkg_ref_->emits_def_ref();
*/
	_temppath_ass = _mda_etc_var + "\\dci-tmp\\ass"; 
	_temppath_comp = _mda_etc_var + "\\dci-tmp\\comp"; 

	//TODO - delete (only for testing )---------------------------------------
	CORBA::Object_var ref = context_->get_CCM_object();
	string ior = orb->object_to_string(ref);
	std::ofstream out;
	string file = _mda_etc_var + "\\repository.ior";
	out.open ( file.c_str(), std::ios_base::binary | std::ios_base::out );
	int size = ior.length();
	for (long i=0; i<size;i++) 
	{
		out << ior[i];
	}
	out.close();
	DEBUG_OUT2( "RepositorySessionImpl::initialize() write ior to ", file );
	//-------------------------------------------------------------------------
	DEBUG_OUT( "RepositorySessionImpl::initialize(): ...end");
}

//TODO: in RepUtils.h verlagern ?!
void
RepositorySessionImpl::get_archive_from_url(const char* url, DCI::AssemblyArchive* archive){
	//
	// get path
	//
	XMLURL uri(url);
	const XMLCh* p = uri.getPath();
	if(!p)
	{
		NORMAL_ERR2( "RepositorySessionImpl::get_archive_from_url(): invalid url=", url);
		throw ::DCI::InvalidArchive();
	}
	std::string name = Qedo::transcode(p);
	std::string::size_type pos = name.find_last_of("/");
	if (pos != std::string::npos)
	{
		name.erase(0, pos + 1);
	}

	//
	// make input stream
	//
	URLInputSource inputSource(uri);
	BinInputStream* inputStream;
	try
	{
		inputStream = inputSource.makeStream();
	}
	catch(...)
	{
		NORMAL_ERR2( "RepositorySessionImpl::get_archive_from_url(): invalid url=", url);
		throw ::DCI::InvalidArchive();
	}
    if (!inputStream)
    {
		NORMAL_ERR2( "RepositorySessionImpl::get_archive_from_url(): invalid url=", url);
		throw ::DCI::InvalidArchive();
    }
	
//	DCI::AssemblyArchive archive = new DCI::AssemblyArchive();
    unsigned char* buf = (unsigned char*)malloc(4096);
    unsigned int len = inputStream->readBytes(buf, 4096);
	archive->length(0);
	unsigned int arcidx = 0;
    while (len)
    {
		archive->length(archive->length()+len);
		for(unsigned int i = 0; i<len; i++) {
			(*archive)[arcidx++] = buf[i];
		}
        len = inputStream->readBytes(buf, 4096);
    }
    free(buf);
	return;
}
//##################################################
// END USER INSERT SECTION RepositorySessionImpl


RepositorySessionImpl::RepositorySessionImpl()
{
// BEGIN USER INSERT SECTION RepositorySessionImpl::RepositorySessionImpl
// END USER INSERT SECTION RepositorySessionImpl::RepositorySessionImpl
}


RepositorySessionImpl::~RepositorySessionImpl()
{
// BEGIN USER INSERT SECTION RepositorySessionImpl::~RepositorySessionImpl
// END USER INSERT SECTION RepositorySessionImpl::~RepositorySessionImpl

}


void
RepositorySessionImpl::set_context(::DCI::CCM_Repository_ContextImpl_ptr context)
    throw (CORBA::SystemException, Components::CCMException)
{
    context_ = ::DCI::CCM_Repository_ContextImpl::_duplicate(context);
}


void
RepositorySessionImpl::configuration_complete()
    throw (CORBA::SystemException, Components::InvalidConfiguration)
{
// BEGIN USER INSERT SECTION RepositorySessionImpl::configuration_complete
	DEBUG_OUT( "RepositorySessionImpl::configuration_complete(): start...");
	this->initialize();
	DEBUG_OUT( "RepositorySessionImpl::configuration_complete(): ...end");
// END USER INSERT SECTION RepositorySessionImpl::configuration_complete
}


void
RepositorySessionImpl::remove()
    throw (CORBA::SystemException)
{
// BEGIN USER INSERT SECTION RepositorySessionImpl::remove
// END USER INSERT SECTION RepositorySessionImpl::remove
}


CORBA::Object_ptr
RepositorySessionImpl::feed_assembly(const DCI::AssemblyArchive& archive)
	throw(CORBA::SystemException, ::Components::Deployment::InstallationFailure, ::DCI::InvalidArchive, ::DCI::AlreadyInstalled)
{
// BEGIN USER INSERT SECTION RepositorySessionImpl::feed_assembly
	DEBUG_OUT( "RepositorySessionImpl::feed_assembly(): start...");
	Qedo::makeDir(_temppath_ass);
    //save archive-file
	std::string ass_archivepath = _temppath_ass + "\\assembly_archive.zip";
	::RepUtils::save_file(ass_archivepath.c_str(), &archive);

	//get AssemblyData
	Qedo::CADReader cadreader;
	Qedo::AssemblyData _assData;
	cadreader.readCAD(ass_archivepath, &_assData, _temppath_ass+"\\");

	MDE::Deployment::Assembly_var rep_assembly = _assembly_ref->lookup(_assData.uuid_.c_str());
	if ( CORBA::is_nil ( rep_assembly ) ) {
	//start transfer to repository ============================
	std::cout << "create Assembly: "<< _assData.uuid_ << "\n";

	dependencyMap dep_map;		//dependencies of depl_units

	std::map < std::string, CorbaIdlTypes::StringSet > impl_map;	//installations of depl_units
	std::map < std::string, CorbaIdlTypes::StringSet > ::iterator it_map;

	//create Assembly     set to "invalid", until complete repository-transaction
    rep_assembly = _assembly_ref->create_assembly(false, _assData.uuid_.c_str(), _assData.cad.c_str());
	
	//Qedo::Package* asspkg = new Qedo::Package(ass_archivepath);

	// create Configuration
	std::cout << "   create Configuration\n";
	MDE::Deployment::Configuration_ptr	rep_Configuration = _configuration_ref->create_configuration();
	//set ass_configuration for Assembly
	rep_assembly->set_config(rep_Configuration);

	std::vector < Qedo::HostData >					::iterator it_hosts;
	for ( it_hosts = _assData.hosts_.begin( ) ; it_hosts != _assData.hosts_.end( ) ; it_hosts++ ) {

		std::vector < Qedo::ProcessData >				::iterator it_proc;
		for ( it_proc = (*it_hosts).processes.begin( ) ; it_proc != (*it_hosts).processes.end( ) ; it_proc++ ) {

			//create ProcessCollocation
			std::cout << "   create ProcessCollocation: "<< (*it_proc).id << " host:" << (*it_proc).dest.node << "\n";
			MDE::Deployment::ProcessCollocation_ptr	rep_ProcessCollocation = 
				_processCollocation_ref->create_process_collocation((*it_proc).dest.node.c_str(),	//destination
																	(CORBA::ULong) 1); 			//cardinality

			//set collocated_instances for Configuration
			//TODO falls nur installs (card=0) bleibt coloc -leiche!!!
			rep_Configuration->add_colloc(rep_ProcessCollocation);

			std::vector < Qedo::HomeInstanceData >	::iterator it_homes;
			for ( it_homes = (*it_proc).homes.begin( ) ; it_homes != (*it_proc).homes.end( ) ; it_homes++ ) {

				MDE::Deployment::DeploymentUnit_var rep_deployment_unit;
				//add DeploymentUnit ------------------------------------------------------------------------
				rep_deployment_unit = get_deploymentUnit(((*it_homes).impl_id).c_str(), ((*it_homes).file).c_str(), &dep_map);
				//!!! add (impl_id, dest) to impl_map
				it_map = impl_map.find((*it_homes).impl_id);
				if ( it_map == impl_map.end( ) ) {
					CorbaIdlTypes::StringSet s;
					s.length(1); 
					s[0] = CORBA::string_dup(((*it_homes).dest.node).c_str());
					std::cout << "add entry to impl_map: ("<< (*it_homes).impl_id << "," << (*it_homes).dest.node << ")..." << std::endl;
					impl_map[((*it_homes).impl_id).c_str()] = s;
				}
				else {
					//if destination not exist, add destination
					unsigned long sidx=0; //boolean found = false;
					for ( ; sidx < (*it_map).second.length(); sidx++ )
						if(strcmp((*it_map).second[sidx], (*it_homes).dest.node.c_str()) == 0){
							std::cout << "dest: " << (*it_homes).dest.node << " already in entry in impl_map..." << std::endl;
							break;
						}
					if(sidx==(*it_map).second.length()) { //destination not found
						(*it_map).second.length(sidx); 
						(*it_map).second[sidx-1] = CORBA::string_dup(((*it_homes).dest.node).c_str());
						std::cout << "add dest: " << (*it_homes).dest.node << " to entry: "<< (*it_homes).impl_id << " in impl_map..." << std::endl;
					}
				}
				// ------------------------------------------------------------------------------------------
				//check: cardinality==0 => only installation without instantiation of home!!
				if((*it_homes).cardinality > 0 ) {
					//check destinations
					//!!((*it_proc).host),(*it_homes).dest)

					//create HomeInstantiation
					std::cout << "   create HomeInstantiation: "<< (*it_homes).id << "\n";
					MDE::Deployment::FinderServiceBag rep_FinderServiceBag;
					MDE::Deployment::HomeInstantiation_ptr	rep_HomeInstantiation = 
						_homeInstantiation_ref->create_home_instantiation((*it_homes).id.c_str(),	//name
																		(*it_homes).dest.node.c_str(),	//destination
																		(*it_homes).cardinality,	//cardinality
																		MDE::Deployment::FinderServiceBag());	//registerwith
					//default component properties
					if( (*it_homes).comp_prop.length())
					{
						Components::ConfigValues_var config = new Components::ConfigValues();
						Qedo::CPFReader reader;
						config = reader.readCPF( (*it_homes).comp_prop );
						this->add_def_props(rep_HomeInstantiation, config);
					}
					//home properties
					if( (*it_homes).comp_prop.length())
					{
						Components::ConfigValues_var config = new Components::ConfigValues();
						Qedo::CPFReader reader;
						config = reader.readCPF( (*it_homes).home_prop );
						this->add_props(rep_HomeInstantiation, config);
					}

					MDE::Deployment::FinderService_ptr rep_FinderService;
					if (strcmp((*it_homes).finder.c_str(), "") != 0) {
						std::cout << "   add FinderService (HOMEFINDER, "<< (*it_homes).finder << ")...\n";
						rep_FinderService= _finderService_ref->create_finder_service(MDE::Deployment::HOMEFINDER, (*it_homes).finder.c_str());
						rep_HomeInstantiation->add_registerwith(rep_FinderService);
					}
					if (strcmp((*it_homes).naming.c_str(), "") != 0) {
						std::cout << "   add FinderService (NAMING, "<< (*it_homes).naming << ")...\n";
						rep_FinderService = _finderService_ref->create_finder_service(MDE::Deployment::NAMING, (*it_homes).naming.c_str());
						rep_HomeInstantiation->add_registerwith(rep_FinderService);
					}
					if (strcmp((*it_homes).trader.c_str(), "") != 0) {
						std::cout << "   add FinderService (TRADING, "<< (*it_homes).trader << ")...\n";
						rep_FinderService = _finderService_ref->create_finder_service(MDE::Deployment::TRADING, (*it_homes).trader.c_str());
						rep_HomeInstantiation->add_registerwith(rep_FinderService);
					}

					//set implemented_by
					rep_HomeInstantiation->set_unit(rep_deployment_unit);

					//set home_instances for ProcessCollocation
					rep_ProcessCollocation->add_thehome(rep_HomeInstantiation);

					std::vector < Qedo::ComponentInstanceData >		::iterator it_comp;
					for ( it_comp = (*it_homes).instances.begin( ) ; it_comp != (*it_homes).instances.end( ) ; it_comp++ ) {

						//create ComponentInstantiation
						std::cout << "   create ComponentInstantiation: "<< (*it_comp).id << "\n";
						MDE::Deployment::ComponentInstantiation_ptr	rep_ComponentInstantiation = 
							_componentInstantiation_ref->create_component_instantiation((*it_comp).id.c_str(),	//name
																						(CORBA::ULong) 1,		//cardinality
																						(CORBA::ULong) 0);		//startorder
						//set created_by for HomeInstantiation
						rep_HomeInstantiation->add_comp(rep_ComponentInstantiation);

						//component properties and configuration
						if( (*it_comp).comp_prop.length())
						{
							Components::ConfigValues_var config = new Components::ConfigValues();
							Qedo::CPFReader reader;
							// component properties 
							config = reader.readCPF( (*it_comp).comp_prop );
							this->add_props(rep_ComponentInstantiation, config);
							// component configuration (COACH extension)
							config = reader.readConf( (*it_comp).comp_prop );
							this->add_conf_props(rep_ComponentInstantiation, config);
						}

						//component rules
						std::vector< Qedo::RuleData >	::iterator it_rule;
						for ( it_rule = (*it_comp).rules.begin( ) ; it_rule != (*it_comp).rules.end( ) ; it_rule++ ) {
							this->add_comp_rule(rep_ComponentInstantiation, *it_rule);
						} //end for it_rule

						////component registration
						//std::vector < Qedo::NamingRegistrationData > ::iterator it_nreg;
						//for ( it_nreg = (*it_comp).naming_registrations.begin( ) ; 
						//	  it_nreg != (*it_comp).naming_registrations.end( ) ; 
						//	  it_nreg++ ) 
						//{
						//
						// register in nameservice
						//
						std::vector < Qedo::NamingRegistrationData > ::const_iterator naming_iter;
						for(naming_iter = (*it_comp).naming_registrations.begin();
							naming_iter != (*it_comp).naming_registrations.end();
							naming_iter++)
						{
							//
							// register facet
							//
							if( (*naming_iter).port_kind == Qedo::FACET_PORT )
							{
								NORMAL_ERR2( "cannot register facet for component ", (*it_comp).id );
								//TODO !! change model in repository!!

								//CORBA::Object_var facet;

								//try
								//{
								//	facet = comp->provide_facet( (*naming_iter).port.c_str() );
								//}
								//catch( Components::InvalidName& )
								//{
								//	NORMAL_ERR2( "AssemblyImpl: no facet ", (*naming_iter).port );
								//	NORMAL_ERR2( "AssemblyImpl: cannot register facet for component", (*iter).id );
								//	break;
								//}

								//if( !registerName( (*naming_iter).name, facet, true ) )
								//{
								//	NORMAL_ERR2( "AssemblyImpl: cannot register facet for component", (*iter).id );
								//}

								continue;
							}

							//
							// register event
							//
							// todo
							
							//
							// register component
							//
							if( (*naming_iter).port_kind == Qedo::COMPONENT_PORT )
							{
								this->add_comp_reg(rep_ComponentInstantiation, (*naming_iter).name);
							}
						} //end for it_nreg
					} // end for it_comp
				}; //end if cardinality > 0
			} // end for it_homes
		} // end for it_proc
	} // end for it_hosts

	//set dependencies -------------------------------------------------------------------------------
		//dependencies are previously collected in dep_map !!!
    DEBUG_OUT("set dependencies...");
	for ( it_map = dep_map.begin( ) ; it_map != dep_map.end( ) ; it_map++ ) {
      
		//lookup DeploymentUnit
		MDE::Deployment::DeploymentUnit_ptr rep_deployment_unit = 
			get_deploymentUnit(((*it_map).first).c_str(), "", 0); //is already in repository; only lookup
	
		//lookup DeploymentUnits depends on
		for ( unsigned long sidx=0; sidx < (*it_map).second.length(); sidx++ ) {
			MDE::Deployment::DeploymentUnit_ptr rep_deployment_unit_depends_on = 
				get_deploymentUnit((*it_map).second[sidx], "", 0); //should be already in repository otherwise error!
	        //set depends_on_unit
			DEBUG_OUT3((*it_map).first, " depends on ", (*it_map).second[sidx]);
			rep_deployment_unit->add_dependent_unit(rep_deployment_unit_depends_on);
		}
	} // end for it_map ----------------------------------------------------------------------------------

	//create Installation -------------------------------------------------------------------------------
		//destinations are previously collected in impl_map !!!
    DEBUG_OUT("create installations...");
	for ( it_map = impl_map.begin( ) ; it_map != impl_map.end( ) ; it_map++ ) {
      
		//lookup DeploymentUnit
		MDE::Deployment::DeploymentUnit_ptr rep_deployment_unit = 
			get_deploymentUnit(((*it_map).first).c_str(), "", 0); //is already in repository; only lookup
	
		//create Installation
		DEBUG_OUT2("   create Installation: impl_id=", (*it_map).first);
		std::cout << "                on destinations:";
		for ( unsigned long sidx=0; sidx < (*it_map).second.length(); sidx++ )
			std::cout << (*it_map).second[sidx] << "|";
		std::cout << "\n";

		MDE::Deployment::Installation_ptr	rep_Installation = 
			_installation_ref->create_installation((*it_map).second);
		//set install_unit for Installation
		rep_Installation->set_impl(rep_deployment_unit);

		//set installations for Configuration
		rep_Configuration->add_install_dest(rep_Installation);
	} // end for it_map ----------------------------------------------------------------------------------

	//create connections ---------------------------------------------------------------------------------
    DEBUG_OUT("create connections...");
	std::vector < Qedo::InterfaceConnectionData >	::iterator it_ifconn;
	for ( it_ifconn = _assData.interface_connections_.begin( ) ; it_ifconn != _assData.interface_connections_.end( ) ; it_ifconn++ ) {
		DEBUG_OUT("   create Connection name=");

		MDE::Deployment::Connection_ptr	rep_Connection = 
			_connection_ref->create_connection("INTERFACECONN"); // TODO: name ???
		rep_Configuration->add_conn(rep_Connection);
		rep_Connection->set_source_end(create_connectionEnd(USER, &(*it_ifconn).provide, rep_assembly));
		rep_Connection->set_target_end(create_connectionEnd(PROVIDER, &(*it_ifconn).use, rep_assembly));
	} // end it_ifconn

	std::vector < Qedo::EventConnectionData >		::iterator it_evconn;
	for ( it_evconn = _assData.event_connections_.begin( ) ; it_evconn != _assData.event_connections_.end( ) ; it_evconn++ ) {
		MDE::Deployment::Connection_ptr	rep_Connection = 
			_connection_ref->create_connection("EVENTCONN"); // TODO: name ???
		rep_Configuration->add_conn(rep_Connection);
		rep_Connection->set_source_end(create_connectionEnd(((*it_evconn).kind == Qedo::EMITTER ? EMITTER : PUBLISHER ), &(*it_evconn).emitter, rep_assembly));
		rep_Connection->set_target_end(create_connectionEnd(CONSUMER, &(*it_evconn).consumer, rep_assembly));
	} // end it_evconn ----------------------------------------------------------------------------------

	//process start_order -------------------------------------------------------------------------------
    DEBUG_OUT("set startorder...");
	std::vector < std::string >	::iterator it_startorder;
	CORBA::ULong count(1);
	for ( it_startorder = _assData.start_order_.begin( ) ; it_startorder != _assData.start_order_.end( ) ; it_startorder++ ) {
		DEBUG_OUT3( "RepositorySessionImpl::feed_assembly(): set startoder name/count=",*it_startorder, count);
		MDE::Deployment::ComponentInstantiation_var	rep_compinst = 
			rep_assembly->lookup_component_instantiation((*it_startorder).c_str());
		if ( CORBA::is_nil(rep_compinst)) {
			NORMAL_ERR("RepositorySessionImpl::feed_assembly() lookup_component_instantiation failed!");
			throw InvalidArchive();
		}
		rep_compinst->set_startorder(count++);
	} // end it_startorder ------------------------------------------------------------------------------
	//end transfer to repository ============================
	}
	else 
		DEBUG_OUT2( "RepositorySessionImpl::feed_assembly(): assembly already in repository uuid=", _assData.uuid_);
	
	//move assembly for further reference
   string save_ass_archivepath = _mda_etc_var+"\\repo-files\\"+_assData.uuid_+".ZIP";
   int result = rename( ass_archivepath.c_str(), save_ass_archivepath.c_str());
   if( result != 0 )
		NORMAL_ERR2("RepositorySessionImpl::feed_assembly() could not rename ",ass_archivepath)
   else
		DEBUG_OUT2( "RepositorySessionImpl::feed_assembly(): save assembly to ", save_ass_archivepath);

	//delete archive file
	Qedo::removeDir(_temppath_ass);
	
	//return reference to created assembly in repository
	DEBUG_OUT( "RepositorySessionImpl::feed_assembly(): ...end");
	return MDE::Deployment::Assembly::_duplicate(rep_assembly);
// END USER INSERT SECTION RepositorySessionImpl::feed_assembly
}


CORBA::Object_ptr
RepositorySessionImpl::feed_assembly_with_descriptor(const char* descriptor)
	throw(CORBA::SystemException, ::Components::Deployment::InstallationFailure, ::DCI::InvalidArchive, ::DCI::AlreadyInstalled)
{
// BEGIN USER INSERT SECTION RepositorySessionImpl::feed_assembly_with_descriptor
	DEBUG_OUT2( "RepositorySessionImpl::feed_assembly_with_descriptor(): start... descriptor=", descriptor);
	//TODO feed_assembly_with_url: get assembly and call feed_assembly()
	DEBUG_OUT( "RepositorySessionImpl::feed_assembly_with_descriptor(): ...end");
	throw CORBA::NO_IMPLEMENT();
// END USER INSERT SECTION RepositorySessionImpl::feed_assembly_with_descriptor
}


CORBA::Object_ptr
RepositorySessionImpl::feed_assembly_with_url(const char* url)
	throw(CORBA::SystemException, ::Components::Deployment::InstallationFailure, ::DCI::InvalidArchive, ::DCI::AlreadyInstalled)
{
// BEGIN USER INSERT SECTION RepositorySessionImpl::feed_assembly_with_url
	DEBUG_OUT2( "RepositorySessionImpl::feed_assembly_with_url(): start... url=", url);
	DCI::AssemblyArchive archive;
	get_archive_from_url(url, &archive);
	CORBA::Object_var ret = this->feed_assembly(archive);
	DEBUG_OUT( "RepositorySessionImpl::feed_assembly_with_url(): ...end");
	return ret._retn();
// END USER INSERT SECTION RepositorySessionImpl::feed_assembly_with_url
}


CORBA::Object_ptr
RepositorySessionImpl::feed_component(const char* implUUID, const DCI::ComponentArchive& archive)
	throw(CORBA::SystemException, ::Components::Deployment::InstallationFailure, ::DCI::InvalidArchive, ::DCI::AlreadyInstalled)
{
// BEGIN USER INSERT SECTION RepositorySessionImpl::feed_component
	DEBUG_OUT2( "RepositorySessionImpl::feed_component(): start... implUUID=",implUUID);
    //save archive-file
	Qedo::makeDir(_temppath_comp);
	std::string archivepath = _temppath_comp + "\\component_archive.zip";
	::RepUtils::save_file(archivepath.c_str(), &archive);

	//TODO extract archive to _temppath_comp ???!!
	dependencyMap dep_map;		//dependencies of depl_units
    dependencyMap ::iterator it_map;

	CORBA::Object_var deplUnit = get_deploymentUnit(implUUID, archivepath.c_str(), &dep_map);

	//set dependencies -------------------------------------------------------------------------------
	//dependencies are previously collected in dep_map !!!
	DEBUG_OUT("set dependencies...");
	for ( it_map = dep_map.begin( ) ; it_map != dep_map.end( ) ; it_map++ ) {
		//lookup DeploymentUnit
		MDE::Deployment::DeploymentUnit_ptr rep_deployment_unit = 
			get_deploymentUnit(((*it_map).first).c_str(), "", 0); //is already in repository; only lookup

		//lookup DeploymentUnits depends on
		for ( unsigned long sidx=0; sidx < (*it_map).second.length(); sidx++ ) {
			MDE::Deployment::DeploymentUnit_ptr rep_deployment_unit_depends_on = 
				get_deploymentUnit((*it_map).second[sidx], "", 0); //should be already in repository otherwise error!
			//set depends_on_unit
			DEBUG_OUT3((*it_map).first, " depends on ", (*it_map).second[sidx]);
			rep_deployment_unit->add_dependent_unit(rep_deployment_unit_depends_on);
		}
	} // end for it_map ----------------------------------------------------------------------------------

	Qedo::removeDir(_temppath_comp);
	DEBUG_OUT( "RepositorySessionImpl::feed_component(): ...end");
	return deplUnit._retn();
// END USER INSERT SECTION RepositorySessionImpl::feed_component
}


CORBA::Object_ptr
RepositorySessionImpl::feed_component_with_url(const char* implUUID, const char* url)
	throw(CORBA::SystemException, ::Components::Deployment::InstallationFailure, ::DCI::InvalidArchive, ::DCI::AlreadyInstalled)
{
// BEGIN USER INSERT SECTION RepositorySessionImpl::feed_component_with_url
	DEBUG_OUT2( "RepositorySessionImpl::feed_component_with_url(): start... url=", url);
	DCI::ComponentArchive archive;
	get_archive_from_url(url, &archive);
	CORBA::Object_var ret = this->feed_component(implUUID, archive);
	DEBUG_OUT( "RepositorySessionImpl::feed_component_with_url(): ...end");
	return ret._retn();
// END USER INSERT SECTION RepositorySessionImpl::feed_component_with_url
}


CORBA::Object_ptr
RepositorySessionImpl::get_root_package()
	throw(CORBA::SystemException)
{
// BEGIN USER INSERT SECTION RepositorySessionImpl::get_root_package
	return Reflective::RefPackage::_narrow(_deployment_pkg_ref);
// END USER INSERT SECTION RepositorySessionImpl::get_root_package
}


// BEGIN USER INSERT SECTION RepositoryImpl
// END USER INSERT SECTION RepositoryImpl


RepositoryImpl::RepositoryImpl()
:component_(new RepositorySessionImpl())
{
// BEGIN USER INSERT SECTION RepositoryImpl::RepositoryImpl
// END USER INSERT SECTION RepositoryImpl::RepositoryImpl
}


RepositoryImpl::~RepositoryImpl()
{
// BEGIN USER INSERT SECTION RepositoryImpl::~RepositoryImpl
// END USER INSERT SECTION RepositoryImpl::~RepositoryImpl

    component_->_remove_ref();
}


::CORBA::Object*
RepositoryImpl::obtain_executor(const char* name)
    throw (CORBA::SystemException)
{
    if (! strcmp ( name, "component" ) ) {
        return Components::EnterpriseComponent::_duplicate (component_);
    }
    
    else if (! strcmp (name, "rep_feeder")) {
        return Components::EnterpriseComponent::_duplicate (component_);
    }
    
    else if (! strcmp (name, "rep_root_proxy")) {
        return Components::EnterpriseComponent::_duplicate (component_);
    }
    
    return Components::EnterpriseComponent::_nil();
}


void
RepositoryImpl::release_executor(::CORBA::Object_ptr executor)
    throw (CORBA::SystemException)
{
    CORBA::release (executor);
}


void
RepositoryImpl::configuration_complete()
    throw (CORBA::SystemException, Components::InvalidConfiguration)
{
    component_->configuration_complete();

// BEGIN USER INSERT SECTION RepositoryImpl::configuration_complete
// END USER INSERT SECTION RepositoryImpl::configuration_complete
}


void
RepositoryImpl::set_session_context(::Components::SessionContext_ptr context)
    throw (CORBA::SystemException, Components::CCMException)
{
    #ifdef TAO_ORB
    ::DCI::CCM_Repository_Context_ptr tmp_context;
    
    tmp_context = dynamic_cast<::DCI::CCM_Repository_ContextImpl*>(context);
    
    if (tmp_context)
        context_ = ::DCI::CCM_Repository_ContextImpl::_duplicate(tmp_context);
    else
        context_ = ::DCI::CCM_Repository_ContextImpl::_nil();
        
    #else
    context_ = ::DCI::CCM_Repository_ContextImpl::_narrow(context);
    
    #endif
    component_->set_context(context_);
}


void
RepositoryImpl::ccm_activate()
    throw (CORBA::SystemException, Components::CCMException)
{
// BEGIN USER INSERT SECTION RepositoryImpl::ccm_activate
// END USER INSERT SECTION RepositoryImpl::ccm_activate
}


void
RepositoryImpl::ccm_passivate()
    throw (CORBA::SystemException, Components::CCMException)
{
// BEGIN USER INSERT SECTION RepositoryImpl::ccm_passivate
// END USER INSERT SECTION RepositoryImpl::ccm_passivate
}


void
RepositoryImpl::ccm_remove()
    throw (CORBA::SystemException, Components::CCMException)
{
// BEGIN USER INSERT SECTION RepositoryImpl::ccm_remove
// END USER INSERT SECTION RepositoryImpl::ccm_remove
}


// BEGIN USER INSERT SECTION RepositoryHomeImpl
// END USER INSERT SECTION RepositoryHomeImpl


RepositoryHomeImpl::RepositoryHomeImpl()
{
// BEGIN USER INSERT SECTION RepositoryHomeImpl::RepositoryHomeImpl
// END USER INSERT SECTION RepositoryHomeImpl::RepositoryHomeImpl
}


RepositoryHomeImpl::~RepositoryHomeImpl()
{
// BEGIN USER INSERT SECTION RepositoryHomeImpl::~RepositoryHomeImpl
// END USER INSERT SECTION RepositoryHomeImpl::~RepositoryHomeImpl

}


void
RepositoryHomeImpl::set_context(Components::HomeContext_ptr ctx)
    throw (CORBA::SystemException, Components::CCMException)
{
    context_ = Components::HomeContext::_duplicate(ctx);
}


::Components::EnterpriseComponent_ptr
RepositoryHomeImpl::create ()
    throw (CORBA::SystemException, Components::CreateFailure)
{
// BEGIN USER INSERT SECTION RepositoryHomeImpl::create
// END USER INSERT SECTION RepositoryHomeImpl::create
    return new RepositoryImpl();
}


};


//
// entry point
//
::Components::HomeExecutorBase_ptr
create_RepositoryHomeE(void)
{
// BEGIN USER INSERT SECTION create_RepositoryHome
// END USER INSERT SECTION create_RepositoryHome

    return new ::DCI::RepositoryHomeImpl();
}

