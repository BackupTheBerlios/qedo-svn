\documentclass[12pt,a4paper]{report}


\begin{document}


\title{Qedo Run-Time Environment - Documentation}
\author{Harald Boehme \\ Bertram Neubauer \\ Tom Ritter \\ Frank Stoinski}

\maketitle

\setcounter{page}{1} 

\tableofcontents


\chapter{Introduction}
\label{sec:Introduction}

The Qedo Run-Time.

...
\section{Installation}
\label{sec:Installation}
For the Installation of the run-time consult the Installation Guide.


\section{Contact}
\label{sec:Contact}

If you have any problem or if you have any comments do not hesitate to contact the other Qedo users by using the qedo-devel mailing list. You can reach it at qedo-devel@lists.berlios.de. You can also use the bug tracking system provided by the Qedo project. You can reach it at http://qedo.berlios.de. this site has all relevant information about the Qedo project. In any case you can also contact the authors directly. The email addresses are listed on the Qedo web page as well.




\chapter{Architecture}
\label{sec:Architecture}
Qedo run-tim has the following architecture.

 ...

\section{Component Server}
\label{sec:AComponentServer}
The component server. 

 ... 

\section{Component Container}
\label{sec:ComponentContainer}
The Component Container. 

...

\section{Component Installer}
\label{sec:ComponentInstaller}
The Component Installer.

...

\chapter{Usage}
\label{sec:Usage}
This section explain the options. ...

\section{Configuration File}
\label{sec:ConfigurationFile}
The Qedo run-time environment is complex software and provides a set of functionalities. Sometimes there are different ways how to provide the functionality. To allow an easy configuration of such properties at run-time (instead of compile-time) Qedo provides a configuration file. XML is used in this file, to make the integration with other tools easier. Though this file is not complex and can be edited with a normal text editor. The following will guide you through the different sections of this file.

The file is structured in sections. Each section can have nested sections or configuration values. The general form of a section is:

\begin{verbatim}
<SECTION name="SectionName">
...
</SECTION>
\end{verbatim}

The general form of an configuration value is:
\begin{verbatim}
<CONFIGVALUE name="parameter_name" value="parameter_value"/>
\end{verbatim}

For those who are familiar with the XML stuff the following DTD is used to evaluate the configuration file.

\begin{verbatim}
<!ELEMENT QEDOCONFIG (SECTION)+>

<!ELEMENT SECTION (SECTION | CONFIGVALUE)*>
<!ATTLIST SECTION name CDATA #REQUIRED>

<!ELEMENT CONFIGVALUE EMPTY>
<!ATTLIST CONFIGVALUE name CDATA #REQUIRED>
<!ATTLIST CONFIGVALUE value CDATA #REQUIRED>

\end{verbatim}
It is highly recommended to use this configuration file. Default Values are used for most of the configuration parameters if they are not set. But the beavior of the runtime might be strange if the configuration file is missing.

Qedo comes with a sample file. Normally you need to modify only a few things to adapt the runtime to your needs. The file hast to be present at the \verb ${Qedo}/etc/Qedo.conf  .     

\subsection{General}
\label{sec:General}

Within this section there are the following configuration values evaluated:
\begin{itemize}
	\item \verb VerboseOutput  if this is set \verb true  the runtime environment will print out a lot of debug information to the standard out streams. If it is set to \verb false  the output will be quiet. In case there is some trouble with the components which run on top of the Qedo run-time this switch can be used for tracing such problmes.
	\item \verb NameService  this is used to set the Name Service which is used by the run-time to establish the contact between various parts of the run-time. This will overwrite any ORB specific settings usually provided as an ORB dependent configuration file (e.g. \verb ~/.micorc ). Furthermore, it is strongly recommended not to use ORB specific mechanisms to provide reference to the name service. As value for this parameter a corbaloc format should be used. (e.g. \verb corbaloc::geist:3000/NameService ) 
	\item \verb ComponentServerKillDelay  This parameter sets the time the component server activator will wait for the termination of a component server. Sometimes the termination of a component server may hang. This is normally caused by component implementations which may hang while they get terminated. In this case the component server is directly killed by the server activator to free the resources allocated by that component server. To decide whether a component server is still terminating or is hanging this parameter can be used. After the time set in this parameter value it is assumed that the component server is hanging.
	
\end{itemize}

	
	
\subsubsection{Debug}
\label{sec:Debug}
This is a subsection of the General section.

\begin{itemize}
	\item \verb DebugMode  This setting simplifies the debugging of component implementations. If this is set \verb true  the component server which is started by the component server activator will wait after the loading of the component libraries until a key is pressed. This time can be used to start the debugger, attach it to the component server process, and to set appropriate breakpoints in the component implementation. if this is set to \verb false  the component server will work normally without a break.
\end{itemize}
	
\subsubsection{Deployment}
\label{SubDeployment}
This is a subsection of the General section.

\begin{itemize}
	\item \verb BaseDir  This parameter is used to set the directory where Assemblies and Components are stored for further processing. Make sure you have enough space on the device where the directory is.
\end{itemize}
	
	
\subsection{Events}
\label{Events}
This section is related to the Event handling of the container.
\begin{itemize}
	\item \verb EventDispatchingStrategy  This parameter can be used to set the event dispatching strategy. It can be \verb asynchronous  or \verb synchrponous  . If \verb asynchronous  is used the container will start an own event dispatching thread. This will allow components which have send an events to go on without waiting for the end of the event delivery. This is the standard behavior of an CCM Container. But in some cases it might be helpful to avoid this event dispatching thread and use synchronous communication to transmit events. In this case the component has to wait for completion of the event delivery.
	
\end{itemize}

\subsection{QoS}
\label{QoS}
This section is related to the QoS Extension of the container.
\begin{itemize}
	\item \verb EnableQoS  Since the handling of QoS extensions at rin-time will consume a certain amount of resources (i.e. CPU cycles) it is strongly recommended to dsiable this feature if you are not planing to use it. Since this feature is not yet fully implemented it shouldn't be use anyway.
	
\end{itemize}



\subsection{Streams}
\label{Streams}
This section is related to the Stream Extension of the container. This section is currently empty but will have parameters soon.

\subsection{Example configuration file}
\label{example}
\begin{verbatim}
<?xml version="1.0"?>
<!DOCTYPE QEDOCONFIG SYSTEM "QedoConfig.dtd">

<!-- Qedo Configuration File -->

<QEDOCONFIG>

<!-- General configuration -->
<SECTION name="General">

	<CONFIGVALUE name="VerboseOutput" value="false"/>
	<CONFIGVALUE name="NameService" value="corbaloc::geist:3000/NameService"/>

	<CONFIGVALUE name="ComponentServerKillDelay" value="10000"/>

	<SECTION name="Debug">
		<CONFIGVALUE name="DebugMode" value="false"/>
	</SECTION>

	<!-- deployment related configuration values -->
	<SECTION name="Deployment">
		<!-- the base directory for the deployment -->
		<CONFIGVALUE name="BaseDir" value="/home/qedo"/>
	</SECTION>
</SECTION>

	
<!-- Event related configuration -->
<SECTION name="Events">
	<CONFIGVALUE name="EventDispatchingStrategy" value="asynchronous"/>
</SECTION>

	
<!-- QoS related configuration -->
<SECTION name="QoS">
	<CONFIGVALUE name="EnableQoS" value="false"/>
</SECTION>


<!-- Streams related configuration -->
<SECTION name="Streams">
</SECTION>

</QEDOCONFIG>

\end{verbatim}


\section{Start up}
\label{sec:StartUp}
To start the tun-time environment of Qedo you need to start a number of processes. 

\subsection{Name Service}
\label{sec:NameService}

The first of all which needs to be started is the name service. This name service needs to be started once for a Qedo deployment domain. Such a domain consist of a number of computers where distributed systems (i.e. component assemblies) can be installed. How to start a name service depends on the used Name Service implementation. But you need to be sure to know the host where the name service is running and on what port the name service is listening. This information is needed for the other servers. The reference to the name service is set by using the Qedo configuration file. 

To start a name service on a specific port usually works with the following option:

\small
\begin{verbatim}

  nsd -ORBIIOPAddr inet:<hostname>:<port>

\end{verbatim}
\normalsize

\subsection{Home Finder}
\label{sec:HomeFinder}

The HomeFinder is an optional Feature which can be used to find running homes. If a HomeFinder is available it is used. If a HomeFinder is not available a warninf message would be displayed but the creation of homes continues. The Homefinder is started by calling

\small
\begin{verbatim}

  homefinder

\end{verbatim}
\normalsize

\subsection{Component Installation}
\label{sec:ComponentInstallation}
The ComponentInstallation server is an implementation of the ComponentInstallation interface defined by CCM. This server is used to install the binaries of the components. This server is mandatory. To start this server you need to call

\small
\begin{verbatim}

  qci

\end{verbatim}
\normalsize

\subsection{Component Server Activator}
\label{sec:ComponentServerActivator}

The ComponentServerActivator server is an implementation of the correspoding interface defined by CCM. This server is used to create new component server and to manage them. This server is mandatory. To start this server you need to call 

\small
\begin{verbatim}

  qcsa

\end{verbatim}
\normalsize

\subsection{Assembly Factory}
\label{sec:AssemblyFactory}

This server implements the assembly factory and assembly interface defined be CCM. This server is mandatory if you like to use the automatic deployment features of CCM. You can also create component servers and containers by yourself. In this case you do not need this server. To start the server you need to call:

\small
\begin{verbatim}

  qassf

\end{verbatim}
\normalsize

\subsection{Component Server}
\label{sec:ComponentServer}

The ComponentServer is started by the ComponentServerActivator automatically.


\chapter{Deployment}
\label{sec:Deployment}
The subdirectory Deployment of the Qedo installation directory contains all deployment related stuff. The XML file DeployedComponents.xml contains information about all installed component implementations and is used to keep those information persistent. The subdirectory ComponentPackages contains the softpackages for component implementations and assemblies. Currently for each assembly or component intended to be installed, the package has to be put there before manually. During component installation each component softpackage is unpacked into a temporary directory named by the UUID of the installed component implementation. These directories are created in the Runtime/ComponentImplementations subdirectory. Subsequently all generated servant code is also put into the Runtime/ComponentImplementations directory. The makefiles in this directory are used to generate servant code for the components. For each ORB implementation and architecture an own makefile
has to be provided. In future it will be determined by the software package descriptor elements 'os' and 'dependency'.

In order to deploy an assembly, a zip file has to be created by the assembly developer, containing an assembly descriptor, zip files for each component  and probably property file descriptors for component instances. The component zip files in turn contain a software package descriptor, the dynamic library for the components business logic and the idl file for the servant code generation.

\chapter{API Reference}
\label{sec:APIReference}

This section explains important part of the API

\section{Context}
\label{sec:Context}

The Session context


\section{container interface}
\label{sec:containerInterface}
The container interface

\end{document}

