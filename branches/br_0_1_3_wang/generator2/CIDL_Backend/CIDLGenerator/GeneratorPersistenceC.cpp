/*****************************************************************************/
/* Qedo - Quality of Service Enabled Distributed Objects                     */
/*                                                                           */
/* Copyright (c) 2002/2003 by the Qedo Team                                  */
/*                                                                           */
/* http://qedo.berlios.de                                                    */
/*                                                                           */
/* This file is part of Qedo Generator                                       */
/*                                                                           */
/* Qedo Generator is free software; you can redistribute it and/or modify    */
/* it under the terms of the GNU General Public License as published by      */
/* the Free Software Foundation; either version 2 of the License, or         */
/* (at your option) any later version.                                       */
/*                                                                           */
/* Qedo Generator is distributed in the hope that it will be useful,         */
/* but WITHOUT ANY WARRANTY; without even the implied warranty of            */
/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             */
/* GNU General Public License for more details.                              */
/*                                                                           */
/* You should have received a copy of the GNU General Public License         */
/* along with Foobar; if not, write to the Free Software                     */
/* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA */
/*                                                                           */
/*****************************************************************************/
#include "GeneratorPersistenceC.h"


namespace QEDO_CIDL_Generator {

GeneratorPersistenceC::GeneratorPersistenceC
( QEDO_ComponentRepository::CIDLRepository_impl *repository)
: CPPBase(repository), 
  m_isAbstract(true),
  m_isRef(false)
{
}

GeneratorPersistenceC::~GeneratorPersistenceC
()
{
}

void
GeneratorPersistenceC::generate(std::string target, std::string fileprefix)
{
	try { initialize(target, fileprefix); }
	catch (InitializeError) { return; }
	
	m_filename = file_prefix_ + "_PSS.cpp";
	
	out.open(m_filename.c_str());
	out << "//\n";
	out << "// generated by Qedo\n";
	out << "//\n\n";
	out << "#ifndef _" << file_prefix_ << "_PSS_C_\n";
	out << "#define _" << file_prefix_ << "_PSS_C_\n\n\n";
	out << "#include \"" << file_prefix_ << "_PSS.h\"\n";
	out << "\n// BEGIN USER INSERT SECTION file\n";
	out << "// END USER INSERT SECTION file\n";

	doGenerate();

	out << "\n#endif\n";
	out.close();
}

void
GeneratorPersistenceC::check_for_generation(IR__::Contained_ptr item)
{
	// check if item is already known
	if (item_well_known(item))
		return;

	// check if item is already in the list or currently processed
	if ((this->m_recursion_set.find(item->id())) != m_recursion_set.end() || this->already_included (item))
		return;
	else
		m_recursion_set.insert(item->id());
	
	CORBA::ULong i;
	CORBA::ULong ulLen;

	switch (item->def_kind()) 
	{
	case CORBA__::dk_Module :
	{
		IR__::ModuleDef_var a_module = IR__::ModuleDef::_narrow(item);

		// modules
		IR__::ContainedSeq_var contained_seq = a_module->contents(CORBA__::dk_Module, true);
		ulLen = contained_seq->length();
		for(i=0; i<ulLen; i++)
			check_for_generation((*contained_seq)[i]);

		// storagehomes
		contained_seq = a_module->contents(CORBA__::dk_StorageHome, true);
		ulLen = contained_seq->length();
		for(i=0; i<ulLen; i++)
			check_for_generation((*contained_seq)[i]);

		break;
	}
	case CORBA__::dk_StorageType :
	{
		IR__::StorageTypeDef_var storagetype = IR__::StorageTypeDef::_narrow(item);
		// insert this interface in generation list
		this->insert_to_generate(item);

		break;
	}
	case CORBA__::dk_StorageHome :
	{
		IR__::StorageHomeDef_var storagehome = IR__::StorageHomeDef::_narrow(item);	
		// insert this interface in generation list
		this->insert_to_generate(item);

		// managed storage type
		IR__::StorageTypeDef_var storagetype = storagehome->managed_storagetype();
		this->check_for_generation(storagetype);

		break; 
	}
	default:
		break;
	};

	m_recursion_set.erase(item->id());
};

void
GeneratorPersistenceC::genAttributeWithNomalType(IR__::AttributeDef_ptr attribute, CORBA::TCKind att_type_kind)
{
	std::string attribute_name = mapName(attribute);
	IR__::IDLType_var attr_type = attribute->type_def();

	switch ( att_type_kind )
	{
		case CORBA::tk_string:
		case CORBA::tk_wstring:
			out << map_psdl_return_type(attr_type, false) << "\n";
			out << m_class_name;
			if(m_isRef) out << "Ref";
			out << "::" << attribute_name << "(";
			out << map_psdl_parameter_type(attr_type, false) << " param)\n";
			out << "{\n";
			out.indent();
			out << "m_" << attribute_name << " = param;\n";
			out << "setModified(true);\n";
			out.unindent();
			out << "}\n\n";
	}

	out << "void\n";
	out << m_class_name;
	if(m_isRef) out << "Ref";
	out << "::" << attribute_name << "(";
	out << map_psdl_parameter_type(attr_type, true) << " param)\n";
	out << "{\n";
	out.indent();
	switch ( att_type_kind )
	{
		case CORBA::tk_string:
			out << "strcpy( m_" << attribute_name << ", param );\n";
			break;
		case CORBA::tk_wstring:
			out << "wcscpy( m_" << attribute_name << ", param );\n";
			break;
		default:
			out << "m_" << attribute_name << " = param;\n";
	}
	out << "setModified(true);\n";
	out.unindent();
	out << "}\n\n";

	// the fourth operation only for string and wstring
	if(attr_type->type()->kind()==CORBA::tk_string)
	{
		out << "void\n";
		out << m_class_name;
		if(m_isRef) out << "Ref";
		out << "::" << attribute_name << "(CORBA::String_var& param)\n";
		out << "{\n";
		out.indent();
		out << "m_" << attribute_name << " = (char*)param;\n";
		out << "setModified(true);\n";
		out.unindent();
		out << "}\n\n";
	}
	else if(attr_type->type()->kind()==CORBA::tk_wstring)
	{
		out << "void\n";
		out << m_class_name;
		if(m_isRef) out << "Ref";
		out << "::" << attribute_name << "(CORBA::WString_var& param)\n";
		out << "{\n";
		out.indent();
		out << "m_" << attribute_name << " = (char*)param;\n";
		out << "setModified(true);\n";
		out.unindent();
		out << "}\n\n";
	}
}

void
GeneratorPersistenceC::genAttributeWithOtherType(IR__::AttributeDef_ptr attribute, CORBA::TCKind att_type_kind)
{
	std::string attribute_name = mapName(attribute);
	IR__::IDLType_var attr_type = attribute->type_def();

	out << map_psdl_return_type(attr_type, false) << "\n";
	out << m_class_name;
	if(m_isRef) out << "Ref";
	out << "::" << attribute_name << "(";
	out << map_psdl_parameter_type(attr_type, false) << " param)\n";
	out << "{\n";
	out.indent();
	out << "return m_" << attribute_name << ";\n";
	out.unindent();
	out << "}\n\n";

	out << "void\n";
	out << m_class_name;
	if(m_isRef) out << "Ref";
	out << "::" << attribute_name << "(";
	out << map_psdl_parameter_type(attr_type, true) << " param)\n";
	out << "{\n";
	out.indent();
	out << "m_" << attribute_name << " = param;\n";
	out << "setModified(true);\n";
	out.unindent();
	out << "}\n\n";
}

void
GeneratorPersistenceC::doAttribute(IR__::AttributeDef_ptr attribute)
{
	out << "\n//\n// " << attribute->id() << "\n//\n";
	std::string attribute_name = mapName(attribute);
	IR__::IDLType_var attr_type = attribute->type_def();
	
	// read only
	out << map_psdl_return_type(attr_type, true) << "\n";
	out << m_class_name;
	if(m_isRef) out << "Ref";
	out << "::" << attribute_name << "() const\n";
	out << "{\n";
	out.indent();
	out << "return m_" << attribute_name << ";\n";
	out.unindent();
	out << "}\n\n";

	// not read only
	if(attribute->mode() == IR__::ATTR_NORMAL)
	{
		CORBA::TCKind att_type_kind = attr_type->type()->kind();
		switch ( att_type_kind )
		{
			case CORBA::tk_short:
			case CORBA::tk_long:
			case CORBA::tk_longlong:
			case CORBA::tk_ushort:
			case CORBA::tk_ulong:
			case CORBA::tk_ulonglong:
			case CORBA::tk_float:
			case CORBA::tk_double:
			case CORBA::tk_longdouble:
			case CORBA::tk_boolean:
			case CORBA::tk_char:
			case CORBA::tk_wchar:
			case CORBA::tk_octet:
			case CORBA::tk_string:
			case CORBA::tk_wstring:
				genAttributeWithNomalType(attribute, att_type_kind);
				break;
			default:
				genAttributeWithOtherType(attribute, att_type_kind);
		}
	}
}

void
GeneratorPersistenceC::genOperation(IR__::OperationDef_ptr operation, IR__::IDLType_ptr ret_type)
{
	out << "\n//\n// " << operation->id() << "\n//\n";
	out << map_psdl_return_type(ret_type, false) << "\n";
	out << m_class_name;
	if(m_isRef) out << "Ref";
	out << "::" << mapName(operation) << "(";

	// parameters
	IR__::ParDescriptionSeq_var pards = operation->params();
	for( CORBA::ULong i=0; i<pards->length(); i++)
	{
		IR__::ParameterDescription pardescr = (*pards)[i];
		if (pardescr.mode == IR__::PARAM_IN) {
			out << map_in_parameter_type (pardescr.type_def) << " " << string(pardescr.name);
		};
		if (pardescr.mode == IR__::PARAM_OUT) {
			out << map_out_parameter_type (pardescr.type_def) << " " << string(pardescr.name);
		};
		if (pardescr.mode == IR__::PARAM_INOUT) {
			out << map_inout_parameter_type (pardescr.type_def) << " " << string(pardescr.name);
		};
		if((i+1)!=pards->length()) { out << ", "; }
	};

	out << ")\n";
	out << "{\n// BEGIN USER INSERT SECTION " << m_class_name;
	if(m_isRef) out << "Ref";
	out << "::" << mapName(operation) << "()\n";
	out << "// END USER INSERT SECTION " << m_class_name;
	if(m_isRef) out << "Ref";
	out << "::" << mapName(operation) << "()\n}\n\n";
}

void
GeneratorPersistenceC::doOperation(IR__::OperationDef_ptr operation)
{
	genOperation(operation, operation->result_def());
}

void
GeneratorPersistenceC::genFactory(IR__::OperationDef_ptr operation, IR__::InterfaceDef_ptr inf_type, IR__::InterfaceDef_ptr inf_home )
{
	bool bFound = false;
	string strTemp = "";
	IR__::AttributeDef_var attribute = 0;

	out << "\n//\n// " << operation->id() << "\n//\n";
	IR__::IDLType_var ret_type = IR__::IDLType::_narrow(inf_type);

	out << map_psdl_return_type(ret_type, false) << "\n";
	out << m_class_name << "::" << mapName(operation) << "(";

	// parameters
	IR__::ParDescriptionSeq_var pards = operation->params();
	for( CORBA::ULong i=0; i<pards->length(); i++)
	{
		IR__::ParameterDescription pardescr = (*pards)[i];
		if (pardescr.mode == IR__::PARAM_IN) {
			out << map_in_parameter_type (pardescr.type_def) << " " << string(pardescr.name);
		};
		if (pardescr.mode == IR__::PARAM_OUT) {
			out << map_out_parameter_type (pardescr.type_def) << " " << string(pardescr.name);
		};
		if (pardescr.mode == IR__::PARAM_INOUT) {
			out << map_inout_parameter_type (pardescr.type_def) << " " << string(pardescr.name);
		};
		if((i+1)!=pards->length()) { out << ", "; }
	};

	out << ")\n";
	out << "{\n";
	out.indent();

	//++++++++++++++++++++++++++++++++++++++++
	// INSERT sentence for FACTORY
	//++++++++++++++++++++++++++++++++++++++++
	IR__::AttributeDefSeq state_members = collectStateMembers(inf_type, CORBA__::dk_default);
	out << "char* szTemp = new char[64];\n";
	out << "string strFactory = \"\";\n\n";
	out << "CatalogBase_ptr pCatalogBase = get_catalog();\n";
	out << "CatalogBaseImpl* pCBImpl = dynamic_cast <CatalogBaseImpl*> (pCatalogBase);\n\n";
	m_strName = "strFactory";

	out << m_strName << " = \"INSERT INTO pid_content (pid, ownhome) VALUES ( \";\n";
	m_strContent = "\\'";
	out << genSQLLine(m_strName, m_strContent, false, false, false);
	m_strContent = "PSSHelper::convertPidToString(m_pid)";
	out << genSQLLine(m_strName, m_strContent, false, false, false, true);
	m_strContent = "\\'";
	out << genSQLLine(m_strName, m_strContent, false, true, true);
	out << m_strName << " += \"\\\'" << inf_home->name() << "\\\' );\";\n\n";
	out << "if(!pCBImpl->ExecuteSQL(" << m_strName << ".c_str()))\n";
	out.indent();
	out << "throw CORBA::BAD_PARAM();\n\n";
	out.unindent();

	out << m_strName << " = \"INSERT INTO " << inf_home->name() << " ( pid, spid, ";

	CORBA::ULong ulLen = state_members.length();
	for(i=0; i<ulLen; i++)
	{
		attribute = IR__::AttributeDef::_narrow(state_members[i]);
		out << mapName(attribute);
		( (i+1)!=ulLen ) ? out << ", " : out << " ) \";\n";
	}

	m_strContent = "VALUES (";
	out << genSQLLine(m_strName, m_strContent, false, false, true);
	m_strContent = "\\'";
	out << genSQLLine(m_strName, m_strContent, false, false, false);
	m_strContent = "PSSHelper::convertPidToString(m_pid)";
	out << genSQLLine(m_strName, m_strContent, false, false, false, true);
	m_strContent = "\\'";
	out << genSQLLine(m_strName, m_strContent, false, true, true);
	m_strContent = "\\'";
	out << genSQLLine(m_strName, m_strContent, false, false, false);
	m_strContent = "PSSHelper::convertSpidToString(m_shortPid)";
	out << genSQLLine(m_strName, m_strContent, false, false, false, true);
	m_strContent = "\\'";
	out << genSQLLine(m_strName, m_strContent, false, true, true);

	for(i=0; i<ulLen; i++)
	{
		bFound = false;
		strTemp = "";
		attribute = IR__::AttributeDef::_narrow(state_members[i]);
		
		for(CORBA::ULong j=0; j<pards->length(); j++)
		{
			IR__::ParameterDescription pardescr = (*pards)[j];	
			strTemp = string(pardescr.name);
			if(strTemp.compare(attribute->name())==0)
			{
				bFound = true;
				break;
			}
		}
		
		if(bFound)
		{
			switch(psdl_check_type(attribute->type_def()))
			{
			case CPPBase::_SHORT:
				out << "memset(szTemp, \'\\0\', 64);\n";
				out << "sprintf(szTemp, \"%hd\", " << strTemp << ");\n";
				if((i+1)!=ulLen)
					out << m_strName << ".append(strcat(szTemp, \", \"));\n";
				else
					out << m_strName << ".append(strcat(szTemp, \" \"));\n";
				break;
			case CPPBase::_INT:
				out << "memset(szTemp, \'\\0\', 64);\n";
				out << "sprintf(szTemp, \"%d\", " << strTemp << ");\n";
				if((i+1)!=ulLen)
					out << m_strName << ".append(strcat(szTemp, \", \"));\n";
				else
					out << m_strName << ".append(strcat(szTemp, \" \"));\n";
				break;
			case CPPBase::_LONG:
				out << "memset(szTemp, \'\\0\', 64);\n";
				out << "sprintf(szTemp, \"%ld\", " << strTemp << ");\n";
				if((i+1)!=ulLen)
					out << m_strName << ".append(strcat(szTemp, \", \"));\n";
				else
					out << m_strName << ".append(strcat(szTemp, \" \"));\n";
				break;
			case CPPBase::_FLOAT:
				out << "memset(szTemp, \'\\0\', 64);\n";
				out << "sprintf(szTemp, \"%f\", " << strTemp << ");\n";
				if((i+1)!=ulLen)
					out << m_strName << ".append(strcat(szTemp, \", \"));\n";
				else
					out << m_strName << ".append(strcat(szTemp, \" \"));\n";
				break;
			case CPPBase::_DOUBLE:
				out << "memset(szTemp, \'\\0\', 64);\n";
				out << "sprintf(szTemp, \"%lf\", " << strTemp << ");\n";
				if((i+1)!=ulLen)
					out << m_strName << ".append(strcat(szTemp, \", \"));\n";
				else
					out << m_strName << ".append(strcat(szTemp, \" \"));\n";
				break;
			case CPPBase::_LONGDOUBLE:
				out << "memset(szTemp, \'\\0\', 64);\n";
				out << "sprintf(szTemp, \"%Lf\", " << strTemp << ");\n";
				if((i+1)!=ulLen)
					out << m_strName << ".append(strcat(szTemp, \", \"));\n";
				else
					out << m_strName << ".append(strcat(szTemp, \" \"));\n";
				break;
			case CPPBase::_STRING:
				m_strContent = "\\'";
				out << genSQLLine(m_strName, m_strContent, false, false, false);
				m_strContent = strTemp;
				out << genSQLLine(m_strName, m_strContent, false, false, false, true);
				m_strContent = "\\'";
				out << genSQLLine(m_strName, m_strContent, false, ((i+1)!=ulLen), true);
				break;
			case CPPBase::_BOOL:
				m_strContent = "PSSHelper::convertBool2String(" + strTemp + ")";
				out << genSQLLine(m_strName, m_strContent, false, ((i+1)!=ulLen), false, true);
				m_strContent = "";
				out << genSQLLine(m_strName, m_strContent, false, false, true);
				break;
			}
		}
		else
		{
			m_strContent = "NULL";
			out << genSQLLine(m_strName, m_strContent, false, ((i+1)!=ulLen), true);
		}
	}
	m_strContent = ");";
	out << genSQLLine(m_strName, m_strContent, false, false, false);
	//++++++++++++++++++++++++++++++++++++++++
	// end of INSERT sentence for FACTORY !!!!
	//++++++++++++++++++++++++++++++++++++++++
	
	out << "\nif(pCBImpl->ExecuteSQL(" << m_strName << ".c_str()))\n";
	out << "{\n";
	out.indent();
	out << "//use factory to create a storage object\n";
	out << "StorageObjectFactory factory = new OBNative_CosPersistentState::StorageObjectFactory_pre();\n";
	out << "CatalogBaseImpl* tmp_catalog = dynamic_cast <CatalogBaseImpl*> (m_pCatalogBase);\n";
	out << "factory = tmp_catalog->getConnector()->register_storage_object_factory(NULL, factory);\n";
	out << "StorageObjectImpl* pStorageObjectImpl = factory->create();\n";
	out << "m_lStorageObjectes.push_back(pStorageObjectImpl);\n";
	out << map_psdl_return_type(ret_type, false) << " tmp_ptr = dynamic_cast <" << map_psdl_return_type(ret_type, false) << "> (pStorageObjectImpl);\n";
	out << "\n//set values to current storageobject incarnation\n";
	out << "//How to handle with pid, spid and the other member variables not given?\n";
	for(CORBA::ULong j=0; j<pards->length(); j++)
	{
		IR__::ParameterDescription pardescr = (*pards)[j];
		out << "tmp_ptr->" << string(pardescr.name) << "(" << string(pardescr.name) << ");\n";
	}
	out << "\nreturn tmp_ptr;\n";
	out.unindent();
	out << "}\n";
	out << "else\n";
	out.indent();
	out << "throw CORBA::BAD_PARAM();\n";
	out.unindent();

	out.unindent();
	out << "\n// BEGIN USER INSERT SECTION " << m_class_name << "::" << mapName(operation) << "()\n";
	out << "// END USER INSERT SECTION " << m_class_name << "::" << mapName(operation) << "()\n}\n\n";
}

void
GeneratorPersistenceC::doFactory(IR__::FactoryDef_ptr factory, IR__::InterfaceDef_ptr inf_def)
{
	if(m_isAbstract)
	{
		IR__::AbstractStorageTypeDef_var abs_storagetype;
		IR__::AbstractStorageHomeDef_var abs_storagehome = IR__::AbstractStorageHomeDef::_narrow(inf_def);
		if(!CORBA::is_nil(abs_storagehome))
			abs_storagetype = abs_storagehome->managed_abstract_storagetype();
		if(!CORBA::is_nil(abs_storagetype))
			genFactory(factory, abs_storagetype, abs_storagehome);
	}
	else
	{
		IR__::StorageTypeDef_var storagetype;
		IR__::StorageHomeDef_var storagehome = IR__::StorageHomeDef::_narrow(inf_def);
		if(!CORBA::is_nil(storagehome))
			storagetype = storagehome->managed_storagetype();
		if(!CORBA::is_nil(storagetype))
			genFactory(factory, storagetype, storagehome);
	}
}

void
GeneratorPersistenceC::genKey(IR__::OperationDef_ptr operation, IR__::InterfaceDef_ptr inf_type, IR__::InterfaceDef_ptr inf_home, bool isRef)
{
	IR__::IDLType_var ret_type = IR__::IDLType::_narrow(inf_type);

	if(!isRef)
		out << "\n//\n// " << operation->id() << "\n//\n";
	char* szReturnType = map_psdl_return_type(ret_type, false);

	//since the definition of a abstract stoage type is not yet supported, 
	//we have to replcace the "_ptr" with "&" for operation find_by_ref_... 
	if(isRef)
	{
		char* pdest = strstr( szReturnType, "*" );
		if( pdest != NULL )
		{
			memset(pdest, '\0', 4);
			memset(pdest, '&', 1);
		}
	}
	
	out << szReturnType << "\n" << m_class_name << "::";
	isRef ? out << "find_ref_by_" : out << "find_by_";
	out << mapName(operation) << "(";

	// parameters
	IR__::ParDescriptionSeq_var pards = operation->params();
	for( CORBA::ULong i=0; i<pards->length(); i++)
	{
		IR__::ParameterDescription pardescr = (*pards)[i];
		if (pardescr.mode == IR__::PARAM_IN) {
			out << map_in_parameter_type (pardescr.type_def) << " " << string(pardescr.name);
		};
		if (pardescr.mode == IR__::PARAM_OUT) {
			out << map_out_parameter_type (pardescr.type_def) << " " << string(pardescr.name);
		};
		if (pardescr.mode == IR__::PARAM_INOUT) {
			out << map_inout_parameter_type (pardescr.type_def) << " " << string(pardescr.name);
		};

		if((i+1)!=pards->length()) { out << ", "; }
	};

	out << ")";
	
	if(!isRef)
	{
		out << "\n";
		out.indent();
		out << "throw(CosPersistentState::NotFound";
		handleException(operation);
		out << ")";
		out.unindent();
	}
	
	out << "\n{\n";
	out.indent();

	//++++++++++++++++++++++++++++++++++++++++
	// SELECT sentence for KEY
	//++++++++++++++++++++++++++++++++++++++++
	out << szReturnType << " tmp_ptr = 0;\n";
	out << "char* szTemp = new char[64];\n";
	out << "string strKey = \"\";\n\n";
	m_strName = "strKey";
	m_strContent = "SELECT pid FROM ONLY ";
	m_strContent += inf_home->name();
	out << genSQLLine(m_strName, m_strContent, true, false, true);
	m_strContent = "WHERE";
	out << genSQLLine(m_strName, m_strContent, false, false, true);

	CORBA::ULong ulLen = pards->length();

	for( i=0; i<ulLen; i++ )
	{
		IR__::ParameterDescription pardescr = (*pards)[i];
		m_strContent = string(pardescr.name);

		if(psdl_check_type(pardescr.type_def)!=CPPBase::_STRING)
			m_strContent += " =";
		else
			m_strContent += " LIKE";
		out << genSQLLine(m_strName, m_strContent, false, false, true);

		switch(psdl_check_type(pardescr.type_def))
		{
		case CPPBase::_SHORT:
			out << "memset(szTemp, \'\\0\', 64);\n";
			out << "sprintf(szTemp, \"%hd\", " << string(pardescr.name) << ");\n";
			if((i+1)!=ulLen)
				out << m_strName << ".append(strcat(szTemp, \", \"));\n";
			else
				out << m_strName << ".append(strcat(szTemp, \" \"));\n";
			break;
		case CPPBase::_INT:
			out << "memset(szTemp, \'\\0\', 64);\n";
			out << "sprintf(szTemp, \"%d\", " << string(pardescr.name) << ");\n";
			if((i+1)!=ulLen)
				out << m_strName << ".append(strcat(szTemp, \", \"));\n";
			else
				out << m_strName << ".append(strcat(szTemp, \" \"));\n";
			break;
		case CPPBase::_LONG:
			out << "memset(szTemp, \'\\0\', 64);\n";
			out << "sprintf(szTemp, \"%ld\", " << string(pardescr.name) << ");\n";
			if((i+1)!=ulLen)
				out << m_strName << ".append(strcat(szTemp, \", \"));\n";
			else
				out << m_strName << ".append(strcat(szTemp, \" \"));\n";
			break;
		case CPPBase::_FLOAT:
			out << "memset(szTemp, \'\\0\', 64);\n";
			out << "sprintf(szTemp, \"%f\", " << string(pardescr.name) << ");\n";
			if((i+1)!=ulLen)
				out << m_strName << ".append(strcat(szTemp, \", \"));\n";
			else
				out << m_strName << ".append(strcat(szTemp, \" \"));\n";
			break;
		case CPPBase::_DOUBLE:
			out << "memset(szTemp, \'\\0\', 64);\n";
			out << "sprintf(szTemp, \"%lf\", " << string(pardescr.name) << ");\n";
			if((i+1)!=ulLen)
				out << m_strName << ".append(strcat(szTemp, \", \"));\n";
			else
				out << m_strName << ".append(strcat(szTemp, \" \"));\n";
			break;
		case CPPBase::_LONGDOUBLE:
			out << "memset(szTemp, \'\\0\', 64);\n";
			out << "sprintf(szTemp, \"%Lf\", " << string(pardescr.name) << ");\n";
			if((i+1)!=ulLen)
				out << m_strName << ".append(strcat(szTemp, \", \"));\n";
			else
				out << m_strName << ".append(strcat(szTemp, \" \"));\n";
			break;
		case CPPBase::_STRING:
			m_strContent = "\\'";
			out << genSQLLine(m_strName, m_strContent, false, false, false);
			m_strContent = string(pardescr.name);
			out << genSQLLine(m_strName, m_strContent, false, false, false, true);
			m_strContent = "\\'";
			out << genSQLLine(m_strName, m_strContent, false, ((i+1)!=ulLen), true);
			break;
		case CPPBase::_BOOL:
			m_strContent = "PSSHelper::convertBool2String(" + string(pardescr.name) + ")";
			out << genSQLLine(m_strName, m_strContent, false, ((i+1)!=ulLen), false, true);
			m_strContent = "";
			out << genSQLLine(m_strName, m_strContent, false, false, true);
			break;
		}
	}
	m_strContent = ");";
	out << genSQLLine(m_strName, m_strContent, false, false, false);
	//++++++++++++++++++++++++++++++++++++++++
	// end of SELECT sentence for KEY !!!!!!!!
	//++++++++++++++++++++++++++++++++++++++++

	out << "\nif(Open(" << m_strName << ".c_str()))\n";
	out << "{\n";
	out.indent();
	out << "if (GetFieldCount()<=0)\n{\n";
	out.indent();
	out << "Close();\n";
	out << "throw CosPersistentState::NotFound();\n";
	out.unindent();
	out << "}\n\n";
	out << "unsigned char* szPid = new unsigned char[254];\n";
	out << "memset(szPid, \'\\0\', 254);\n";
	out << "GetFieldValue(0, szPid);\n";
	out << "Close();\n\n";
	out << "string strPid = \"\";\n";
	out << "strPid.append((const char*)szPid);\n";
	out << "StorageObjectBase sob = find_by_pid(strPid);\n";
	out << "tmp_ptr = dynamic_cast <" << szReturnType << "> (sob);\n";
	out.unindent();
	out << "}\n\n";
	out << "return tmp_ptr;\n";

	out.unindent();
	out << "\n// BEGIN USER INSERT SECTION " << m_class_name;
	isRef ? out << "::find_ref_by_" : out << "::find_by_";
	out << mapName(operation) << "()\n";
	out << "// END USER INSERT SECTION " << m_class_name;
	isRef ? out << "::find_ref_by_" : out << "::find_by_";
	out << mapName(operation) << "()\n}\n\n";
}

void
GeneratorPersistenceC::doKey(IR__::KeyDef_ptr key, IR__::InterfaceDef_ptr inf_def)
{
	if(m_isAbstract)
	{
		IR__::AbstractStorageTypeDef_var abs_storagetype;
		IR__::AbstractStorageHomeDef_var abs_storagehome = IR__::AbstractStorageHomeDef::_narrow(inf_def);
		if(!CORBA::is_nil(abs_storagehome))
			abs_storagetype = abs_storagehome->managed_abstract_storagetype();
		if(!CORBA::is_nil(abs_storagetype))
		{
			genKey(key, abs_storagetype, abs_storagehome, false);
			genKey(key, abs_storagetype, abs_storagehome, true);
		}
	}
	else
	{
		//??????????????????????????????????????????????????????????????????????
		//still necessary as the concrete storage home has no relational table??
		//??????????????????????????????????????????????????????????????????????
		IR__::StorageTypeDef_var storagetype;
		IR__::StorageHomeDef_var storagehome = IR__::StorageHomeDef::_narrow(inf_def);
		if(!CORBA::is_nil(storagehome))
			storagetype = storagehome->managed_storagetype();
		if(!CORBA::is_nil(storagetype))
		{
			genKey(key, storagetype, storagehome, false);
			genKey(key, storagetype, storagehome, true);
		}
	}
}

void 
GeneratorPersistenceC::doException(IR__::ExceptionDef_ptr except)
{
	out << ", " << mapFullName(except);
}

void
GeneratorPersistenceC::genAbstractObjsForConcreteType(IR__::AbstractStorageTypeDef_ptr abs_storagetype)
{
	IR__::InterfaceDefSeq_var abs_storagetype_seq = abs_storagetype->base_abstract_storagetypes();
	
	for(CORBA::ULong i=0; i<abs_storagetype_seq->length(); i++) 
	{
		handleAttribute((*abs_storagetype_seq)[i]);
		handleOperation((*abs_storagetype_seq)[i]);
	}

	handleAttribute(abs_storagetype);
	handleOperation(abs_storagetype);
}

void
GeneratorPersistenceC::genStorageTypeBody(IR__::StorageTypeDef_ptr storagetype, bool isRef)
{
	m_class_name = string(storagetype->name());

	IR__::InterfaceDefSeq_var supported_infs = storagetype->supported_interfaces();
	if(supported_infs->length()>1)
		throw CORBA::BAD_PARAM(); // is this exception appropriate?

	IR__::AbstractStorageTypeDef_var abs_storagetype = 
		IR__::AbstractStorageTypeDef::_narrow((*supported_infs)[0]);

	m_SthIter = m_SthMap.find(abs_storagetype->name());
	string strAbsStoragehomeName = m_SthIter->second;

	out << "// BEGIN USER INSERT SECTION " << m_class_name;
	isRef ? out << "Ref\n" : out << "\n";
	out << "// END USER INSERT SECTION " << m_class_name;
	isRef ? out << "Ref\n\n" : out << "\n\n";
	out << m_class_name;
	if(isRef) out << "Ref";
	out << "::" << m_class_name;
	if(isRef) out << "Ref";
	out	<< "()\n";
	out << "{\n";
	out.indent();

	//+++++++++++++++++++++++++++++++++++++++++++++++
	// SELECT sentence for m_strSelect in StorageType
	//+++++++++++++++++++++++++++++++++++++++++++++++
	out << "char* szTemp = new char[64];\n\n";
	out << "// for CatalogBase::refresh()\n";
	m_strName = "m_strSelect";
	m_strContent = "SELECT * FROM ONLY ";
	m_strContent += strAbsStoragehomeName;
	out << genSQLLine(m_strName, m_strContent, true, false, true);
	m_strContent = "WHERE pid LIKE \\'";
	out << genSQLLine(m_strName, m_strContent, false, false, false);
	m_strContent = "PSSHelper::convertPidToString(m_pid)";
	out << genSQLLine(m_strName, m_strContent, false, false, false, true);
	m_strContent = "\\';";
	out << genSQLLine(m_strName, m_strContent, false, false, false);
	out << "\n";
	//++++++++++++++++++++++++++++++++++++++++++++++++++++++
	// end of SELECT sentence for m_strSelect in StorageType
	//++++++++++++++++++++++++++++++++++++++++++++++++++++++

	//+++++++++++++++++++++++++++++++++++++++++++++++
	// UPDATE sentence for m_strUpdate in StorageType
	//+++++++++++++++++++++++++++++++++++++++++++++++
	IR__::AttributeDef_var attribute = 0;
	IR__::AttributeDefSeq state_members = collectStateMembers(storagetype, CORBA__::dk_Create);
	CORBA::ULong ulLen = state_members.length();
	out << "// for CatalogBase::flush()\n";
	m_strName = "m_strUpdate";
	m_strContent = "UPDATE ";
	m_strContent += strAbsStoragehomeName;
	m_strContent += " SET";
	out << genSQLLine(m_strName, m_strContent, true, false, true);

	for(CORBA::ULong i=0; i<ulLen; i++)
	{
		attribute = IR__::AttributeDef::_narrow(state_members[i]);
		m_strContent = mapName(attribute) + " = ";

		switch(psdl_check_type(attribute->type_def()))
		{
		case CPPBase::_SHORT:
			out << genSQLLine(m_strName, m_strContent, false, false, false);
			out << "memset(szTemp, \'\\0\', 64);\n";
			out << "sprintf(szTemp, \"%hd\", m_" << mapName(attribute) << ");\n";
			if((i+1)!=ulLen)
				out << m_strName << ".append(strcat(szTemp, \", \"));\n";
			else
				out << m_strName << ".append(strcat(szTemp, \" \"));\n";
			break;
		case CPPBase::_INT:
			out << genSQLLine(m_strName, m_strContent, false, false, false);
			out << "memset(szTemp, \'\\0\', 64);\n";
			out << "sprintf(szTemp, \"%d\", m_" << mapName(attribute) << ");\n";
			if((i+1)!=ulLen)
				out << m_strName << ".append(strcat(szTemp, \", \"));\n";
			else
				out << m_strName << ".append(strcat(szTemp, \" \"));\n";
			break;
		case CPPBase::_LONG:
			out << genSQLLine(m_strName, m_strContent, false, false, false);
			out << "memset(szTemp, \'\\0\', 64);\n";
			out << "sprintf(szTemp, \"%ld\", m_" << mapName(attribute) << ");\n";
			if((i+1)!=ulLen)
				out << m_strName << ".append(strcat(szTemp, \", \"));\n";
			else
				out << m_strName << ".append(strcat(szTemp, \" \"));\n";
			break;
		case CPPBase::_FLOAT:
			out << genSQLLine(m_strName, m_strContent, false, false, false);
			out << "memset(szTemp, \'\\0\', 64);\n";
			out << "sprintf(szTemp, \"%f\", m_" << mapName(attribute) << ");\n";
			if((i+1)!=ulLen)
				out << m_strName << ".append(strcat(szTemp, \", \"));\n";
			else
				out << m_strName << ".append(strcat(szTemp, \" \"));\n";
			break;
		case CPPBase::_DOUBLE:
			out << genSQLLine(m_strName, m_strContent, false, false, false);
			out << "memset(szTemp, \'\\0\', 64);\n";
			out << "sprintf(szTemp, \"%lf\", m_" << mapName(attribute) << ");\n";
			if((i+1)!=ulLen)
				out << m_strName << ".append(strcat(szTemp, \", \"));\n";
			else
				out << m_strName << ".append(strcat(szTemp, \" \"));\n";
			break;
		case CPPBase::_LONGDOUBLE:
			out << genSQLLine(m_strName, m_strContent, false, false, false);
			out << "memset(szTemp, \'\\0\', 64);\n";
			out << "sprintf(szTemp, \"%Lf\", m_" << mapName(attribute) << ");\n";
			if((i+1)!=ulLen)
				out << m_strName << ".append(strcat(szTemp, \", \"));\n";
			else
				out << m_strName << ".append(strcat(szTemp, \" \"));\n";
			break;
		case CPPBase::_STRING:
			m_strContent += "\\'";
			out << genSQLLine(m_strName, m_strContent, false, false, false);
			m_strContent = "m_" + mapName(attribute);
			out << genSQLLine(m_strName, m_strContent, false, false, false, true);
			m_strContent = "\\'";
			out << genSQLLine(m_strName, m_strContent, false, ((i+1)!=ulLen), true);
			break;
		case CPPBase::_BOOL:
			out << genSQLLine(m_strName, m_strContent, false, false, false);
			m_strContent = "PSSHelper::convertBool2String(m_" + mapName(attribute) + ")";
			out << genSQLLine(m_strName, m_strContent, false, ((i+1)!=ulLen), false, true);
			m_strContent = "";
			out << genSQLLine(m_strName, m_strContent, false, false, true);
			break;
		}
	}

	m_strContent = "WHERE pid LIKE \\'";
	out << genSQLLine(m_strName, m_strContent, false, false, false);
	m_strContent = "PSSHelper::convertPidToString(m_pid)";
	out << genSQLLine(m_strName, m_strContent, false, false, false, true);
	m_strContent = "\\';";
	out << genSQLLine(m_strName, m_strContent, false, false, false);
	out << "\n";
	//++++++++++++++++++++++++++++++++++++++++++++++++++++++
	// end of UPDATE sentence for m_strUpdate in StorageType
	//++++++++++++++++++++++++++++++++++++++++++++++++++++++

	out.unindent();
	out << "// BEGIN USER INSERT SECTION " << m_class_name;
	if(isRef) out << "Ref";
	out << "::" << m_class_name;
	if(isRef) out << "Ref";
	out << "()\n";
	out << "// END USER INSERT SECTION " <<m_class_name;
	if(isRef) out << "Ref";
	out << "::" << m_class_name;
	if(isRef) out << "Ref";
	out << "()\n}\n\n";
	out << m_class_name;
	if(isRef) out << "Ref";
	out << "::~" << m_class_name;
	if(isRef) out << "Ref";
	out << "()\n";
	out << "{\n// BEGIN USER INSERT SECTION " << m_class_name;
	if(isRef) out << "Ref";
	out << "::~" << m_class_name;
	if(isRef) out << "Ref";
	out << "()\n";
	out << "// END USER INSERT SECTION " <<m_class_name;
	if(isRef) out << "Ref";
	out << "::~" << m_class_name;
	if(isRef) out << "Ref";
	out << "()\n}\n\n";

	/*
	for(CORBA::ULong i = 0; i < supported_infs->length(); i++) 
	{
		IR__::AbstractStorageTypeDef_var abs_storage_type_inh;
		abs_storage_type_inh = IR__::AbstractStorageTypeDef::_narrow((*supported_infs)[i]);
		genAbstractObjsForConcreteType(abs_storage_type_inh);
	};
	*/

	m_isRef = isRef;
	genAbstractObjsForConcreteType(abs_storagetype);
	handleAttribute(storagetype);
	handleOperation(storagetype);

	out << "void\n";
	out << m_class_name;
	if(isRef) out << "Ref";
	out << "::" << "setValue(map<string, CORBA::Any> valueMap)\n";
	out << "{\n";
	out.indent();
	out << "map <string, CORBA::Any> :: const_iterator colIter;\n\n";
	out << "colIter = valueMap.find(\"pid\");\n";
	out << "colIter->second >>= m_pid;\n\n";
	out << "colIter = valueMap.find(\"spid\");\n";
	out << "colIter->second >>= m_shortPid;\n\n";

	for(CORBA::ULong i=0; i<ulLen; i++)
	{
		attribute = IR__::AttributeDef::_narrow(state_members[i]);
		out << "colIter = valueMap.find(\"" << mapName(attribute) << "\");\n";

		switch(psdl_check_type(attribute->type_def()))
		{
		case CPPBase::_SHORT:
		case CPPBase::_INT:
		case CPPBase::_LONG:
		case CPPBase::_FLOAT:
		case CPPBase::_DOUBLE:
		case CPPBase::_LONGDOUBLE:
		case CPPBase::_STRING:
			out << "colIter->second >>= m_" << mapName(attribute) << ";\n\n";
			break;
		case CPPBase::_BOOL:
			out << "colIter->second >>= CORBA::Any::to_boolean(m_" << mapName(attribute) << ");\n\n";
			break;
		}
	}

	out.unindent();
	out << "}\n\n";
}

void 
GeneratorPersistenceC::doStorageType(IR__::StorageTypeDef_ptr storagetype)
{
	out << "\n\n";	
	open_module(out, storagetype, "");
	out << "\n\n";

	// generate normal class
	genStorageTypeBody(storagetype, false);
	// generate ref class
	genStorageTypeBody(storagetype, true);

	close_module(out, storagetype);
}

void
GeneratorPersistenceC::genAbstractObjsForConcreteHome(IR__::AbstractStorageHomeDef_ptr abs_storagehome)
{
	IR__::InterfaceDefSeq_var abs_storagehome_seq = abs_storagehome->base_abstract_storagehomes();

	for(CORBA::ULong i=0; i<abs_storagehome_seq->length(); i++) 
	{
		IR__::AbstractStorageHomeDef_var abs_storagehome_inh;
		abs_storagehome_inh = IR__::AbstractStorageHomeDef::_narrow((*abs_storagehome_seq)[i]);
		m_isAbstract = true;
		handleAttribute(abs_storagehome_inh);
		handleOperation(abs_storagehome_inh);
		handleFactory(abs_storagehome_inh);
		handleKey(abs_storagehome_inh);
	}

	m_isAbstract = true;
	handleAttribute(abs_storagehome);
	handleOperation(abs_storagehome);
	handleFactory(abs_storagehome);
	handleKey(abs_storagehome);
}

void
GeneratorPersistenceC::genCreateOperation(IR__::StorageHomeDef_ptr storagehome, bool isRef)
{
	IR__::InterfaceDefSeq_var supported_infs = storagehome->supported_interfaces();
	if(supported_infs->length()>1)
		throw CORBA::BAD_PARAM(); // is this exception appropriate?
	
	IR__::AbstractStorageHomeDef_var abs_storagehome = 
		IR__::AbstractStorageHomeDef::_narrow((*supported_infs)[0]);

	string strDummy = "";
	int iLength = m_class_name.length() + 10;
	char* szRetType = map_psdl_return_type(storagehome->managed_storagetype(), false);
	IR__::AttributeDef_var attribute = 0;
		
	if(isRef)
	{
		char* pdest = strstr( szRetType, "*" );
		if( pdest != NULL )
		{
			memset(pdest, '\0', 1);
			strcat(szRetType, "Ref");
		}
	}
	
	out << szRetType << "\n" << m_class_name << "::_create(";
	out << "Pid* pid,\n";
	strDummy.append(iLength, ' ');
	out << strDummy.c_str();
	out << "ShortPid* shortPid,\n";

	IR__::AttributeDefSeq state_members = 
		collectStateMembers(storagehome->managed_storagetype(), CORBA__::dk_Create);

	CORBA::ULong ulLen = state_members.length();

	for(CORBA::ULong i=0; i<ulLen; i++)
	{
		strDummy = "";
		strDummy.append(iLength, ' ');
		out << strDummy.c_str();

		attribute = IR__::AttributeDef::_narrow(state_members[i]);
		out << map_in_parameter_type(attribute->type_def()) << " " << mapName(attribute);
		if( (i+1)!=ulLen )
			out << ",\n";
	}
	
	if(isRef)
	{
		strDummy = "";
		strDummy.append(iLength, ' ');
		out << ",\n" << strDummy.c_str() << "CosPersistentState::YieldRef yr";
	}

	out << ")\n"; 
	out << "{\n";
	out.indent();

	//+++++++++++++++++++++++++++++++++++++++++++
	// INSERT sentence for _create in storagehome
	//+++++++++++++++++++++++++++++++++++++++++++
	out << "char* szTemp = new char[64];\n";
	out << "string strInsert = \"\";\n\n";
	out << "CatalogBase_ptr pCatalogBase = get_catalog();\n";
	out << "CatalogBaseImpl* pCBImpl = dynamic_cast <CatalogBaseImpl*> (pCatalogBase);\n\n";
	m_strName = "strInsert";

	out << m_strName << " = \"INSERT INTO pid_content (pid, ownhome) VALUES ( \";\n";
	m_strContent = "\\'";
	out << genSQLLine(m_strName, m_strContent, false, false, false);
	m_strContent = "PSSHelper::convertPidToString(pid)";
	out << genSQLLine(m_strName, m_strContent, false, false, false, true);
	m_strContent = "\\'";
	out << genSQLLine(m_strName, m_strContent, false, true, true);
	out << m_strName << " += \"\\\'" << abs_storagehome->name() << "\\\' );\";\n\n";
	out << "if(!pCBImpl->ExecuteSQL(" << m_strName << ".c_str()))\n";
	out.indent();
	out << "throw CORBA::BAD_PARAM();\n\n";
	out.unindent();

	out << m_strName << " = \"INSERT INTO " << abs_storagehome->name() << " ( pid, spid, ";
	
	for(i=0; i<ulLen; i++)
	{
		attribute = IR__::AttributeDef::_narrow(state_members[i]);
		out << mapName(attribute);
		( (i+1)!=ulLen ) ? out << ", " : out << " ) \";\n";
	}
	
	out << "//Where should the pid and spid come from?\n";
	m_strContent = "VALUES (";
	out << genSQLLine(m_strName, m_strContent, false, false, true);
	m_strContent = "\\'";
	out << genSQLLine(m_strName, m_strContent, false, false, false);
	m_strContent = "PSSHelper::convertPidToString(pid)";
	out << genSQLLine(m_strName, m_strContent, false, false, false, true);
	m_strContent = "\\'";
	out << genSQLLine(m_strName, m_strContent, false, true, true);
	m_strContent = "\\'";
	out << genSQLLine(m_strName, m_strContent, false, false, false);
	m_strContent = "PSSHelper::convertSpidToString(shortPid)";
	out << genSQLLine(m_strName, m_strContent, false, false, false, true);
	m_strContent = "\\'";
	out << genSQLLine(m_strName, m_strContent, false, true, true);

	for(CORBA::ULong i=0; i<ulLen; i++)
	{
		attribute = IR__::AttributeDef::_narrow(state_members[i]);

		switch(psdl_check_type(attribute->type_def()))
		{
		case CPPBase::_SHORT:
			out << "memset(szTemp, \'\\0\', 64);\n";
			out << "sprintf(szTemp, \"%hd\", " << mapName(attribute) << ");\n";
			if((i+1)!=ulLen)
				out << m_strName << ".append(strcat(szTemp, \", \"));\n";
			else
				out << m_strName << ".append(strcat(szTemp, \" \"));\n";
			break;
		case CPPBase::_INT:
			out << "memset(szTemp, \'\\0\', 64);\n";
			out << "sprintf(szTemp, \"%d\", " << mapName(attribute) << ");\n";
			if((i+1)!=ulLen)
				out << m_strName << ".append(strcat(szTemp, \", \"));\n";
			else
				out << m_strName << ".append(strcat(szTemp, \" \"));\n";
			break;
		case CPPBase::_LONG:
			out << "memset(szTemp, \'\\0\', 64);\n";
			out << "sprintf(szTemp, \"%ld\", " << mapName(attribute) << ");\n";
			if((i+1)!=ulLen)
				out << m_strName << ".append(strcat(szTemp, \", \"));\n";
			else
				out << m_strName << ".append(strcat(szTemp, \" \"));\n";
			break;
		case CPPBase::_FLOAT:
			out << "memset(szTemp, \'\\0\', 64);\n";
			out << "sprintf(szTemp, \"%f\", " << mapName(attribute) << ");\n";
			if((i+1)!=ulLen)
				out << m_strName << ".append(strcat(szTemp, \", \"));\n";
			else
				out << m_strName << ".append(strcat(szTemp, \" \"));\n";
			break;
		case CPPBase::_DOUBLE:
			out << "memset(szTemp, \'\\0\', 64);\n";
			out << "sprintf(szTemp, \"%lf\", " << mapName(attribute) << ");\n";
			if((i+1)!=ulLen)
				out << m_strName << ".append(strcat(szTemp, \", \"));\n";
			else
				out << m_strName << ".append(strcat(szTemp, \" \"));\n";
			break;
		case CPPBase::_LONGDOUBLE:
			out << "memset(szTemp, \'\\0\', 64);\n";
			out << "sprintf(szTemp, \"%Lf\", " << mapName(attribute) << ");\n";
			if((i+1)!=ulLen)
				out << m_strName << ".append(strcat(szTemp, \", \"));\n";
			else
				out << m_strName << ".append(strcat(szTemp, \" \"));\n";
			break;
		case CPPBase::_STRING:
			m_strContent = "\\'";
			out << genSQLLine(m_strName, m_strContent, false, false, false);
			m_strContent = mapName(attribute);
			out << genSQLLine(m_strName, m_strContent, false, false, false, true);
			m_strContent = "\\'";
			out << genSQLLine(m_strName, m_strContent, false, ((i+1)!=ulLen), true);
			break;
		case CPPBase::_BOOL:
			m_strContent = "PSSHelper::convertBool2String(" + mapName(attribute) + ")";
			out << genSQLLine(m_strName, m_strContent, false, ((i+1)!=ulLen), false, true);
			m_strContent = "";
			out << genSQLLine(m_strName, m_strContent, false, false, true);
			break;
		}
	}
	m_strContent = ");";
	out << genSQLLine(m_strName, m_strContent, false, false, false);
	//++++++++++++++++++++++++++++++++++++++++++++++++++
	// end of INSERT sentence for _create in storagehome
	//++++++++++++++++++++++++++++++++++++++++++++++++++
	
	out << "\nif(pCBImpl->ExecuteSQL(" << m_strName << ".c_str()))\n";
	out << "{\n";
	out.indent();
	if(!isRef)
	{
		out << "//use factory to create a storage object\n";
		out << "StorageObjectFactory factory = new OBNative_CosPersistentState::StorageObjectFactory_pre();\n";
		out << "CatalogBaseImpl* tmp_catalog = dynamic_cast <CatalogBaseImpl*> (m_pCatalogBase);\n";
		out << "factory = tmp_catalog->getConnector()->register_storage_object_factory(NULL, factory);\n";
		out << "StorageObjectImpl* pStorageObjectImpl = factory->create();\n";
		out << "m_lStorageObjectes.push_back(pStorageObjectImpl);\n";
		out << szRetType << " tmp_ptr = dynamic_cast <" << szRetType << "> (pStorageObjectImpl);\n";
		out << "\n//set values to current storageobject incarnation\n";
		out << "//How to handle with pid and spid?\n";
		for(CORBA::ULong i=0; i<ulLen; i++)
		{
			attribute = IR__::AttributeDef::_narrow(state_members[i]);
			out << "tmp_ptr->" << mapName(attribute) << "(" << mapName(attribute) << ");\n";
		}
		out << "\nreturn tmp_ptr;\n";
	}
	else
	{
		//out << "return 0;\n";
	}

	out.unindent();
	out << "}\n";
	out << "else\n";
	out.indent();
	out << "throw CORBA::BAD_PARAM();\n";
	out.unindent();
	out.unindent();
	out << "\n// BEGIN USER INSERT SECTION " << m_class_name << "::_create()\n";
	out << "// END USER INSERT SECTION " << m_class_name << "::_create()\n}\n\n";
}

void 
GeneratorPersistenceC::doStorageHome(IR__::StorageHomeDef_ptr storagehome)
{
	m_class_name = string(storagehome->name());

	IR__::InterfaceDefSeq_var supported_infs = storagehome->supported_interfaces();
	if(supported_infs->length()>1)
		throw CORBA::BAD_PARAM(); // is this exception appropriate?

	IR__::StorageTypeDef_var storagetype = storagehome->managed_storagetype();
	IR__::AbstractStorageHomeDef_var abs_storagehome = 
		IR__::AbstractStorageHomeDef::_narrow((*supported_infs)[0]);
	IR__::AbstractStorageTypeDef_var abs_storagetype = 
		abs_storagehome->managed_abstract_storagetype();
	m_SthMap.insert( Sth_Pair(abs_storagetype->name(), abs_storagehome->name()) );
	IR__::AttributeDefSeq state_members = collectStateMembers(abs_storagetype, CORBA__::dk_Self);
	IR__::InterfaceDefSeq_var base_abs_storagehomes = abs_storagehome->base_abstract_storagehomes();

	CORBA::ULong ulLen = state_members.length();
	CORBA::ULong ulLenBaseAbsHomes = base_abs_storagehomes->length();
	IR__::AttributeDef_var attribute = 0;

	// achtung: wenn kein modul, sollte vielleicht PSS_ der prefix für alle pss sein?
	out << "\n\n";
	open_module(out, storagetype, "");
	out << "\n\n";

	out << "// BEGIN USER INSERT SECTION " << m_class_name << "\n";
	out << "// END USER INSERT SECTION " << m_class_name << "\n\n";
	out << m_class_name << "::" << m_class_name << "()\n";
	out << "{\n";
	out.indent();

	//++++++++++++++++++++++++++++++++++++++++
	// CREATE sentence 
	//++++++++++++++++++++++++++++++++++++++++
	m_strName = "strCreateTable";
	m_strContent = "CREATE TABLE ";
	m_strContent += abs_storagehome->name();
	m_strContent += " (";
	out << genSQLLine(m_strName, m_strContent, true, false, true);

	if(ulLenBaseAbsHomes==0)
	{
		m_strContent = "pid  VARCHAR(254)  NOT NULL  REFERENCES PID_CONTENT";
		out << genSQLLine(m_strName, m_strContent, false, true, true);
		m_strContent = "spid  VARCHAR(254)";
		out << genSQLLine(m_strName, m_strContent, false, true, true);
	}

	for(CORBA::ULong i=0; i<ulLen; i++)
	{
		attribute = IR__::AttributeDef::_narrow(state_members[i]);
		m_strContent = mapName(attribute);
		m_strContent += "  ";
		m_strContent.append( map_psdl2sql_type(attribute->type_def()) );
		bool isComma = ((i+1)!=ulLen) || (ulLenBaseAbsHomes==0);
		out << genSQLLine(m_strName, m_strContent, false, isComma, true);
	}

	if(ulLenBaseAbsHomes>0)
	{
		m_strContent = ") INHERITS ( ";

		for(CORBA::ULong j=0; j<ulLenBaseAbsHomes; j++)
		{
			m_strContent.append(((*base_abs_storagehomes)[j])->name());
			((j+1)!=ulLenBaseAbsHomes) ? m_strContent += ", " : m_strContent += " );";
			out << genSQLLine(m_strName, m_strContent, false, false, false);
		}
	}
	else
	{
		m_strContent = "CONSTRAINT PK_";
		m_strContent += abs_storagehome->name();
		m_strContent += " PRIMARY KEY (pid)";
		out << genSQLLine(m_strName, m_strContent, false, false, true);
		m_strContent = ");";
		out << genSQLLine(m_strName, m_strContent, false, false, false);
	}

	out << "\n";
	//++++++++++++++++++++++++++++++++++++++++
	// end of CREATE sentence !!!!!!!!!!!!!!!!
	//++++++++++++++++++++++++++++++++++++++++

	out.unindent();
	out << "// BEGIN USER INSERT SECTION " << m_class_name << "::" << m_class_name << "()\n";
	out << "// END USER INSERT SECTION " <<m_class_name << "::" << m_class_name << "()\n}\n\n";
	out << m_class_name << "::~" << m_class_name << "()\n";
	out << "{\n// BEGIN USER INSERT SECTION " << m_class_name << "::~" << m_class_name << "()\n";
	out << "// END USER INSERT SECTION " <<m_class_name << "::~" << m_class_name << "()\n}\n\n";
	
	genCreateOperation(storagehome, false);
	genCreateOperation(storagehome, true);

	/*
	for(CORBA::ULong i = 0; i < supported_infs->length(); i++)
	{
		IR__::AbstractStorageHomeDef_var abs_storagehome;
		abs_storagehome = IR__::AbstractStorageHomeDef::_narrow((*supported_infs)[i]);
		genAbstractObjsForConcreteHome(abs_storagehome);
	};
	*/
	genAbstractObjsForConcreteHome(abs_storagehome);

	m_isAbstract = false;
	handleAttribute(storagehome);
	handleOperation(storagehome);
	handleFactory(storagehome);
	handleKey(storagehome);

	close_module(out, storagetype);
}

IR__::AttributeDefSeq 
GeneratorPersistenceC::collectStateMembers(IR__::InterfaceDef_ptr inf_def, CORBA__::CollectStyle style)
{
	IR__::AttributeDefSeq state_members;

	IR__::AbstractStorageTypeDef_var abs_storagetype =
		IR__::AbstractStorageTypeDef::_narrow(inf_def);
	if(!CORBA::is_nil(abs_storagetype))
		abs_storagetype->get_state_members(state_members, style);

	IR__::StorageTypeDef_var storagetype = 
		IR__::StorageTypeDef::_narrow(inf_def);
	if(!CORBA::is_nil(storagetype))
		storagetype->get_state_members(state_members, style);

	return state_members;
}

string
GeneratorPersistenceC::genSQLLine(string strName, string strContent, bool start, bool comma, bool space, bool func)
{
	string strRet = strName;

	start ? strRet += " = " : strRet += " += ";
	if(!func) strRet += "\"";
	strRet += strContent;
	if(comma) strRet += ",";
	if(space) strRet += " ";
	if(!func) strRet += "\"";
	strRet += ";\n";

	return strRet;
}

} // namespace
