/*****************************************************************************/
/* Qedo - Quality of Service Enabled Distributed Objects                     */
/*                                                                           */
/* Copyright (c) 2002/2003 by the Qedo Team                                  */
/*                                                                           */
/* http://qedo.berlios.de                                                    */
/*                                                                           */
/* This file is part of Qedo Generator                                       */
/*                                                                           */
/* Qedo Generator is free software; you can redistribute it and/or modify    */
/* it under the terms of the GNU General Public License as published by      */
/* the Free Software Foundation; either version 2 of the License, or         */
/* (at your option) any later version.                                       */
/*                                                                           */
/* Qedo Generator is distributed in the hope that it will be useful,         */
/* but WITHOUT ANY WARRANTY; without even the implied warranty of            */
/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             */
/* GNU General Public License for more details.                              */
/*                                                                           */
/* You should have received a copy of the GNU General Public License         */
/* along with Foobar; if not, write to the Free Software                     */
/* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA */
/*                                                                           */
/*****************************************************************************/

#include "GeneratorPersistenceC.h"
#include "Debug.h"
#include <map>

using namespace std;


namespace QEDO_CIDL_Generator {

GeneratorPersistenceC::GeneratorPersistenceC
( QEDO_ComponentRepository::CIDLRepository_impl *repository)
: CPPBase(repository), isAbstract(true)
{
}

GeneratorPersistenceC::~GeneratorPersistenceC
()
{
}

void
GeneratorPersistenceC::generate(std::string target, std::string fileprefix)
{
	try { initialize(target, fileprefix); }
	catch (InitializeError) { return; }
	
	filename_ = file_prefix_ + "_PSS.cpp";
	
	out.open(filename_.c_str());
	out << "//\n";
	out << "// generated by Qedo\n";
	out << "//\n\n";
	out << "#ifndef _" << file_prefix_ << "_PSS_C_\n";
	out << "#define _" << file_prefix_ << "_PSS_C_\n\n\n";
	out << "#include \"" << file_prefix_ << "_PSS.h\"\n";
	out << "\n// BEGIN USER INSERT SECTION file\n";
	out << "// END USER INSERT SECTION file\n";

	doGenerate();

	out << "\n#endif\n";
	out.close();
}

void
GeneratorPersistenceC::check_for_generation(IR__::Contained_ptr item)
{
	//
	// check if item is already known
	//
	if (item_well_known(item))
		return;

	//
	// check if item is already in the list or currently processed
	//
	if ((this->m_recursion_set.find(item->id())) != m_recursion_set.end() || this->already_included (item))
		return;
	else
		m_recursion_set.insert(item->id());

	CORBA::ULong len;
	CORBA::ULong i;
	switch (item->def_kind()) {
	case CORBA__::dk_Module : {
		IR__::ModuleDef_var a_module = IR__::ModuleDef::_narrow(item);

		// modules
		IR__::ContainedSeq_var contained_seq = a_module->contents(CORBA__::dk_Module, true);
		len = contained_seq->length();
		for(i = 0; i < len; i++)
		{
			check_for_generation((*contained_seq)[i]);
		}

		// storagehomes
		contained_seq = a_module->contents(CORBA__::dk_StorageHome, true);
		len = contained_seq->length();
		for(i = 0; i < len; i++)
		{
			check_for_generation((*contained_seq)[i]);
		}

		break; }
	case CORBA__::dk_StorageType : {
		IR__::StorageTypeDef_var storagetype = IR__::StorageTypeDef::_narrow(item);

		// insert this interface in generation list
		this->insert_to_generate(item);

		break; }
	case CORBA__::dk_StorageHome : {
		IR__::StorageHomeDef_var storagehome = IR__::StorageHomeDef::_narrow(item);
		
		// insert this interface in generation list
		this->insert_to_generate(item);

		// managed storage type
		IR__::StorageTypeDef_var storagetype = storagehome->managed_storage_type();
		this->check_for_generation(storagetype);

		break; }
	default:
		break;
	};

	m_recursion_set.erase(item->id());
};

void
GeneratorPersistenceC::doAttribute(IR__::AttributeDef_ptr attribute)
{
	out << "\n//\n// " << attribute->id() << "\n//\n";
	std::string attribute_name = mapName(attribute);
	
	// read only
	out << map_psdl_return_type(attribute->type_def(), true) << "\n";
	out << class_name_ << "::" << attribute_name << "() const\n";
	out << "{\n";
	out.indent();
	out << "return m_" << attribute_name << ";\n";
	out.unindent();
	out << "}\n\n";

	// not read only
	if(attribute->mode() == IR__::ATTR_NORMAL)
	{
		CORBA::TCKind att_type_kind = attribute->type_def()->type()->kind();
		switch ( att_type_kind )
		{
			case CORBA::tk_short:
			case CORBA::tk_long:
			case CORBA::tk_longlong:
			case CORBA::tk_ushort:
			case CORBA::tk_ulong:
			case CORBA::tk_ulonglong:
			case CORBA::tk_float:
			case CORBA::tk_double:
			case CORBA::tk_longdouble:
			case CORBA::tk_boolean:
			case CORBA::tk_char:
			case CORBA::tk_wchar:
			case CORBA::tk_string:
			case CORBA::tk_wstring:
				genAttributeWithNomalType(attribute, att_type_kind);
				break;
			default:
				genAttributeWithOtherType(attribute, att_type_kind);
		}
	}
}

void
GeneratorPersistenceC::genAttributeWithNomalType(IR__::AttributeDef_ptr attribute, CORBA::TCKind att_type_kind)
{
	std::string attribute_name = mapName(attribute);
	out << map_psdl_return_type(attribute->type_def(), false) << "\n";
	out << class_name_ << "::" << attribute_name << "(";
	out << map_psdl_parameter_type(attribute->type_def(), false) << " param)\n";
	out << "{\n";
	out.indent();
	out << "m_" << attribute_name << " = param;\n";
	out.unindent();
	out << "}\n\n";

	out << "void\n";
	out << class_name_ << "::" << attribute_name << "(";
	out << map_psdl_parameter_type(attribute->type_def(), true) << " param)\n";
	out << "{\n";
	out.indent();
	switch ( att_type_kind )
	{
		case CORBA::tk_string:
			out << "strcpy( m_" << attribute_name << ", param );\n";
			break;
		case CORBA::tk_wstring:
			out << "wcscpy( m_" << attribute_name << ", param );\n";
			break;
		default:
			out << "m_" << attribute_name << " = param;\n";
	}
	out.unindent();
	out << "}\n\n";

	// the fourth operation only for string and wstring
	if(attribute->type_def()->type()->kind()==CORBA::tk_string)
	{
		out << "void\n";
		out << class_name_ << "::" << attribute_name << "(CORBA::String_var& param)\n";
		out << "{\n";
		out.indent();
		out << "m_" << attribute_name << " = param;\n";
		out.unindent();
		out << "}\n\n";
	}
	else if(attribute->type_def()->type()->kind()==CORBA::tk_wstring)
	{
		out << "void\n";
		out << class_name_ << "::" << attribute_name << "(CORBA::WString_var& param)\n";
		out << "{\n";
		out.indent();
		out << "m_" << attribute_name << " = param;\n";
		out.unindent();
		out << "}\n\n";
	}
}

void
GeneratorPersistenceC::genAttributeWithOtherType(IR__::AttributeDef_ptr attribute, CORBA::TCKind att_type_kind)
{
	std::string attribute_name = mapName(attribute);
	out << map_psdl_return_type(attribute->type_def(), false) << "\n";
	out << class_name_ << "::" << attribute_name << "(";
	out << map_psdl_parameter_type(attribute->type_def(), false) << " param)\n";
	out << "{\n";
	out.indent();
	out << "return m_" << attribute_name << ";\n";
	out.unindent();
	out << "}\n\n";

	out << "void\n";
	out << class_name_ << "::" << attribute_name << "(";
	out << map_psdl_parameter_type(attribute->type_def(), true) << " param)\n";
	out << "{\n";
	out.indent();
	out << "m_" << attribute_name << " = param;\n";
	out.unindent();
	out << "}\n\n";
}

void
GeneratorPersistenceC::doOperation(IR__::OperationDef_ptr operation)
{
	genOperation(operation, operation->result_def());
}

void
GeneratorPersistenceC::doFactory(IR__::FactoryDef_ptr factory, IR__::InterfaceDef_ptr inf_def)
{
	if(isAbstract)
	{
		IR__::AbstractStorageTypeDef_var abs_storagetype;
		IR__::AbstractStorageHomeDef_var abs_storagehome = IR__::AbstractStorageHomeDef::_narrow(inf_def);
		if(!CORBA::is_nil(abs_storagehome))
			abs_storagetype = abs_storagehome->managed_abstract_storage_type();
		if(!CORBA::is_nil(abs_storagetype))
			genOperation(factory, abs_storagetype);
	}
	else
	{
		IR__::StorageTypeDef_var storagetype;
		IR__::StorageHomeDef_var storagehome = IR__::StorageHomeDef::_narrow(inf_def);
		if(!CORBA::is_nil(storagehome))
			storagetype = storagehome->managed_storage_type();
		if(!CORBA::is_nil(storagetype))
			genOperation(factory, storagetype);
	}
}

void
GeneratorPersistenceC::doKey(IR__::KeyDef_ptr key, IR__::InterfaceDef_ptr inf_def)
{
	if(isAbstract)
	{
		IR__::AbstractStorageTypeDef_var abs_storagetype;
		IR__::AbstractStorageHomeDef_var abs_storagehome = IR__::AbstractStorageHomeDef::_narrow(inf_def);
		if(!CORBA::is_nil(abs_storagehome))
			abs_storagetype = abs_storagehome->managed_abstract_storage_type();
		if(!CORBA::is_nil(abs_storagetype))
		{
			genKey(key, abs_storagetype, false);
			genKey(key, abs_storagetype, true);
		}
	}
	else
	{
		IR__::StorageTypeDef_var storagetype;
		IR__::StorageHomeDef_var storagehome = IR__::StorageHomeDef::_narrow(inf_def);
		if(!CORBA::is_nil(storagehome))
			storagetype = storagehome->managed_storage_type();
		if(!CORBA::is_nil(storagetype))
		{
			genKey(key, storagetype, false);
			genKey(key, storagetype, true);
		}
	}
}

void 
GeneratorPersistenceC::doException(IR__::ExceptionDef_ptr except)
{
	out << ", " << mapFullName(except);
}

void 
GeneratorPersistenceC::doStorageType(IR__::StorageTypeDef_ptr storage_type)
{
	// achtung: wenn kein modul, sollte vielleicht PSS_ der prefix für alle pss sein?
	out << "\n\n";	
	open_module(out, storage_type, "");
	//out.unindent();
	out << "\n\n";
	
	class_name_ = string(storage_type->name());
	out << "// BEGIN USER INSERT SECTION " << class_name_ << "\n";
	out << "// END USER INSERT SECTION " << class_name_ << "\n\n";
	out << class_name_ << "::" << class_name_ << "()\n";
	out << "{\n// BEGIN USER INSERT SECTION " << class_name_ << "::" << class_name_ << "()\n";
	out << "// END USER INSERT SECTION " <<class_name_ << "::" << class_name_ << "()\n}\n\n";
	out << class_name_ << "::~" << class_name_ << "()\n";
	out << "{\n// BEGIN USER INSERT SECTION " << class_name_ << "::~" << class_name_ << "()\n";
	out << "// END USER INSERT SECTION " <<class_name_ << "::~" << class_name_ << "()\n}\n\n";

	IR__::InterfaceDefSeq_var supported_infs = storage_type->supported_interfaces();
	if(supported_infs->length()==0)
		out << "ERROR: NO SUPPORTED INTERFACES?\n";
	else
		for(CORBA::ULong i = 0; i < supported_infs->length(); i++) {
			handleAttribute((*supported_infs)[i]);
			handleOperation((*supported_infs)[i]);
		};

	handleAttribute(storage_type);
	handleOperation(storage_type);

	out << "void\n";
	out << class_name_ << "::" << "setValue(map<string, CORBA::Any> valueMap)\n";
	out << "{\n}\n\n";

	close_module(out, storage_type);
}

void 
GeneratorPersistenceC::doStorageHome(IR__::StorageHomeDef_ptr storage_home)
{
	storagehome_ = IR__::StorageHomeDef::_duplicate(storage_home);
	storagetype_ = IR__::StorageTypeDef::_duplicate(storage_home->managed_storage_type());

	// achtung: wenn kein modul, sollte vielleicht PSS_ der prefix für alle pss sein?
	out << "\n\n";
	open_module(out, storagetype_, "");
	//out.unindent();
	out << "\n\n";

	class_name_ = string(storage_home->name());
	out << "// BEGIN USER INSERT SECTION " << class_name_ << "\n";
	out << "// END USER INSERT SECTION " << class_name_ << "\n\n";
	out << class_name_ << "::" << class_name_ << "()\n";
	out << "{\n// BEGIN USER INSERT SECTION " << class_name_ << "::" << class_name_ << "()\n";
	out << "// END USER INSERT SECTION " <<class_name_ << "::" << class_name_ << "()\n}\n\n";
	out << class_name_ << "::~" << class_name_ << "()\n";
	out << "{\n// BEGIN USER INSERT SECTION " << class_name_ << "::~" << class_name_ << "()\n";
	out << "// END USER INSERT SECTION " <<class_name_ << "::~" << class_name_ << "()\n}\n\n";
	
	genCreateOperation(storage_home, false);
	genCreateOperation(storage_home, true);

	IR__::InterfaceDefSeq_var supported_infs = storage_home->supported_interfaces();
	if(supported_infs->length()==0)
		out << "ERROR: NO SUPPORTED INTERFACES?\n";
	else
		for(CORBA::ULong i = 0; i < supported_infs->length(); i++) {
			isAbstract = true;
			handleAttribute((*supported_infs)[i]);
			handleOperation((*supported_infs)[i]);
			IR__::AbstractStorageHomeDef_var abs_storagehome = 
				IR__::AbstractStorageHomeDef::_narrow((*supported_infs)[i]);
			if(!CORBA::is_nil(abs_storagehome))
				handleFactory(abs_storagehome);
			handleKey((*supported_infs)[i]);
		};

	isAbstract = false;
	handleAttribute(storage_home);
	handleOperation(storage_home);
	handleFactory(storage_home);
	handleKey(storage_home);

	close_module(out, storagetype_);
}

void
GeneratorPersistenceC::genOperation(IR__::OperationDef_ptr operation, IR__::IDLType_ptr ret_type)
{
	out << "\n//\n// " << operation->id() << "\n//\n";
	out << map_psdl_return_type(ret_type, false) << "\n";
	out << class_name_ << "::" << mapName(operation) << "(";

	//
	// parameters
	//
	IR__::ParDescriptionSeq* pards = operation->params();
	CORBA::ULong i;
	for( i= pards->length(); i > 0; i--)
	{
		if(i < pards->length()) { out << ", "; }
		IR__::ParameterDescription pardescr = (*pards)[i - 1];
		if (pardescr.mode == IR__::PARAM_IN) {
			out << map_in_parameter_type (pardescr.type_def) << " " << string(pardescr.name);
		};
		if (pardescr.mode == IR__::PARAM_OUT) {
			out << map_out_parameter_type (pardescr.type_def) << " " << string(pardescr.name);
		};
		if (pardescr.mode == IR__::PARAM_INOUT) {
			out << map_inout_parameter_type (pardescr.type_def) << " " << string(pardescr.name);
		};
	};

	out << ")\n";
	out << "{\n// BEGIN USER INSERT SECTION " << class_name_ << "::" << mapName(operation) << "()\n";
	out << "// END USER INSERT SECTION " << class_name_ << "::" << mapName(operation) << "()\n}\n\n";
}

void
GeneratorPersistenceC::genKey(IR__::OperationDef_ptr operation, IR__::IDLType_ptr ret_type, bool isRef)
{
	if(!isRef)
		out << "\n//\n// " << operation->id() << "\n//\n";
	char* szReturnType = map_psdl_return_type(ret_type, false);

	//since the definition of a abstract stoage type is not yet supported, 
	//we have to replcace the "_ptr" with "&" for operation find_by_ref_... 
	if(isRef)
	{
		char* pdest = strstr( szReturnType, "_ptr" );
		if( pdest != NULL )
		{
			memset(pdest, '\0', 4);
			memset(pdest, '&', 1);
		}
	}
	
	out << szReturnType << "\n" << class_name_ << "::";
	isRef ? out << "find_ref_by_" : out << "find_by_";
	out << mapName(operation) << "(";

	//
	// parameters
	//
	IR__::ParDescriptionSeq* pards = operation->params();
	CORBA::ULong i;
	for( i= pards->length(); i > 0; i--)
	{
		if(i < pards->length()) { out << ", "; }
		IR__::ParameterDescription pardescr = (*pards)[i - 1];
		if (pardescr.mode == IR__::PARAM_IN) {
			out << map_in_parameter_type (pardescr.type_def) << " " << string(pardescr.name);
		};
		if (pardescr.mode == IR__::PARAM_OUT) {
			out << map_out_parameter_type (pardescr.type_def) << " " << string(pardescr.name);
		};
		if (pardescr.mode == IR__::PARAM_INOUT) {
			out << map_inout_parameter_type (pardescr.type_def) << " " << string(pardescr.name);
		};
	};

	out << ")";
	
	if(!isRef)
	{
		out << "\n";
		out.indent();
		out << "throw(CosPersistentState::NotFound";
		handleException(operation);
		out << ")";
		out.unindent();
	}
	
	out << "\n{\n// BEGIN USER INSERT SECTION " << class_name_;
	isRef ? out << "::find_ref_by_" : out << "::find_by_";
	out << mapName(operation) << "()\n";
	out << "// END USER INSERT SECTION " << class_name_;
	isRef ? out << "::find_ref_by_" : out << "::find_by_";
	out << mapName(operation) << "()\n}\n\n";
}

void
GeneratorPersistenceC::genCreateOperation(IR__::StorageHomeDef_ptr storage_home, bool isRef)
{
	int iLength = class_name_.length() + 10;
	string strDummy = "";
	char* szDisplay = map_psdl_return_type(storage_home->managed_storage_type(), false);
		
	if(isRef)
	{
		char* pdest = strstr( szDisplay, "*" );
		if( pdest != NULL )
		{
			memset(pdest, '\0', 1);
			strcat(szDisplay, "Ref");
		}
	}
	
	out << szDisplay << "\n" << class_name_ << "::_create(";
	
	IR__::AttributeDefSeq state_members;
	storage_home->managed_storage_type()->get_StateMembers(state_members, CORBA__::dk_Create);
	CORBA::ULong len = state_members.length();
	for(CORBA::ULong i = 0; i < len; i++)
	{
		IR__::AttributeDef_var a_attribute = IR__::AttributeDef::_narrow(state_members[i]);
		out << map_in_parameter_type(a_attribute->type_def()) << " " << mapName(a_attribute);
		if( (i+1)!=len )
		{
			out << ",\n";
			strDummy = "";
			strDummy.append(iLength, ' ');
			out << strDummy.c_str();
		}
	}
	
	if(isRef)
	{
		strDummy = "";
		strDummy.append(iLength, ' ');
		out << ",\n" << strDummy.c_str() << "CosPersistentState::YieldRef yr";
	}

	out << ")\n"; 
	out << "{\n// BEGIN USER INSERT SECTION " << class_name_ << "::_create()\n";
	out << "// END USER INSERT SECTION " << class_name_ << "::_create()\n}\n\n";
}

} // namespace
