#include "GeneratorPersistenceH.h"
#include "Debug.h"
#include <map>

using namespace std;


namespace QEDO_CIDL_Generator {

GeneratorPersistenceH::GeneratorPersistenceH
( QEDO_ComponentRepository::CIDLRepository_impl *repository)
: CPPBase(repository)
{
}

GeneratorPersistenceH::~GeneratorPersistenceH
()
{
}

void
GeneratorPersistenceH::generate(std::string target, std::string fileprefix)
{
	try { initialize(target, fileprefix); }
	catch (InitializeError) { return; }
	
	filename_ = file_prefix_ + "_PSS.h";
	
	out.open(filename_.c_str());
	out << "//\n";
	out << "// generated by Qedo\n";
	out << "//\n\n";
	out << "#ifndef __" << file_prefix_ << "_PSS\n";
	out << "#define __" << file_prefix_ << "_PSS\n\n\n";
	out << "#include \"CORBADepends.h\"\n";
	out << "#include \"PSSStorageObject.h\"\n\n\n";

	doGenerate();

	out << "\n#endif\n";
	out.close();
}

void
GeneratorPersistenceH::check_for_generation(IR__::Contained_ptr item)
{
	//
	// check if item is already known
	//
	if (item_well_known(item))
		return;

	//
	// check if item is already in the list or currently processed
	//
	if ((this->m_recursion_set.find(item->id())) != m_recursion_set.end() || this->already_included (item))
		return;
	else
		m_recursion_set.insert(item->id());

	CORBA::ULong len;
	CORBA::ULong i;
	switch (item->def_kind()) {
	case CORBA__::dk_Module : {
		IR__::ModuleDef_var a_module = IR__::ModuleDef::_narrow(item);

		// modules
		IR__::ContainedSeq_var contained_seq = a_module->contents(CORBA__::dk_Module, true);
		len = contained_seq->length();
		for(i = 0; i < len; i++)
		{
			check_for_generation((*contained_seq)[i]);
		}

		// abstract storagehomes
		contained_seq = a_module->contents(CORBA__::dk_AbstractStorageHome, true);
		len = contained_seq->length();
		for(i = 0; i < len; i++)
		{
			check_for_generation((*contained_seq)[i]);
		}

		// storagehomes
		contained_seq = a_module->contents(CORBA__::dk_StorageHome, true);
		len = contained_seq->length();
		for(i = 0; i < len; i++)
		{
			check_for_generation((*contained_seq)[i]);
		}

		break; }
	case CORBA__::dk_AbstractStorageType : {
		IR__::AbstractStorageTypeDef_var abs_storagetype = IR__::AbstractStorageTypeDef::_narrow(item);

		// insert this interface in generation list
		this->insert_to_generate(item);

		break; }
	case CORBA__::dk_StorageType : {
		IR__::StorageTypeDef_var storagetype = IR__::StorageTypeDef::_narrow(item);

		// insert this interface in generation list
		this->insert_to_generate(item);

		break; }
    case CORBA__::dk_AbstractStorageHome : {
		IR__::AbstractStorageHomeDef_var abs_storagehome = IR__::AbstractStorageHomeDef::_narrow(item);
		
		// insert this interface in generation list
		this->insert_to_generate(item);

		// managed abstract storage type
		IR__::AbstractStorageTypeDef_var abs_storagetype = abs_storagehome->managed_abstract_storage_type();
		this->check_for_generation(abs_storagetype);

		break; }
	case CORBA__::dk_StorageHome : {
		IR__::StorageHomeDef_var storagehome = IR__::StorageHomeDef::_narrow(item);
		
		// insert this interface in generation list
		this->insert_to_generate(item);

		// managed storage type
		IR__::StorageTypeDef_var storagetype = storagehome->managed_storage_type();
		this->check_for_generation(storagetype);

		break; }
	default:
		break;
	};

	m_recursion_set.erase(item->id());
};

void
GeneratorPersistenceH::doAttribute(IR__::AttributeDef_ptr attribute)
{
	out << "\n//\n// " << attribute->id() << "\n//\n";
	std::string attribute_name = mapName(attribute);

	// read only
	out << "virtual const " << map_return_type(attribute->type_def()) << " " << attribute_name << "() const = 0;\n";

	// not read only
	if(attribute->mode() == IR__::ATTR_NORMAL)
	{
		out << "virtual void " << attribute_name << "(";
		out << map_in_parameter_type(attribute->type_def()) << " param) = 0;\n";

		out << "virtual void " << attribute_name << "(";
		out << map_attribute_type(attribute->type_def()) << " param) = 0;\n";

		// the fourth operation only for string and wstring
		if(attribute->type_def()->type()->kind()==CORBA::tk_string)
			out << "virtual void " << attribute_name << "(String_var& param) = 0;\n";
		else if(attribute->type_def()->type()->kind()==CORBA::tk_wstring)
			out << "virtual void " << attribute_name << "(WString_var& param) = 0;\n";
	}
}

void
GeneratorPersistenceH::doOperation(IR__::OperationDef_ptr operation)
{
	genOperation(operation, operation->result_def(), false);
}

void
GeneratorPersistenceH::doFactory(IR__::FactoryDef_ptr factory)
{
	genOperation(factory, abs_storagehome_, false);
	//genOperation(factory, storagehome_);
}

void
GeneratorPersistenceH::doPSSKey(IR__::PSSKeyDef_ptr psskey)
{
	genOperation(psskey, abs_storagehome_, true);
	//genOperation(psskey, storagehome_);
}

void 
GeneratorPersistenceH::doException(IR__::ExceptionDef_ptr except)
{
	out << ", " << mapFullName(except);
}

void 
GeneratorPersistenceH::doAbstractStorageType(IR__::AbstractStorageTypeDef_ptr abs_storage_type)
{
	out << "\n\n";

	// achtung: wenn kein modul, sollte vielleicht PSS_ der prefix für alle pss sein?
	open_module(out, abs_storage_type, "PSS_");
	
	//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	// generate normal class
	//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	out << "\n\n";

	std::string class_name = string(abs_storage_type->name());

	out << "class " << class_name << "\n";
	out.indent();
	
	IR__::InterfaceDefSeq_var abs_storage_types = abs_storage_type->base_abstract_storage_types();
	if(abs_storage_types->length()==0)
		out << ": public virtual CosPersistentState::StorageObject\n";
	else
		for(CORBA::ULong i = 0; i < abs_storage_types->length(); i++) {
			IR__::AbstractStorageTypeDef_ptr abs_storage_type_inh;
			abs_storage_type_inh = IR__::AbstractStorageTypeDef::_narrow((*abs_storage_types)[i]);
			i==0 ? out << ": " : out << ", ";
			out << "public virtual " << abs_storage_type_inh->name() << "\n";
		};

	out.unindent();
	out << "{\n\n";
	out << "public:\n\n";
	out.indent();
    out << class_name << "();\n";
	out << "~" << class_name << "();\n";

	handleAttribute(abs_storage_type);
	handleOperation(abs_storage_type);

	out.unindent();
	out << "};\n";
	out << "\n\n";

	//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	// generate ref class
	//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	out << "class " << class_name << "Ref\n";
	out.indent();
	
	//IR__::InterfaceDefSeq_var abs_storage_types = abs_storage_type->base_abstract_storage_types();
	if(abs_storage_types->length()==0)
		out << ": public virtual CosPersistentState::StorageObjectRef\n";
	else
		for(CORBA::ULong i = 0; i < abs_storage_types->length(); i++) {
			IR__::AbstractStorageTypeDef_ptr abs_storage_type_inh;
			abs_storage_type_inh = IR__::AbstractStorageTypeDef::_narrow((*abs_storage_types)[i]);
			i==0 ? out << ": " : out << ", ";
			out << "public virtual " << abs_storage_type_inh->name() << "Ref\n";
		};

	out.unindent();
	out << "{\n\n";
	out << "public:\n\n";
	out.indent();
    out << class_name << "();\n";
	out << "~" << class_name << "();\n";

	handleAttribute(abs_storage_type);
	handleOperation(abs_storage_type);

	out.unindent();
	out << "};\n";
	out << "\n\n";

	close_module(out, abs_storage_type);
}

void 
GeneratorPersistenceH::doStorageType(IR__::StorageTypeDef_ptr storage_type)
{
	// achtung: wenn kein modul, sollte vielleicht PSS_ der prefix für alle pss sein?
	open_module(out, storage_type, "PSS_");
	out << "\n\n";

	

	close_module(out, storage_type);
}

void 
GeneratorPersistenceH::doAbstractStorageHome(IR__::AbstractStorageHomeDef_ptr abs_storage_home)
{
	abs_storagehome_ = IR__::AbstractStorageHomeDef::_duplicate(abs_storage_home);
	abs_storagetype_ = IR__::AbstractStorageTypeDef::_duplicate(abs_storage_home->managed_abstract_storage_type());

	// achtung: wenn kein modul, sollte vielleicht PSS_ der prefix für alle pss sein?
	open_module(out, abs_storagetype_, "PSS_");
	out << "\n\n";

	std::string class_name = string(abs_storage_home->name());

	out << "class " << class_name << "\n";
	out.indent();
	
	IR__::InterfaceDefSeq_var abs_storage_homes = abs_storage_home->base_abstract_storage_homes();
	if(abs_storage_homes->length()==0)
		out << ": public virtual CosPersistentState::StorageHomeBase\n";
	else
		for(CORBA::ULong i = 0; i < abs_storage_homes->length(); i++) {
			IR__::AbstractStorageHomeDef_ptr abs_storage_home_inh;
			abs_storage_home_inh = IR__::AbstractStorageHomeDef::_narrow((*abs_storage_homes)[i]);
			i==0 ? out << ": " : out << ", ";
			out << "public virtual " << abs_storage_home_inh->name() << "\n";
		};

	out.unindent();
	out << "{\n\n";
	out << "public:\n\n";
	out.indent();
    out << class_name << "();\n";
	out << "~" << class_name << "();\n";

	handleAttribute(abs_storage_home);
	handleOperation(abs_storage_home);
	handleFactory(abs_storage_home);
	handlePSSKey(abs_storage_home);

	out.unindent();
	out << "};\n";
	out << "\n\n";

	close_module(out, abs_storagetype_);
}

void 
GeneratorPersistenceH::doStorageHome(IR__::StorageHomeDef_ptr storage_home)
{
	storagehome_ = IR__::StorageHomeDef::_duplicate(storage_home);
	storagetype_ = IR__::StorageTypeDef::_duplicate(storage_home->managed_storage_type());

	// achtung: wenn kein modul, sollte vielleicht PSS_ der prefix für alle pss sein?
	open_module(out, storagetype_, "PSS_");
	out << "\n\n";



	out << "\n\n";

	close_module(out, storagetype_);
}

void
GeneratorPersistenceH::genOperation(IR__::OperationDef_ptr operation, IR__::IDLType_ptr ret_type, bool isPSSKey)
{
	out << "\n//\n// " << operation->id() << "\n//\n";
	
	if(isPSSKey)
		out << "virtual " << map_return_type(ret_type) << " find_by_" << mapName(operation) << "(";
	else
		out << "virtual " << map_return_type(ret_type) << " " << mapName(operation) << "(";

	//
	// parameters
	//
	IR__::ParDescriptionSeq* pards = operation->params();
	CORBA::ULong i;
	for( i= pards->length(); i > 0; i--)
	{
		if(i < pards->length()) { out << ", "; }
		IR__::ParameterDescription pardescr = (*pards)[i - 1];
		if (pardescr.mode == IR__::PARAM_IN) {
			out << map_in_parameter_type (pardescr.type_def) << " " << string(pardescr.name);
		};
		if (pardescr.mode == IR__::PARAM_OUT) {
			out << map_out_parameter_type (pardescr.type_def) << " " << string(pardescr.name);
		};
		if (pardescr.mode == IR__::PARAM_INOUT) {
			out << map_inout_parameter_type (pardescr.type_def) << " " << string(pardescr.name);
		};
	};

	if(isPSSKey) {
		out.indent();
		out << "throw(CORBA::SystemException";
		handleException(operation);
		out << ");\n";
		out.unindent();
	}
	else
		out << ") = 0;\n";
}

} // namespace
