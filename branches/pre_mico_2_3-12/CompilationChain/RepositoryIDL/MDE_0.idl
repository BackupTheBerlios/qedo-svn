/*
	*********************************************************************
	
	Generated by M2C MOF2IDL
	
	Copyright (c) 2001
	IKV++ Technologies AG
	Berlin, Germany
	
	All Rights Reserved
	
	**********************************************************************
*/
    
#include <Reflective.idl>
#include <CorbaIdlTypes.idl>
#include <PrimitiveTypes.idl>

#pragma prefix ""

#ifndef _MDE_0_idl_
#define _MDE_0_idl_

module MDE
{
	module BaseIDL
	{
		interface ValueFactoryDefClass;
		typedef sequence < ValueFactoryDefClass >  ValueFactoryDefClassUList;
		
		typedef sequence < ValueFactoryDefClass >  ValueFactoryDefClassList;
		
		typedef sequence < ValueFactoryDefClass >  ValueFactoryDefClassBag;
		
		typedef sequence < ValueFactoryDefClass >  ValueFactoryDefClassSet;
		
		interface ValueFactoryDef;
		typedef sequence < ValueFactoryDef >  ValueFactoryDefUList;
		
		typedef sequence < ValueFactoryDef >  ValueFactoryDefList;
		
		typedef sequence < ValueFactoryDef >  ValueFactoryDefBag;
		
		typedef sequence < ValueFactoryDef >  ValueFactoryDefSet;
		
		interface ParameterDef;
		typedef sequence < ParameterDef >  ParameterDefUList;
		
		interface OperationDef;
		typedef sequence < OperationDef >  OperationDefSet;
		
		interface Typed;
		typedef sequence < Typed >  TypedSet;
		

/* 
class proxy::MDE::BaseIDL::Typed
*/
		interface TypedClass
			: Reflective::RefObject
		{
			readonly attribute MDE::BaseIDL::TypedSet all_of_type_typed;
		};

		interface Contained;
		typedef sequence < Contained >  ContainedSet;
		

/* 
class proxy::MDE::BaseIDL::Contained
*/
		interface ContainedClass
			: Reflective::RefObject
		{
			readonly attribute MDE::BaseIDL::ContainedSet all_of_type_contained;
		};


/* 
class proxy::MDE::BaseIDL::OperationDef
*/
		interface OperationDefClass
			: TypedClass,
			  ContainedClass
		{
			readonly attribute MDE::BaseIDL::OperationDefSet all_of_type_operation_def;
			readonly attribute MDE::BaseIDL::OperationDefSet all_of_class_operation_def;
			MDE::BaseIDL::OperationDef create_operation_def ( 
				in string identifier,
				in string repository_id,
				in string version,
				in boolean is_oneway,
				in MDE::BaseIDL::ParameterDefUList parameters,
				in string contexts) raises ( 
					Reflective::MofError);
		};


/* 
class proxy::MDE::BaseIDL::ValueFactoryDef
*/
		interface ValueFactoryDefClass
			: OperationDefClass
		{
			readonly attribute MDE::BaseIDL::ValueFactoryDefSet all_of_type_value_factory_def;
			readonly attribute MDE::BaseIDL::ValueFactoryDefSet all_of_class_value_factory_def;
			MDE::BaseIDL::ValueFactoryDef create_value_factory_def ( 
				in string identifier,
				in string repository_id,
				in string version,
				in boolean is_oneway,
				in MDE::BaseIDL::ParameterDefUList parameters,
				in string contexts) raises ( 
					Reflective::MofError);
		};

		interface ExceptionDef;
		typedef sequence < ExceptionDef >  ExceptionDefSet;
		
		interface IDLType;

/* 
::MDE::BaseIDL::Typed
*/
		interface Typed
			: TypedClass
		{
			MDE::BaseIDL::IDLType idl_type ( ) raises ( 
					Reflective::MofError);
			void set_idl_type ( 
				in MDE::BaseIDL::IDLType new_value) raises ( 
					Reflective::MofError);
		};

		interface Container;

/* 
::MDE::BaseIDL::Contained
*/
		interface Contained
			: ContainedClass
		{
			string identifier ( ) raises ( 
					Reflective::MofError);
			void set_identifier ( 
				in string new_value) raises ( 
					Reflective::MofError);
			string repository_id ( ) raises ( 
					Reflective::MofError);
			void set_repository_id ( 
				in string new_value) raises ( 
					Reflective::MofError);
			string version ( ) raises ( 
					Reflective::MofError);
			void set_version ( 
				in string new_value) raises ( 
					Reflective::MofError);
			MDE::BaseIDL::Container defined_in ( ) raises ( 
					Reflective::NotSet,
					Reflective::MofError);
			void set_defined_in ( 
				in MDE::BaseIDL::Container new_value) raises ( 
					Reflective::MofError);
			void unset_defined_in ( ) raises ( 
					Reflective::MofError);
		};


/* 
::MDE::BaseIDL::OperationDef
*/
		interface OperationDef
			: OperationDefClass,
			  Typed,
			  Contained
		{
			boolean is_oneway ( ) raises ( 
					Reflective::MofError);
			void set_is_oneway ( 
				in boolean new_value) raises ( 
					Reflective::MofError);
			MDE::BaseIDL::ParameterDefUList parameters ( ) raises ( 
					Reflective::MofError);
			void set_parameters ( 
				in MDE::BaseIDL::ParameterDefUList new_value) raises ( 
					Reflective::MofError);
			void add_parameters ( 
				in MDE::BaseIDL::ParameterDef new_element) raises ( 
					Reflective::MofError);
			void add_parameters_before ( 
				in MDE::BaseIDL::ParameterDef new_element,
				in MDE::BaseIDL::ParameterDef before_element) raises ( 
					Reflective::NotFound,
					Reflective::MofError);
			void modify_parameters ( 
				in MDE::BaseIDL::ParameterDef old_element,
				in MDE::BaseIDL::ParameterDef new_element) raises ( 
					Reflective::NotFound,
					Reflective::MofError);
			void remove_parameters ( 
				in MDE::BaseIDL::ParameterDef old_element) raises ( 
					Reflective::NotFound,
					Reflective::MofError);
			string contexts ( ) raises ( 
					Reflective::MofError);
			void set_contexts ( 
				in string new_value) raises ( 
					Reflective::MofError);
			MDE::BaseIDL::ExceptionDefSet exception_def ( ) raises ( 
					Reflective::MofError);
			void set_exception_def ( 
				in MDE::BaseIDL::ExceptionDefSet new_value) raises ( 
					Reflective::MofError);
			void add_exception_def ( 
				in MDE::BaseIDL::ExceptionDef new_element) raises ( 
					Reflective::MofError);
			void modify_exception_def ( 
				in MDE::BaseIDL::ExceptionDef old_element,
				in MDE::BaseIDL::ExceptionDef new_element) raises ( 
					Reflective::NotFound,
					Reflective::MofError);
			void remove_exception_def ( 
				in MDE::BaseIDL::ExceptionDef old_element) raises ( 
					Reflective::NotFound,
					Reflective::MofError);
		};


/* 
::MDE::BaseIDL::ValueFactoryDef
*/
		interface ValueFactoryDef
			: ValueFactoryDefClass,
			  OperationDef
		{
		};

		interface AttributeDef;
		struct GetRaisesExLink
		{
			ExceptionDef get_exception_end;
			AttributeDef get_attribute_end;
		};

		typedef sequence < GetRaisesExLink >  GetRaisesExLinkSet;
		

/* 
::MDE::BaseIDL::GetRaisesEx
*/
		interface GetRaisesEx
			: Reflective::RefAssociation
		{
			MDE::BaseIDL::GetRaisesExLinkSet all_get_raises_ex_links ( ) raises ( 
					Reflective::MofError);
			boolean exists ( 
				in MDE::BaseIDL::ExceptionDef get_exception,
				in MDE::BaseIDL::AttributeDef get_attribute) raises ( 
					Reflective::MofError);
			MDE::BaseIDL::ExceptionDefSet get_exception ( 
				in MDE::BaseIDL::AttributeDef get_attribute) raises ( 
					Reflective::MofError);
			void add ( 
				in MDE::BaseIDL::ExceptionDef get_exception,
				in MDE::BaseIDL::AttributeDef get_attribute) raises ( 
					Reflective::MofError);
			void modify_get_exception ( 
				in MDE::BaseIDL::ExceptionDef get_exception,
				in MDE::BaseIDL::AttributeDef get_attribute,
				in MDE::BaseIDL::ExceptionDef new_get_exception) raises ( 
					Reflective::MofError,
					Reflective::NotFound);
			void remove ( 
				in MDE::BaseIDL::ExceptionDef get_exception,
				in MDE::BaseIDL::AttributeDef get_attribute) raises ( 
					Reflective::MofError,
					Reflective::NotFound);
		};

		struct SetRaisesExLink
		{
			ExceptionDef set_exception_end;
			AttributeDef set_attribute_end;
		};

		typedef sequence < SetRaisesExLink >  SetRaisesExLinkSet;
		

/* 
::MDE::BaseIDL::SetRaisesEx
*/
		interface SetRaisesEx
			: Reflective::RefAssociation
		{
			MDE::BaseIDL::SetRaisesExLinkSet all_set_raises_ex_links ( ) raises ( 
					Reflective::MofError);
			boolean exists ( 
				in MDE::BaseIDL::ExceptionDef set_exception,
				in MDE::BaseIDL::AttributeDef set_attribute) raises ( 
					Reflective::MofError);
			MDE::BaseIDL::ExceptionDefSet set_exception ( 
				in MDE::BaseIDL::AttributeDef set_attribute) raises ( 
					Reflective::MofError);
			void add ( 
				in MDE::BaseIDL::ExceptionDef set_exception,
				in MDE::BaseIDL::AttributeDef set_attribute) raises ( 
					Reflective::MofError);
			void modify_set_exception ( 
				in MDE::BaseIDL::ExceptionDef set_exception,
				in MDE::BaseIDL::AttributeDef set_attribute,
				in MDE::BaseIDL::ExceptionDef new_set_exception) raises ( 
					Reflective::MofError,
					Reflective::NotFound);
			void remove ( 
				in MDE::BaseIDL::ExceptionDef set_exception,
				in MDE::BaseIDL::AttributeDef set_attribute) raises ( 
					Reflective::MofError,
					Reflective::NotFound);
		};

		interface AttributeDefClass;
		typedef sequence < AttributeDefClass >  AttributeDefClassUList;
		
		typedef sequence < AttributeDefClass >  AttributeDefClassList;
		
		typedef sequence < AttributeDefClass >  AttributeDefClassBag;
		
		typedef sequence < AttributeDefClass >  AttributeDefClassSet;
		
		typedef sequence < AttributeDef >  AttributeDefUList;
		
		typedef sequence < AttributeDef >  AttributeDefList;
		
		typedef sequence < AttributeDef >  AttributeDefBag;
		
		typedef sequence < AttributeDef >  AttributeDefSet;
		

/* 
class proxy::MDE::BaseIDL::AttributeDef
*/
		interface AttributeDefClass
			: TypedClass,
			  ContainedClass
		{
			readonly attribute MDE::BaseIDL::AttributeDefSet all_of_type_attribute_def;
			readonly attribute MDE::BaseIDL::AttributeDefSet all_of_class_attribute_def;
			MDE::BaseIDL::AttributeDef create_attribute_def ( 
				in string identifier,
				in string repository_id,
				in string version,
				in boolean is_readonly) raises ( 
					Reflective::MofError);
		};


/* 
::MDE::BaseIDL::AttributeDef
*/
		interface AttributeDef
			: AttributeDefClass,
			  Typed,
			  Contained
		{
			boolean is_readonly ( ) raises ( 
					Reflective::MofError);
			void set_is_readonly ( 
				in boolean new_value) raises ( 
					Reflective::MofError);
			MDE::BaseIDL::ExceptionDefSet set_exception ( ) raises ( 
					Reflective::MofError);
			void set_set_exception ( 
				in MDE::BaseIDL::ExceptionDefSet new_value) raises ( 
					Reflective::MofError);
			void add_set_exception ( 
				in MDE::BaseIDL::ExceptionDef new_element) raises ( 
					Reflective::MofError);
			void modify_set_exception ( 
				in MDE::BaseIDL::ExceptionDef old_element,
				in MDE::BaseIDL::ExceptionDef new_element) raises ( 
					Reflective::NotFound,
					Reflective::MofError);
			void remove_set_exception ( 
				in MDE::BaseIDL::ExceptionDef old_element) raises ( 
					Reflective::NotFound,
					Reflective::MofError);
			MDE::BaseIDL::ExceptionDefSet get_exception ( ) raises ( 
					Reflective::MofError);
			void set_get_exception ( 
				in MDE::BaseIDL::ExceptionDefSet new_value) raises ( 
					Reflective::MofError);
			void add_get_exception ( 
				in MDE::BaseIDL::ExceptionDef new_element) raises ( 
					Reflective::MofError);
			void modify_get_exception ( 
				in MDE::BaseIDL::ExceptionDef old_element,
				in MDE::BaseIDL::ExceptionDef new_element) raises ( 
					Reflective::NotFound,
					Reflective::MofError);
			void remove_get_exception ( 
				in MDE::BaseIDL::ExceptionDef old_element) raises ( 
					Reflective::NotFound,
					Reflective::MofError);
		};

		struct CanRaiseLink
		{
			OperationDef operation_def_end;
			ExceptionDef exception_def_end;
		};

		typedef sequence < CanRaiseLink >  CanRaiseLinkSet;
		

/* 
::MDE::BaseIDL::CanRaise
*/
		interface CanRaise
			: Reflective::RefAssociation
		{
			MDE::BaseIDL::CanRaiseLinkSet all_can_raise_links ( ) raises ( 
					Reflective::MofError);
			boolean exists ( 
				in MDE::BaseIDL::OperationDef operation_def,
				in MDE::BaseIDL::ExceptionDef exception_def) raises ( 
					Reflective::MofError);
			MDE::BaseIDL::ExceptionDefSet exception_def ( 
				in MDE::BaseIDL::OperationDef operation_def) raises ( 
					Reflective::MofError);
			void add ( 
				in MDE::BaseIDL::OperationDef operation_def,
				in MDE::BaseIDL::ExceptionDef exception_def) raises ( 
					Reflective::MofError);
			void modify_exception_def ( 
				in MDE::BaseIDL::OperationDef operation_def,
				in MDE::BaseIDL::ExceptionDef exception_def,
				in MDE::BaseIDL::ExceptionDef new_exception_def) raises ( 
					Reflective::MofError,
					Reflective::NotFound);
			void remove ( 
				in MDE::BaseIDL::OperationDef operation_def,
				in MDE::BaseIDL::ExceptionDef exception_def) raises ( 
					Reflective::MofError,
					Reflective::NotFound);
		};

		interface ExceptionDefClass;
		typedef sequence < ExceptionDefClass >  ExceptionDefClassUList;
		
		typedef sequence < ExceptionDefClass >  ExceptionDefClassList;
		
		typedef sequence < ExceptionDefClass >  ExceptionDefClassBag;
		
		typedef sequence < ExceptionDefClass >  ExceptionDefClassSet;
		
		typedef sequence < ExceptionDef >  ExceptionDefUList;
		
		typedef sequence < ExceptionDef >  ExceptionDefList;
		
		typedef sequence < ExceptionDef >  ExceptionDefBag;
		
		interface Field;
		typedef sequence < Field >  FieldUList;
		

/* 
class proxy::MDE::BaseIDL::ExceptionDef
*/
		interface ExceptionDefClass
			: ContainedClass
		{
			readonly attribute MDE::BaseIDL::ExceptionDefSet all_of_type_exception_def;
			readonly attribute MDE::BaseIDL::ExceptionDefSet all_of_class_exception_def;
			MDE::BaseIDL::ExceptionDef create_exception_def ( 
				in string identifier,
				in string repository_id,
				in string version,
				in string type_code,
				in MDE::BaseIDL::FieldUList members) raises ( 
					Reflective::MofError);
		};


/* 
::MDE::BaseIDL::ExceptionDef
*/
		interface ExceptionDef
			: ExceptionDefClass,
			  Contained
		{
			string type_code ( ) raises ( 
					Reflective::MofError);
			void set_type_code ( 
				in string new_value) raises ( 
					Reflective::MofError);
			MDE::BaseIDL::FieldUList members ( ) raises ( 
					Reflective::MofError);
			void set_members ( 
				in MDE::BaseIDL::FieldUList new_value) raises ( 
					Reflective::MofError);
			void add_members ( 
				in MDE::BaseIDL::Field new_element) raises ( 
					Reflective::MofError);
			void add_members_before ( 
				in MDE::BaseIDL::Field new_element,
				in MDE::BaseIDL::Field before_element) raises ( 
					Reflective::NotFound,
					Reflective::MofError);
			void modify_members ( 
				in MDE::BaseIDL::Field old_element,
				in MDE::BaseIDL::Field new_element) raises ( 
					Reflective::NotFound,
					Reflective::MofError);
			void remove_members ( 
				in MDE::BaseIDL::Field old_element) raises ( 
					Reflective::NotFound,
					Reflective::MofError);
		};

		typedef sequence < OperationDefClass >  OperationDefClassUList;
		
		typedef sequence < OperationDefClass >  OperationDefClassList;
		
		typedef sequence < OperationDefClass >  OperationDefClassBag;
		
		typedef sequence < OperationDefClass >  OperationDefClassSet;
		
		typedef sequence < OperationDef >  OperationDefUList;
		
		typedef sequence < OperationDef >  OperationDefList;
		
		typedef sequence < OperationDef >  OperationDefBag;
		
		interface ValueBoxDefClass;
		typedef sequence < ValueBoxDefClass >  ValueBoxDefClassUList;
		
		typedef sequence < ValueBoxDefClass >  ValueBoxDefClassList;
		
		typedef sequence < ValueBoxDefClass >  ValueBoxDefClassBag;
		
		typedef sequence < ValueBoxDefClass >  ValueBoxDefClassSet;
		
		interface ValueBoxDef;
		typedef sequence < ValueBoxDef >  ValueBoxDefUList;
		
		typedef sequence < ValueBoxDef >  ValueBoxDefList;
		
		typedef sequence < ValueBoxDef >  ValueBoxDefBag;
		
		typedef sequence < ValueBoxDef >  ValueBoxDefSet;
		
		interface TypedefDef;
		typedef sequence < TypedefDef >  TypedefDefSet;
		
		typedef sequence < IDLType >  IDLTypeSet;
		

/* 
class proxy::MDE::BaseIDL::IDLType
*/
		interface IDLTypeClass
			: Reflective::RefObject
		{
			readonly attribute MDE::BaseIDL::IDLTypeSet all_of_type_idltype;
		};


/* 
class proxy::MDE::BaseIDL::TypedefDef
*/
		interface TypedefDefClass
			: IDLTypeClass,
			  ContainedClass
		{
			readonly attribute MDE::BaseIDL::TypedefDefSet all_of_type_typedef_def;
		};


/* 
class proxy::MDE::BaseIDL::ValueBoxDef
*/
		interface ValueBoxDefClass
			: TypedefDefClass,
			  TypedClass
		{
			readonly attribute MDE::BaseIDL::ValueBoxDefSet all_of_type_value_box_def;
			readonly attribute MDE::BaseIDL::ValueBoxDefSet all_of_class_value_box_def;
			MDE::BaseIDL::ValueBoxDef create_value_box_def ( 
				in string identifier,
				in string repository_id,
				in string version) raises ( 
					Reflective::MofError);
		};


/* 
::MDE::BaseIDL::IDLType
*/
		interface IDLType
			: IDLTypeClass
		{
		};


/* 
::MDE::BaseIDL::TypedefDef
*/
		interface TypedefDef
			: TypedefDefClass,
			  IDLType,
			  Contained
		{
		};


/* 
::MDE::BaseIDL::ValueBoxDef
*/
		interface ValueBoxDef
			: ValueBoxDefClass,
			  TypedefDef,
			  Typed
		{
		};

		interface ValueDef;
		struct AbstractDerivedFromLink
		{
			ValueDef abstract_derived_end;
			ValueDef abstract_base_end;
		};

		typedef sequence < AbstractDerivedFromLink >  AbstractDerivedFromLinkSet;
		
		typedef sequence < ValueDef >  ValueDefSet;
		

/* 
::MDE::BaseIDL::AbstractDerivedFrom
*/
		interface AbstractDerivedFrom
			: Reflective::RefAssociation
		{
			MDE::BaseIDL::AbstractDerivedFromLinkSet all_abstract_derived_from_links ( ) raises ( 
					Reflective::MofError);
			boolean exists ( 
				in MDE::BaseIDL::ValueDef abstract_derived,
				in MDE::BaseIDL::ValueDef abstract_base) raises ( 
					Reflective::MofError);
			MDE::BaseIDL::ValueDefSet abstract_base ( 
				in MDE::BaseIDL::ValueDef abstract_derived) raises ( 
					Reflective::MofError);
			void add ( 
				in MDE::BaseIDL::ValueDef abstract_derived,
				in MDE::BaseIDL::ValueDef abstract_base) raises ( 
					Reflective::MofError);
			void modify_abstract_base ( 
				in MDE::BaseIDL::ValueDef abstract_derived,
				in MDE::BaseIDL::ValueDef abstract_base,
				in MDE::BaseIDL::ValueDef new_abstract_base) raises ( 
					Reflective::MofError,
					Reflective::NotFound);
			void remove ( 
				in MDE::BaseIDL::ValueDef abstract_derived,
				in MDE::BaseIDL::ValueDef abstract_base) raises ( 
					Reflective::MofError,
					Reflective::NotFound);
		};

		struct ValueDerivedFromLink
		{
			ValueDef base_end;
			ValueDef derived_end;
		};

		typedef sequence < ValueDerivedFromLink >  ValueDerivedFromLinkSet;
		

/* 
::MDE::BaseIDL::ValueDerivedFrom
*/
		interface ValueDerivedFrom
			: Reflective::RefAssociation
		{
			MDE::BaseIDL::ValueDerivedFromLinkSet all_value_derived_from_links ( ) raises ( 
					Reflective::MofError);
			boolean exists ( 
				in MDE::BaseIDL::ValueDef base,
				in MDE::BaseIDL::ValueDef derived) raises ( 
					Reflective::MofError);
			MDE::BaseIDL::ValueDef base ( 
				in MDE::BaseIDL::ValueDef derived) raises ( 
					Reflective::MofError);
			void add ( 
				in MDE::BaseIDL::ValueDef base,
				in MDE::BaseIDL::ValueDef derived) raises ( 
					Reflective::MofError);
			void modify_base ( 
				in MDE::BaseIDL::ValueDef base,
				in MDE::BaseIDL::ValueDef derived,
				in MDE::BaseIDL::ValueDef new_base) raises ( 
					Reflective::MofError,
					Reflective::NotFound);
			void remove ( 
				in MDE::BaseIDL::ValueDef base,
				in MDE::BaseIDL::ValueDef derived) raises ( 
					Reflective::MofError,
					Reflective::NotFound);
		};

		interface InterfaceDef;
		struct SupportssLink
		{
			ValueDef value_def_end;
			InterfaceDef interface_def_end;
		};

		typedef sequence < SupportssLink >  SupportssLinkSet;
		

/* 
::MDE::BaseIDL::supportss
*/
		interface Supportss
			: Reflective::RefAssociation
		{
			MDE::BaseIDL::SupportssLinkSet all_supportss_links ( ) raises ( 
					Reflective::MofError);
			boolean exists ( 
				in MDE::BaseIDL::ValueDef value_def,
				in MDE::BaseIDL::InterfaceDef interface_def) raises ( 
					Reflective::MofError);
			MDE::BaseIDL::InterfaceDef interface_def ( 
				in MDE::BaseIDL::ValueDef value_def) raises ( 
					Reflective::MofError);
			void add ( 
				in MDE::BaseIDL::ValueDef value_def,
				in MDE::BaseIDL::InterfaceDef interface_def) raises ( 
					Reflective::MofError);
			void modify_interface_def ( 
				in MDE::BaseIDL::ValueDef value_def,
				in MDE::BaseIDL::InterfaceDef interface_def,
				in MDE::BaseIDL::InterfaceDef new_interface_def) raises ( 
					Reflective::MofError,
					Reflective::NotFound);
			void remove ( 
				in MDE::BaseIDL::ValueDef value_def,
				in MDE::BaseIDL::InterfaceDef interface_def) raises ( 
					Reflective::MofError,
					Reflective::NotFound);
		};

		struct InterfaceDerivedFromLink
		{
			InterfaceDef base_end;
			InterfaceDef derived_end;
		};

		typedef sequence < InterfaceDerivedFromLink >  InterfaceDerivedFromLinkSet;
		
		typedef sequence < InterfaceDef >  InterfaceDefSet;
		

/* 
::MDE::BaseIDL::InterfaceDerivedFrom
*/
		interface InterfaceDerivedFrom
			: Reflective::RefAssociation
		{
			MDE::BaseIDL::InterfaceDerivedFromLinkSet all_interface_derived_from_links ( ) raises ( 
					Reflective::MofError);
			boolean exists ( 
				in MDE::BaseIDL::InterfaceDef base,
				in MDE::BaseIDL::InterfaceDef derived) raises ( 
					Reflective::MofError);
			MDE::BaseIDL::InterfaceDefSet base ( 
				in MDE::BaseIDL::InterfaceDef derived) raises ( 
					Reflective::MofError);
			void add ( 
				in MDE::BaseIDL::InterfaceDef base,
				in MDE::BaseIDL::InterfaceDef derived) raises ( 
					Reflective::MofError);
			void modify_base ( 
				in MDE::BaseIDL::InterfaceDef base,
				in MDE::BaseIDL::InterfaceDef derived,
				in MDE::BaseIDL::InterfaceDef new_base) raises ( 
					Reflective::MofError,
					Reflective::NotFound);
			void remove ( 
				in MDE::BaseIDL::InterfaceDef base,
				in MDE::BaseIDL::InterfaceDef derived) raises ( 
					Reflective::MofError,
					Reflective::NotFound);
		};

		interface InterfaceDefClass;
		typedef sequence < InterfaceDefClass >  InterfaceDefClassUList;
		
		typedef sequence < InterfaceDefClass >  InterfaceDefClassList;
		
		typedef sequence < InterfaceDefClass >  InterfaceDefClassBag;
		
		typedef sequence < InterfaceDefClass >  InterfaceDefClassSet;
		
		typedef sequence < InterfaceDef >  InterfaceDefUList;
		
		typedef sequence < InterfaceDef >  InterfaceDefList;
		
		typedef sequence < InterfaceDef >  InterfaceDefBag;
		
		typedef sequence < Container >  ContainerSet;
		

/* 
class proxy::MDE::BaseIDL::Container
*/
		interface ContainerClass
			: ContainedClass
		{
			readonly attribute MDE::BaseIDL::ContainerSet all_of_type_container;
		};


/* 
class proxy::MDE::BaseIDL::InterfaceDef
*/
		interface InterfaceDefClass
			: IDLTypeClass,
			  ContainerClass
		{
			readonly attribute MDE::BaseIDL::InterfaceDefSet all_of_type_interface_def;
			readonly attribute MDE::BaseIDL::InterfaceDefSet all_of_class_interface_def;
			MDE::BaseIDL::InterfaceDef create_interface_def ( 
				in string identifier,
				in string repository_id,
				in string version,
				in boolean is_abstract,
				in boolean is_local) raises ( 
					Reflective::MofError);
		};


/* 
::MDE::BaseIDL::DefinitionKind
*/
		enum DefinitionKind
			{
			DK_NONE,
			DK_ALL,
			DK_ATTRIBUTE,
			DK_CONSTANT,
			DK_EXCEPTION,
			DK_INTERFACE,
			DK_MODULE,
			DK_OPERATION,
			DK_TYPEDEF,
			DK_ALIAS,
			DK_STRUCT,
			DK_UNION,
			 DK_FIXED,
			DK_ENUM,
			DK_PRIMITIVE,
			DK_STRING,
			DK_SEQUENCE,
			DK_WSTRING,
			DK_ARRAY,
			DK_REPOSITORY
			};

/* 
::MDE::BaseIDL::Container
*/
		interface Container
			: ContainerClass,
			  Contained
		{

/* 
::MDE::BaseIDL::Container::lookupName
*/

/* 
returns Contained
*/
			MDE::BaseIDL::Contained lookup_name ( 
				in string search_name,
				in long long levels_to_search,
				in MDE::BaseIDL::DefinitionKind limit_to_type,
				in boolean exclude_inherited);

/* 
::MDE::BaseIDL::Container::lookup
*/
			MDE::BaseIDL::Contained lookup ( 
				in string search_name);

/* 
::MDE::BaseIDL::Container::getFilteredContents
*/

/* 
returns Contained [0..*]
*/
			MDE::BaseIDL::ContainedSet get_filtered_contents ( 
				in MDE::BaseIDL::DefinitionKind limit_to_type,
				in boolean include_inherited);
			MDE::BaseIDL::ContainedSet contents ( ) raises ( 
					Reflective::MofError);
			void set_contents ( 
				in MDE::BaseIDL::ContainedSet new_value) raises ( 
					Reflective::MofError);
			void add_contents ( 
				in MDE::BaseIDL::Contained new_element) raises ( 
					Reflective::MofError);
			void modify_contents ( 
				in MDE::BaseIDL::Contained old_element,
				in MDE::BaseIDL::Contained new_element) raises ( 
					Reflective::NotFound,
					Reflective::MofError);
			void remove_contents ( 
				in MDE::BaseIDL::Contained old_element) raises ( 
					Reflective::NotFound,
					Reflective::MofError);
		};


/* 
::MDE::BaseIDL::InterfaceDef
*/
		interface InterfaceDef
			: InterfaceDefClass,
			  IDLType,
			  Container
		{
			boolean is_abstract ( ) raises ( 
					Reflective::MofError);
			void set_is_abstract ( 
				in boolean new_value) raises ( 
					Reflective::MofError);
			boolean is_local ( ) raises ( 
					Reflective::MofError);
			void set_is_local ( 
				in boolean new_value) raises ( 
					Reflective::MofError);
			MDE::BaseIDL::InterfaceDefSet base ( ) raises ( 
					Reflective::MofError);
			void set_base ( 
				in MDE::BaseIDL::InterfaceDefSet new_value) raises ( 
					Reflective::MofError);
			void add_base ( 
				in MDE::BaseIDL::InterfaceDef new_element) raises ( 
					Reflective::MofError);
			void modify_base ( 
				in MDE::BaseIDL::InterfaceDef old_element,
				in MDE::BaseIDL::InterfaceDef new_element) raises ( 
					Reflective::NotFound,
					Reflective::MofError);
			void remove_base ( 
				in MDE::BaseIDL::InterfaceDef old_element) raises ( 
					Reflective::NotFound,
					Reflective::MofError);
		};

		interface ValueDefClass;
		typedef sequence < ValueDefClass >  ValueDefClassUList;
		
		typedef sequence < ValueDefClass >  ValueDefClassList;
		
		typedef sequence < ValueDefClass >  ValueDefClassBag;
		
		typedef sequence < ValueDefClass >  ValueDefClassSet;
		
		typedef sequence < ValueDef >  ValueDefUList;
		
		typedef sequence < ValueDef >  ValueDefList;
		
		typedef sequence < ValueDef >  ValueDefBag;
		

/* 
class proxy::MDE::BaseIDL::ValueDef
*/
		interface ValueDefClass
			: ContainerClass,
			  IDLTypeClass
		{
			readonly attribute MDE::BaseIDL::ValueDefSet all_of_type_value_def;
			readonly attribute MDE::BaseIDL::ValueDefSet all_of_class_value_def;
			MDE::BaseIDL::ValueDef create_value_def ( 
				in string identifier,
				in string repository_id,
				in string version,
				in boolean is_abstract,
				in boolean is_custom,
				in boolean is_truncatable) raises ( 
					Reflective::MofError);
		};


/* 
::MDE::BaseIDL::ValueDef
*/
		interface ValueDef
			: ValueDefClass,
			  Container,
			  IDLType
		{
			boolean is_abstract ( ) raises ( 
					Reflective::MofError);
			void set_is_abstract ( 
				in boolean new_value) raises ( 
					Reflective::MofError);
			boolean is_custom ( ) raises ( 
					Reflective::MofError);
			void set_is_custom ( 
				in boolean new_value) raises ( 
					Reflective::MofError);
			boolean is_truncatable ( ) raises ( 
					Reflective::MofError);
			void set_is_truncatable ( 
				in boolean new_value) raises ( 
					Reflective::MofError);
			MDE::BaseIDL::InterfaceDef interface_def ( ) raises ( 
					Reflective::NotSet,
					Reflective::MofError);
			void set_interface_def ( 
				in MDE::BaseIDL::InterfaceDef new_value) raises ( 
					Reflective::MofError);
			void unset_interface_def ( ) raises ( 
					Reflective::MofError);
			MDE::BaseIDL::ValueDef base ( ) raises ( 
					Reflective::NotSet,
					Reflective::MofError);
			void set_base ( 
				in MDE::BaseIDL::ValueDef new_value) raises ( 
					Reflective::MofError);
			void unset_base ( ) raises ( 
					Reflective::MofError);
			MDE::BaseIDL::ValueDefSet abstract_base ( ) raises ( 
					Reflective::MofError);
			void set_abstract_base ( 
				in MDE::BaseIDL::ValueDefSet new_value) raises ( 
					Reflective::MofError);
			void add_abstract_base ( 
				in MDE::BaseIDL::ValueDef new_element) raises ( 
					Reflective::MofError);
			void modify_abstract_base ( 
				in MDE::BaseIDL::ValueDef old_element,
				in MDE::BaseIDL::ValueDef new_element) raises ( 
					Reflective::NotFound,
					Reflective::MofError);
			void remove_abstract_base ( 
				in MDE::BaseIDL::ValueDef old_element) raises ( 
					Reflective::NotFound,
					Reflective::MofError);
		};

		interface ValueMemberDefClass;
		typedef sequence < ValueMemberDefClass >  ValueMemberDefClassUList;
		
		typedef sequence < ValueMemberDefClass >  ValueMemberDefClassList;
		
		typedef sequence < ValueMemberDefClass >  ValueMemberDefClassBag;
		
		typedef sequence < ValueMemberDefClass >  ValueMemberDefClassSet;
		
		interface ValueMemberDef;
		typedef sequence < ValueMemberDef >  ValueMemberDefUList;
		
		typedef sequence < ValueMemberDef >  ValueMemberDefList;
		
		typedef sequence < ValueMemberDef >  ValueMemberDefBag;
		
		typedef sequence < ValueMemberDef >  ValueMemberDefSet;
		

/* 
class proxy::MDE::BaseIDL::ValueMemberDef
*/
		interface ValueMemberDefClass
			: TypedClass,
			  ContainedClass
		{
			readonly attribute MDE::BaseIDL::ValueMemberDefSet all_of_type_value_member_def;
			readonly attribute MDE::BaseIDL::ValueMemberDefSet all_of_class_value_member_def;
			MDE::BaseIDL::ValueMemberDef create_value_member_def ( 
				in string identifier,
				in string repository_id,
				in string version,
				in boolean is_public_member) raises ( 
					Reflective::MofError);
		};


/* 
::MDE::BaseIDL::ValueMemberDef
*/
		interface ValueMemberDef
			: ValueMemberDefClass,
			  Typed,
			  Contained
		{
			boolean is_public_member ( ) raises ( 
					Reflective::MofError);
			void set_is_public_member ( 
				in boolean new_value) raises ( 
					Reflective::MofError);
		};


/* 
::MDE::BaseIDL::PrimitiveKind
*/
		enum PrimitiveKind
			{
			 PK_VOID,
			PK_SHORT,
			 PK_LONG,
			 PK_USHORT,
			PK_ULONG,
			PK_FLOAT,
			PK_DOUBLE,
			PK_BOOLEAN,
			PK_CHAR,
			PK_OCTET,
			PK_ANY,
			PK_LONGDOUBLE,
			 PK_WSTRING,
			PK_TYPECODE,
			PK_WCHAR,
			PK_STRING,
			PK_ULONGLONG,
			PK_OBJREF,
			 PK_LONGLONG
			};
		typedef sequence < PrimitiveKind >  PrimitiveKindUList;
		
		typedef sequence < PrimitiveKind >  PrimitiveKindList;
		
		typedef sequence < PrimitiveKind >  PrimitiveKindBag;
		
		typedef sequence < PrimitiveKind >  PrimitiveKindSet;
		
		interface PrimitiveDefClass;
		typedef sequence < PrimitiveDefClass >  PrimitiveDefClassUList;
		
		typedef sequence < PrimitiveDefClass >  PrimitiveDefClassList;
		
		typedef sequence < PrimitiveDefClass >  PrimitiveDefClassBag;
		
		typedef sequence < PrimitiveDefClass >  PrimitiveDefClassSet;
		
		interface PrimitiveDef;
		typedef sequence < PrimitiveDef >  PrimitiveDefUList;
		
		typedef sequence < PrimitiveDef >  PrimitiveDefList;
		
		typedef sequence < PrimitiveDef >  PrimitiveDefBag;
		
		typedef sequence < PrimitiveDef >  PrimitiveDefSet;
		

/* 
class proxy::MDE::BaseIDL::PrimitiveDef
*/
		interface PrimitiveDefClass
			: IDLTypeClass
		{
			readonly attribute MDE::BaseIDL::PrimitiveDefSet all_of_type_primitive_def;
			readonly attribute MDE::BaseIDL::PrimitiveDefSet all_of_class_primitive_def;
			MDE::BaseIDL::PrimitiveDef create_primitive_def ( 
				in MDE::BaseIDL::PrimitiveKind kind) raises ( 
					Reflective::MofError);
		};


/* 
::MDE::BaseIDL::PrimitiveDef
*/
		interface PrimitiveDef
			: PrimitiveDefClass,
			  IDLType
		{
			MDE::BaseIDL::PrimitiveKind kind ( ) raises ( 
					Reflective::MofError);
			void set_kind ( 
				in MDE::BaseIDL::PrimitiveKind new_value) raises ( 
					Reflective::MofError);
		};

		interface ArrayDefClass;
		typedef sequence < ArrayDefClass >  ArrayDefClassUList;
		
		typedef sequence < ArrayDefClass >  ArrayDefClassList;
		
		typedef sequence < ArrayDefClass >  ArrayDefClassBag;
		
		typedef sequence < ArrayDefClass >  ArrayDefClassSet;
		
		interface ArrayDef;
		typedef sequence < ArrayDef >  ArrayDefUList;
		
		typedef sequence < ArrayDef >  ArrayDefList;
		
		typedef sequence < ArrayDef >  ArrayDefBag;
		
		typedef sequence < ArrayDef >  ArrayDefSet;
		

/* 
class proxy::MDE::BaseIDL::ArrayDef
*/
		interface ArrayDefClass
			: TypedClass,
			  IDLTypeClass
		{
			readonly attribute MDE::BaseIDL::ArrayDefSet all_of_type_array_def;
			readonly attribute MDE::BaseIDL::ArrayDefSet all_of_class_array_def;
			MDE::BaseIDL::ArrayDef create_array_def ( 
				in unsigned long bound) raises ( 
					Reflective::MofError);
		};


/* 
::MDE::BaseIDL::ArrayDef
*/
		interface ArrayDef
			: ArrayDefClass,
			  Typed,
			  IDLType
		{
			unsigned long bound ( ) raises ( 
					Reflective::MofError);
			void set_bound ( 
				in unsigned long new_value) raises ( 
					Reflective::MofError);
		};

		interface SequenceDefClass;
		typedef sequence < SequenceDefClass >  SequenceDefClassUList;
		
		typedef sequence < SequenceDefClass >  SequenceDefClassList;
		
		typedef sequence < SequenceDefClass >  SequenceDefClassBag;
		
		typedef sequence < SequenceDefClass >  SequenceDefClassSet;
		
		interface SequenceDef;
		typedef sequence < SequenceDef >  SequenceDefUList;
		
		typedef sequence < SequenceDef >  SequenceDefList;
		
		typedef sequence < SequenceDef >  SequenceDefBag;
		
		typedef sequence < SequenceDef >  SequenceDefSet;
		

/* 
class proxy::MDE::BaseIDL::SequenceDef
*/
		interface SequenceDefClass
			: TypedClass,
			  IDLTypeClass
		{
			readonly attribute MDE::BaseIDL::SequenceDefSet all_of_type_sequence_def;
			readonly attribute MDE::BaseIDL::SequenceDefSet all_of_class_sequence_def;
			MDE::BaseIDL::SequenceDef create_sequence_def ( 
				in unsigned long bound) raises ( 
					Reflective::MofError);
		};


/* 
::MDE::BaseIDL::SequenceDef
*/
		interface SequenceDef
			: SequenceDefClass,
			  Typed,
			  IDLType
		{
			unsigned long bound ( ) raises ( 
					Reflective::MofError);
			void set_bound ( 
				in unsigned long new_value) raises ( 
					Reflective::MofError);
		};

		interface FixedDefClass;
		typedef sequence < FixedDefClass >  FixedDefClassUList;
		
		typedef sequence < FixedDefClass >  FixedDefClassList;
		
		typedef sequence < FixedDefClass >  FixedDefClassBag;
		
		typedef sequence < FixedDefClass >  FixedDefClassSet;
		
		interface FixedDef;
		typedef sequence < FixedDef >  FixedDefUList;
		
		typedef sequence < FixedDef >  FixedDefList;
		
		typedef sequence < FixedDef >  FixedDefBag;
		
		typedef sequence < FixedDef >  FixedDefSet;
		

/* 
class proxy::MDE::BaseIDL::FixedDef
*/
		interface FixedDefClass
			: IDLTypeClass
		{
			readonly attribute MDE::BaseIDL::FixedDefSet all_of_type_fixed_def;
			readonly attribute MDE::BaseIDL::FixedDefSet all_of_class_fixed_def;
			MDE::BaseIDL::FixedDef create_fixed_def ( 
				in short digits,
				in short scale) raises ( 
					Reflective::MofError);
		};


/* 
::MDE::BaseIDL::FixedDef
*/
		interface FixedDef
			: FixedDefClass,
			  IDLType
		{
			short digits ( ) raises ( 
					Reflective::MofError);
			void set_digits ( 
				in short new_value) raises ( 
					Reflective::MofError);
			short scale ( ) raises ( 
					Reflective::MofError);
			void set_scale ( 
				in short new_value) raises ( 
					Reflective::MofError);
		};

		interface WstringDefClass;
		typedef sequence < WstringDefClass >  WstringDefClassUList;
		
		typedef sequence < WstringDefClass >  WstringDefClassList;
		
		typedef sequence < WstringDefClass >  WstringDefClassBag;
		
		typedef sequence < WstringDefClass >  WstringDefClassSet;
		
		interface WstringDef;
		typedef sequence < WstringDef >  WstringDefUList;
		
		typedef sequence < WstringDef >  WstringDefList;
		
		typedef sequence < WstringDef >  WstringDefBag;
		
		typedef sequence < WstringDef >  WstringDefSet;
		

/* 
class proxy::MDE::BaseIDL::WstringDef
*/
		interface WstringDefClass
			: IDLTypeClass
		{
			readonly attribute MDE::BaseIDL::WstringDefSet all_of_type_wstring_def;
			readonly attribute MDE::BaseIDL::WstringDefSet all_of_class_wstring_def;
			MDE::BaseIDL::WstringDef create_wstring_def ( 
				in unsigned long bound) raises ( 
					Reflective::MofError);
		};


/* 
::MDE::BaseIDL::WstringDef
*/
		interface WstringDef
			: WstringDefClass,
			  IDLType
		{
			unsigned long bound ( ) raises ( 
					Reflective::MofError);
			void set_bound ( 
				in unsigned long new_value) raises ( 
					Reflective::MofError);
		};

		interface StringDefClass;
		typedef sequence < StringDefClass >  StringDefClassUList;
		
		typedef sequence < StringDefClass >  StringDefClassList;
		
		typedef sequence < StringDefClass >  StringDefClassBag;
		
		typedef sequence < StringDefClass >  StringDefClassSet;
		
		interface StringDef;
		typedef sequence < StringDef >  StringDefUList;
		
		typedef sequence < StringDef >  StringDefList;
		
		typedef sequence < StringDef >  StringDefBag;
		
		typedef sequence < StringDef >  StringDefSet;
		

/* 
class proxy::MDE::BaseIDL::StringDef
*/
		interface StringDefClass
			: IDLTypeClass
		{
			readonly attribute MDE::BaseIDL::StringDefSet all_of_type_string_def;
			readonly attribute MDE::BaseIDL::StringDefSet all_of_class_string_def;
			MDE::BaseIDL::StringDef create_string_def ( 
				in unsigned long bound) raises ( 
					Reflective::MofError);
		};


/* 
::MDE::BaseIDL::StringDef
*/
		interface StringDef
			: StringDefClass,
			  IDLType
		{
			unsigned long bound ( ) raises ( 
					Reflective::MofError);
			void set_bound ( 
				in unsigned long new_value) raises ( 
					Reflective::MofError);
		};

		interface AliasDefClass;
		typedef sequence < AliasDefClass >  AliasDefClassUList;
		
		typedef sequence < AliasDefClass >  AliasDefClassList;
		
		typedef sequence < AliasDefClass >  AliasDefClassBag;
		
		typedef sequence < AliasDefClass >  AliasDefClassSet;
		
		interface AliasDef;
		typedef sequence < AliasDef >  AliasDefUList;
		
		typedef sequence < AliasDef >  AliasDefList;
		
		typedef sequence < AliasDef >  AliasDefBag;
		
		typedef sequence < AliasDef >  AliasDefSet;
		

/* 
class proxy::MDE::BaseIDL::AliasDef
*/
		interface AliasDefClass
			: TypedefDefClass,
			  TypedClass
		{
			readonly attribute MDE::BaseIDL::AliasDefSet all_of_type_alias_def;
			readonly attribute MDE::BaseIDL::AliasDefSet all_of_class_alias_def;
			MDE::BaseIDL::AliasDef create_alias_def ( 
				in string identifier,
				in string repository_id,
				in string version) raises ( 
					Reflective::MofError);
		};


/* 
::MDE::BaseIDL::AliasDef
*/
		interface AliasDef
			: AliasDefClass,
			  TypedefDef,
			  Typed
		{
		};

		interface EnumDefClass;
		typedef sequence < EnumDefClass >  EnumDefClassUList;
		
		typedef sequence < EnumDefClass >  EnumDefClassList;
		
		typedef sequence < EnumDefClass >  EnumDefClassBag;
		
		typedef sequence < EnumDefClass >  EnumDefClassSet;
		
		interface EnumDef;
		typedef sequence < EnumDef >  EnumDefUList;
		
		typedef sequence < EnumDef >  EnumDefList;
		
		typedef sequence < EnumDef >  EnumDefBag;
		
		typedef sequence < EnumDef >  EnumDefSet;
		

/* 
class proxy::MDE::BaseIDL::EnumDef
*/
		interface EnumDefClass
			: TypedefDefClass
		{
			readonly attribute MDE::BaseIDL::EnumDefSet all_of_type_enum_def;
			readonly attribute MDE::BaseIDL::EnumDefSet all_of_class_enum_def;
			MDE::BaseIDL::EnumDef create_enum_def ( 
				in string identifier,
				in string repository_id,
				in string version,
				in CorbaIdlTypes::StringSet members) raises ( 
					Reflective::MofError);
		};


/* 
::MDE::BaseIDL::EnumDef
*/
		interface EnumDef
			: EnumDefClass,
			  TypedefDef
		{
			CorbaIdlTypes::StringSet members ( ) raises ( 
					Reflective::MofError);
			void set_members ( 
				in CorbaIdlTypes::StringSet new_value) raises ( 
					Reflective::MofError);
			void add_members ( 
				in string new_element) raises ( 
					Reflective::MofError);
			void modify_members ( 
				in string old_element,
				in string new_element) raises ( 
					Reflective::NotFound,
					Reflective::MofError);
			void remove_members ( 
				in string old_element) raises ( 
					Reflective::NotFound,
					Reflective::MofError);
		};

		interface UnionDef;
		struct DiscriminatedByLink
		{
			UnionDef union_def_end;
			IDLType discriminator_type_end;
		};

		typedef sequence < DiscriminatedByLink >  DiscriminatedByLinkSet;
		

/* 
::MDE::BaseIDL::DiscriminatedBy
*/
		interface DiscriminatedBy
			: Reflective::RefAssociation
		{
			MDE::BaseIDL::DiscriminatedByLinkSet all_discriminated_by_links ( ) raises ( 
					Reflective::MofError);
			boolean exists ( 
				in MDE::BaseIDL::UnionDef union_def,
				in MDE::BaseIDL::IDLType discriminator_type) raises ( 
					Reflective::MofError);
			MDE::BaseIDL::IDLType discriminator_type ( 
				in MDE::BaseIDL::UnionDef union_def) raises ( 
					Reflective::MofError);
			void add ( 
				in MDE::BaseIDL::UnionDef union_def,
				in MDE::BaseIDL::IDLType discriminator_type) raises ( 
					Reflective::MofError);
			void modify_discriminator_type ( 
				in MDE::BaseIDL::UnionDef union_def,
				in MDE::BaseIDL::IDLType discriminator_type,
				in MDE::BaseIDL::IDLType new_discriminator_type) raises ( 
					Reflective::MofError,
					Reflective::NotFound);
			void remove ( 
				in MDE::BaseIDL::UnionDef union_def,
				in MDE::BaseIDL::IDLType discriminator_type) raises ( 
					Reflective::MofError,
					Reflective::NotFound);
		};

		interface UnionFieldClass;
		typedef sequence < UnionFieldClass >  UnionFieldClassUList;
		
		typedef sequence < UnionFieldClass >  UnionFieldClassList;
		
		typedef sequence < UnionFieldClass >  UnionFieldClassBag;
		
		typedef sequence < UnionFieldClass >  UnionFieldClassSet;
		
		interface UnionField;
		typedef sequence < UnionField >  UnionFieldUList;
		
		typedef sequence < UnionField >  UnionFieldList;
		
		typedef sequence < UnionField >  UnionFieldBag;
		
		typedef sequence < UnionField >  UnionFieldSet;
		

/* 
class proxy::MDE::BaseIDL::UnionField
*/
		interface UnionFieldClass
			: TypedClass
		{
			readonly attribute MDE::BaseIDL::UnionFieldSet all_of_type_union_field;
			readonly attribute MDE::BaseIDL::UnionFieldSet all_of_class_union_field;
			MDE::BaseIDL::UnionField create_union_field ( 
				in string identifier,
				in string label) raises ( 
					Reflective::MofError);
		};


/* 
::MDE::BaseIDL::UnionField
*/
		interface UnionField
			: UnionFieldClass,
			  Typed
		{
			string identifier ( ) raises ( 
					Reflective::MofError);
			void set_identifier ( 
				in string new_value) raises ( 
					Reflective::MofError);
			string label ( ) raises ( 
					Reflective::MofError);
			void set_label ( 
				in string new_value) raises ( 
					Reflective::MofError);
		};

		interface UnionDefClass;
		typedef sequence < UnionDefClass >  UnionDefClassUList;
		
		typedef sequence < UnionDefClass >  UnionDefClassList;
		
		typedef sequence < UnionDefClass >  UnionDefClassBag;
		
		typedef sequence < UnionDefClass >  UnionDefClassSet;
		
		typedef sequence < UnionDef >  UnionDefUList;
		
		typedef sequence < UnionDef >  UnionDefList;
		
		typedef sequence < UnionDef >  UnionDefBag;
		
		typedef sequence < UnionDef >  UnionDefSet;
		

/* 
class proxy::MDE::BaseIDL::UnionDef
*/
		interface UnionDefClass
			: TypedefDefClass
		{
			readonly attribute MDE::BaseIDL::UnionDefSet all_of_type_union_def;
			readonly attribute MDE::BaseIDL::UnionDefSet all_of_class_union_def;
			MDE::BaseIDL::UnionDef create_union_def ( 
				in string identifier,
				in string repository_id,
				in string version,
				in MDE::BaseIDL::UnionFieldUList union_members) raises ( 
					Reflective::MofError);
		};


/* 
::MDE::BaseIDL::UnionDef
*/
		interface UnionDef
			: UnionDefClass,
			  TypedefDef
		{
			MDE::BaseIDL::UnionFieldUList union_members ( ) raises ( 
					Reflective::MofError);
			void set_union_members ( 
				in MDE::BaseIDL::UnionFieldUList new_value) raises ( 
					Reflective::MofError);
			void add_union_members ( 
				in MDE::BaseIDL::UnionField new_element) raises ( 
					Reflective::MofError);
			void add_union_members_before ( 
				in MDE::BaseIDL::UnionField new_element,
				in MDE::BaseIDL::UnionField before_element) raises ( 
					Reflective::NotFound,
					Reflective::MofError);
			void modify_union_members ( 
				in MDE::BaseIDL::UnionField old_element,
				in MDE::BaseIDL::UnionField new_element) raises ( 
					Reflective::NotFound,
					Reflective::MofError);
			void remove_union_members ( 
				in MDE::BaseIDL::UnionField old_element) raises ( 
					Reflective::NotFound,
					Reflective::MofError);
			MDE::BaseIDL::IDLType discriminator_type ( ) raises ( 
					Reflective::MofError);
			void set_discriminator_type ( 
				in MDE::BaseIDL::IDLType new_value) raises ( 
					Reflective::MofError);
		};

		interface StructDefClass;
		typedef sequence < StructDefClass >  StructDefClassUList;
		
		typedef sequence < StructDefClass >  StructDefClassList;
		
		typedef sequence < StructDefClass >  StructDefClassBag;
		
		typedef sequence < StructDefClass >  StructDefClassSet;
		
		interface StructDef;
		typedef sequence < StructDef >  StructDefUList;
		
		typedef sequence < StructDef >  StructDefList;
		
		typedef sequence < StructDef >  StructDefBag;
		
		typedef sequence < StructDef >  StructDefSet;
		

/* 
class proxy::MDE::BaseIDL::StructDef
*/
		interface StructDefClass
			: TypedefDefClass
		{
			readonly attribute MDE::BaseIDL::StructDefSet all_of_type_struct_def;
			readonly attribute MDE::BaseIDL::StructDefSet all_of_class_struct_def;
			MDE::BaseIDL::StructDef create_struct_def ( 
				in string identifier,
				in string repository_id,
				in string version,
				in MDE::BaseIDL::FieldUList members) raises ( 
					Reflective::MofError);
		};


/* 
::MDE::BaseIDL::StructDef
*/
		interface StructDef
			: StructDefClass,
			  TypedefDef
		{
			MDE::BaseIDL::FieldUList members ( ) raises ( 
					Reflective::MofError);
			void set_members ( 
				in MDE::BaseIDL::FieldUList new_value) raises ( 
					Reflective::MofError);
			void add_members ( 
				in MDE::BaseIDL::Field new_element) raises ( 
					Reflective::MofError);
			void add_members_before ( 
				in MDE::BaseIDL::Field new_element,
				in MDE::BaseIDL::Field before_element) raises ( 
					Reflective::NotFound,
					Reflective::MofError);
			void modify_members ( 
				in MDE::BaseIDL::Field old_element,
				in MDE::BaseIDL::Field new_element) raises ( 
					Reflective::NotFound,
					Reflective::MofError);
			void remove_members ( 
				in MDE::BaseIDL::Field old_element) raises ( 
					Reflective::NotFound,
					Reflective::MofError);
		};

		interface FieldClass;
		typedef sequence < FieldClass >  FieldClassUList;
		
		typedef sequence < FieldClass >  FieldClassList;
		
		typedef sequence < FieldClass >  FieldClassBag;
		
		typedef sequence < FieldClass >  FieldClassSet;
		
		typedef sequence < Field >  FieldList;
		
		typedef sequence < Field >  FieldBag;
		
		typedef sequence < Field >  FieldSet;
		

/* 
class proxy::MDE::BaseIDL::Field
*/
		interface FieldClass
			: TypedClass
		{
			readonly attribute MDE::BaseIDL::FieldSet all_of_type_field;
			readonly attribute MDE::BaseIDL::FieldSet all_of_class_field;
			MDE::BaseIDL::Field create_field ( 
				in string identifier) raises ( 
					Reflective::MofError);
		};


/* 
::MDE::BaseIDL::Field
*/
		interface Field
			: FieldClass,
			  Typed
		{
			string identifier ( ) raises ( 
					Reflective::MofError);
			void set_identifier ( 
				in string new_value) raises ( 
					Reflective::MofError);
		};

		typedef sequence < TypedefDefClass >  TypedefDefClassUList;
		
		typedef sequence < TypedefDefClass >  TypedefDefClassList;
		
		typedef sequence < TypedefDefClass >  TypedefDefClassBag;
		
		typedef sequence < TypedefDefClass >  TypedefDefClassSet;
		
		typedef sequence < TypedefDef >  TypedefDefUList;
		
		typedef sequence < TypedefDef >  TypedefDefList;
		
		typedef sequence < TypedefDef >  TypedefDefBag;
		
		interface ModuleDefClass;
		typedef sequence < ModuleDefClass >  ModuleDefClassUList;
		
		typedef sequence < ModuleDefClass >  ModuleDefClassList;
		
		typedef sequence < ModuleDefClass >  ModuleDefClassBag;
		
		typedef sequence < ModuleDefClass >  ModuleDefClassSet;
		
		interface ModuleDef;
		typedef sequence < ModuleDef >  ModuleDefUList;
		
		typedef sequence < ModuleDef >  ModuleDefList;
		
		typedef sequence < ModuleDef >  ModuleDefBag;
		
		typedef sequence < ModuleDef >  ModuleDefSet;
		

/* 
class proxy::MDE::BaseIDL::ModuleDef
*/
		interface ModuleDefClass
			: ContainerClass
		{
			readonly attribute MDE::BaseIDL::ModuleDefSet all_of_type_module_def;
			readonly attribute MDE::BaseIDL::ModuleDefSet all_of_class_module_def;
			MDE::BaseIDL::ModuleDef create_module_def ( 
				in string identifier,
				in string repository_id,
				in string version,
				in string prefix) raises ( 
					Reflective::MofError);
		};


/* 
::MDE::BaseIDL::ModuleDef
*/
		interface ModuleDef
			: ModuleDefClass,
			  Container
		{
			string prefix ( ) raises ( 
					Reflective::MofError);
			void set_prefix ( 
				in string new_value) raises ( 
					Reflective::MofError);
		};

		interface ConstantDefClass;
		typedef sequence < ConstantDefClass >  ConstantDefClassUList;
		
		typedef sequence < ConstantDefClass >  ConstantDefClassList;
		
		typedef sequence < ConstantDefClass >  ConstantDefClassBag;
		
		typedef sequence < ConstantDefClass >  ConstantDefClassSet;
		
		interface ConstantDef;
		typedef sequence < ConstantDef >  ConstantDefUList;
		
		typedef sequence < ConstantDef >  ConstantDefList;
		
		typedef sequence < ConstantDef >  ConstantDefBag;
		
		typedef sequence < ConstantDef >  ConstantDefSet;
		

/* 
class proxy::MDE::BaseIDL::ConstantDef
*/
		interface ConstantDefClass
			: TypedClass,
			  ContainedClass
		{
			readonly attribute MDE::BaseIDL::ConstantDefSet all_of_type_constant_def;
			readonly attribute MDE::BaseIDL::ConstantDefSet all_of_class_constant_def;
			MDE::BaseIDL::ConstantDef create_constant_def ( 
				in string identifier,
				in string repository_id,
				in string version,
				in string const_value) raises ( 
					Reflective::MofError);
		};


/* 
::MDE::BaseIDL::ConstantDef
*/
		interface ConstantDef
			: ConstantDefClass,
			  Typed,
			  Contained
		{
			string const_value ( ) raises ( 
					Reflective::MofError);
			void set_const_value ( 
				in string new_value) raises ( 
					Reflective::MofError);
		};

		struct ContainsLink
		{
			Container defined_in_end;
			Contained contents_end;
		};

		typedef sequence < ContainsLink >  ContainsLinkSet;
		

/* 
::MDE::BaseIDL::Contains
*/
		interface Contains
			: Reflective::RefAssociation
		{
			MDE::BaseIDL::ContainsLinkSet all_contains_links ( ) raises ( 
					Reflective::MofError);
			boolean exists ( 
				in MDE::BaseIDL::Container defined_in,
				in MDE::BaseIDL::Contained contents) raises ( 
					Reflective::MofError);
			MDE::BaseIDL::Container defined_in ( 
				in MDE::BaseIDL::Contained contents) raises ( 
					Reflective::MofError);
			MDE::BaseIDL::ContainedSet contents ( 
				in MDE::BaseIDL::Container defined_in) raises ( 
					Reflective::MofError);
			void add ( 
				in MDE::BaseIDL::Container defined_in,
				in MDE::BaseIDL::Contained contents) raises ( 
					Reflective::MofError);
			void modify_defined_in ( 
				in MDE::BaseIDL::Container defined_in,
				in MDE::BaseIDL::Contained contents,
				in MDE::BaseIDL::Container new_defined_in) raises ( 
					Reflective::MofError,
					Reflective::NotFound);
			void modify_contents ( 
				in MDE::BaseIDL::Container defined_in,
				in MDE::BaseIDL::Contained contents,
				in MDE::BaseIDL::Contained new_contents) raises ( 
					Reflective::MofError,
					Reflective::NotFound);
			void remove ( 
				in MDE::BaseIDL::Container defined_in,
				in MDE::BaseIDL::Contained contents) raises ( 
					Reflective::MofError,
					Reflective::NotFound);
		};

		typedef sequence < DefinitionKind >  DefinitionKindUList;
		
		typedef sequence < DefinitionKind >  DefinitionKindList;
		
		typedef sequence < DefinitionKind >  DefinitionKindBag;
		
		typedef sequence < DefinitionKind >  DefinitionKindSet;
		
		typedef sequence < ContainerClass >  ContainerClassUList;
		
		typedef sequence < ContainerClass >  ContainerClassList;
		
		typedef sequence < ContainerClass >  ContainerClassBag;
		
		typedef sequence < ContainerClass >  ContainerClassSet;
		
		typedef sequence < Container >  ContainerUList;
		
		typedef sequence < Container >  ContainerList;
		
		typedef sequence < Container >  ContainerBag;
		
		typedef sequence < ContainedClass >  ContainedClassUList;
		
		typedef sequence < ContainedClass >  ContainedClassList;
		
		typedef sequence < ContainedClass >  ContainedClassBag;
		
		typedef sequence < ContainedClass >  ContainedClassSet;
		
		typedef sequence < Contained >  ContainedUList;
		
		typedef sequence < Contained >  ContainedList;
		
		typedef sequence < Contained >  ContainedBag;
		

/* 
::MDE::BaseIDL::ParameterMode
*/
		enum ParameterMode
			{
			PARAM_IN,
			 PARAM_OUT,
			PARAM_INOUT
			};
		typedef sequence < ParameterMode >  ParameterModeUList;
		
		typedef sequence < ParameterMode >  ParameterModeList;
		
		typedef sequence < ParameterMode >  ParameterModeBag;
		
		typedef sequence < ParameterMode >  ParameterModeSet;
		
		interface ParameterDefClass;
		typedef sequence < ParameterDefClass >  ParameterDefClassUList;
		
		typedef sequence < ParameterDefClass >  ParameterDefClassList;
		
		typedef sequence < ParameterDefClass >  ParameterDefClassBag;
		
		typedef sequence < ParameterDefClass >  ParameterDefClassSet;
		
		typedef sequence < ParameterDef >  ParameterDefList;
		
		typedef sequence < ParameterDef >  ParameterDefBag;
		
		typedef sequence < ParameterDef >  ParameterDefSet;
		

/* 
class proxy::MDE::BaseIDL::ParameterDef
*/
		interface ParameterDefClass
			: TypedClass
		{
			readonly attribute MDE::BaseIDL::ParameterDefSet all_of_type_parameter_def;
			readonly attribute MDE::BaseIDL::ParameterDefSet all_of_class_parameter_def;
			MDE::BaseIDL::ParameterDef create_parameter_def ( 
				in string identifier,
				in MDE::BaseIDL::ParameterMode direction) raises ( 
					Reflective::MofError);
		};


/* 
::MDE::BaseIDL::ParameterDef
*/
		interface ParameterDef
			: ParameterDefClass,
			  Typed
		{
			string identifier ( ) raises ( 
					Reflective::MofError);
			void set_identifier ( 
				in string new_value) raises ( 
					Reflective::MofError);
			MDE::BaseIDL::ParameterMode direction ( ) raises ( 
					Reflective::MofError);
			void set_direction ( 
				in MDE::BaseIDL::ParameterMode new_value) raises ( 
					Reflective::MofError);
		};

		struct TypedByLink
		{
			Typed typed_end;
			IDLType idl_type_end;
		};

		typedef sequence < TypedByLink >  TypedByLinkSet;
		

/* 
::MDE::BaseIDL::TypedBy
*/
		interface TypedBy
			: Reflective::RefAssociation
		{
			MDE::BaseIDL::TypedByLinkSet all_typed_by_links ( ) raises ( 
					Reflective::MofError);
			boolean exists ( 
				in MDE::BaseIDL::Typed typed,
				in MDE::BaseIDL::IDLType idl_type) raises ( 
					Reflective::MofError);
			MDE::BaseIDL::IDLType idl_type ( 
				in MDE::BaseIDL::Typed typed) raises ( 
					Reflective::MofError);
			void add ( 
				in MDE::BaseIDL::Typed typed,
				in MDE::BaseIDL::IDLType idl_type) raises ( 
					Reflective::MofError);
			void modify_idl_type ( 
				in MDE::BaseIDL::Typed typed,
				in MDE::BaseIDL::IDLType idl_type,
				in MDE::BaseIDL::IDLType new_idl_type) raises ( 
					Reflective::MofError,
					Reflective::NotFound);
			void remove ( 
				in MDE::BaseIDL::Typed typed,
				in MDE::BaseIDL::IDLType idl_type) raises ( 
					Reflective::MofError,
					Reflective::NotFound);
		};

		typedef sequence < IDLTypeClass >  IDLTypeClassUList;
		
		typedef sequence < IDLTypeClass >  IDLTypeClassList;
		
		typedef sequence < IDLTypeClass >  IDLTypeClassBag;
		
		typedef sequence < IDLTypeClass >  IDLTypeClassSet;
		
		typedef sequence < IDLType >  IDLTypeUList;
		
		typedef sequence < IDLType >  IDLTypeList;
		
		typedef sequence < IDLType >  IDLTypeBag;
		
		typedef sequence < TypedClass >  TypedClassUList;
		
		typedef sequence < TypedClass >  TypedClassList;
		
		typedef sequence < TypedClass >  TypedClassBag;
		
		typedef sequence < TypedClass >  TypedClassSet;
		
		typedef sequence < Typed >  TypedUList;
		
		typedef sequence < Typed >  TypedList;
		
		typedef sequence < Typed >  TypedBag;
		
		interface BaseIDLPackage
			: Reflective::RefPackage
		{
			readonly attribute MDE::BaseIDL::TypedClass typed_ref;
			readonly attribute MDE::BaseIDL::IDLTypeClass idltype_ref;
			readonly attribute MDE::BaseIDL::TypedBy typed_by_ref;
			readonly attribute MDE::BaseIDL::ParameterDefClass parameter_def_ref;
			readonly attribute MDE::BaseIDL::ContainedClass contained_ref;
			readonly attribute MDE::BaseIDL::ContainerClass container_ref;
			readonly attribute MDE::BaseIDL::Contains contains_ref;
			readonly attribute MDE::BaseIDL::ConstantDefClass constant_def_ref;
			readonly attribute MDE::BaseIDL::ModuleDefClass module_def_ref;
			readonly attribute MDE::BaseIDL::TypedefDefClass typedef_def_ref;
			readonly attribute MDE::BaseIDL::FieldClass field_ref;
			readonly attribute MDE::BaseIDL::StructDefClass struct_def_ref;
			readonly attribute MDE::BaseIDL::UnionDefClass union_def_ref;
			readonly attribute MDE::BaseIDL::UnionFieldClass union_field_ref;
			readonly attribute MDE::BaseIDL::DiscriminatedBy discriminated_by_ref;
			readonly attribute MDE::BaseIDL::EnumDefClass enum_def_ref;
			readonly attribute MDE::BaseIDL::AliasDefClass alias_def_ref;
			readonly attribute MDE::BaseIDL::StringDefClass string_def_ref;
			readonly attribute MDE::BaseIDL::WstringDefClass wstring_def_ref;
			readonly attribute MDE::BaseIDL::FixedDefClass fixed_def_ref;
			readonly attribute MDE::BaseIDL::SequenceDefClass sequence_def_ref;
			readonly attribute MDE::BaseIDL::ArrayDefClass array_def_ref;
			readonly attribute MDE::BaseIDL::PrimitiveDefClass primitive_def_ref;
			readonly attribute MDE::BaseIDL::ValueMemberDefClass value_member_def_ref;
			readonly attribute MDE::BaseIDL::ValueDefClass value_def_ref;
			readonly attribute MDE::BaseIDL::InterfaceDefClass interface_def_ref;
			readonly attribute MDE::BaseIDL::InterfaceDerivedFrom interface_derived_from_ref;
			readonly attribute MDE::BaseIDL::Supportss supportss_ref;
			readonly attribute MDE::BaseIDL::ValueDerivedFrom value_derived_from_ref;
			readonly attribute MDE::BaseIDL::AbstractDerivedFrom abstract_derived_from_ref;
			readonly attribute MDE::BaseIDL::ValueBoxDefClass value_box_def_ref;
			readonly attribute MDE::BaseIDL::OperationDefClass operation_def_ref;
			readonly attribute MDE::BaseIDL::ExceptionDefClass exception_def_ref;
			readonly attribute MDE::BaseIDL::CanRaise can_raise_ref;
			readonly attribute MDE::BaseIDL::AttributeDefClass attribute_def_ref;
			readonly attribute MDE::BaseIDL::SetRaisesEx set_raises_ex_ref;
			readonly attribute MDE::BaseIDL::GetRaisesEx get_raises_ex_ref;
			readonly attribute MDE::BaseIDL::ValueFactoryDefClass value_factory_def_ref;
		};

	}; // end module BaseIDL
}; // end module MDE
#endif