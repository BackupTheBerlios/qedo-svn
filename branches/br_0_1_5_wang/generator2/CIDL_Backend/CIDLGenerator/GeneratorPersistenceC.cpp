/*****************************************************************************/
/* Qedo - Quality of Service Enabled Distributed Objects                     */
/*                                                                           */
/* Copyright (c) 2002/2003 by the Qedo Team                                  */
/*                                                                           */
/* http://qedo.berlios.de                                                    */
/*                                                                           */
/* This file is part of Qedo Generator                                       */
/*                                                                           */
/* Qedo Generator is free software; you can redistribute it and/or modify    */
/* it under the terms of the GNU General Public License as published by      */
/* the Free Software Foundation; either version 2 of the License, or         */
/* (at your option) any later version.                                       */
/*                                                                           */
/* Qedo Generator is distributed in the hope that it will be useful,         */
/* but WITHOUT ANY WARRANTY; without even the implied warranty of            */
/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             */
/* GNU General Public License for more details.                              */
/*                                                                           */
/* You should have received a copy of the GNU General Public License         */
/* along with Foobar; if not, write to the Free Software                     */
/* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA */
/*                                                                           */
/*****************************************************************************/
#include "GeneratorPersistenceC.h"


namespace QEDO_CIDL_Generator {

GeneratorPersistenceC::GeneratorPersistenceC
( QEDO_ComponentRepository::CIDLRepository_impl *repository)
: CPPBase(repository), 
  bAbstract_(true),
  bRef_(false),
  strFilename_(""),
  strClassname_(""),
  strActBasename_(""),
  strName_(""),
  strContent_(""),
  strNamespace_("")
{
}

GeneratorPersistenceC::~GeneratorPersistenceC
()
{
	if(!lValueTypes_.empty())
		lValueTypes_.clear();
}

void
GeneratorPersistenceC::generate(std::string target, std::string fileprefix)
{
	try { initialize(target, fileprefix); }
	catch (InitializeError) { return; }
	
	strFilename_ = file_prefix_ + "_PSS.cpp";
	
	out.open(strFilename_.c_str());
	out << "//\n";
	out << "// generated by Qedo\n";
	out << "//\n\n";
	out << "#ifndef _" << file_prefix_ << "_PSS_C_\n";
	out << "#define _" << file_prefix_ << "_PSS_C_\n\n\n";
	out << "#include \"" << file_prefix_ << "_PSS.h\"\n";
	
	// parse the namespace name from prefix, disadvantage is 
	// that will not allow the user to use '_' in his namespace name
	// a little farfetched ;-(
	basic_string <char>::size_type idx;
    static const basic_string <char>::size_type npos = -1;
	
	idx = file_prefix_.find("_");
	if(idx!=npos)
		strNamespace_ = file_prefix_.substr(0, idx);

	doGenerate();

	out << "\n#endif\n";
	out.close();
}

void
GeneratorPersistenceC::check_for_generation(IR__::Contained_ptr item)
{
	// check if item is already known
	if (item_well_known(item))
		return;

	// check if item is already in the list or currently processed
	if ((this->sRecursion_.find(item->id())) != sRecursion_.end() || this->already_included (item))
		return;
	else
		sRecursion_.insert(item->id());
	
	CORBA::ULong i;
	CORBA::ULong ulLen;

	switch (item->def_kind()) 
	{
	case CORBA__::dk_Module :
	{
		IR__::ModuleDef_var a_module = IR__::ModuleDef::_narrow(item);

		// modules
		IR__::ContainedSeq_var contained_seq = a_module->contents(CORBA__::dk_Module, true);
		ulLen = contained_seq->length();
		for(i=0; i<ulLen; i++)
			check_for_generation((*contained_seq)[i]);

		// compositions
		contained_seq = repository_->contents(CORBA__::dk_Composition, true);
		ulLen = contained_seq->length();
		CIDL::CompositionDef_var a_composition;
		for(i = 0; i < ulLen; i++)
		{
			a_composition = CIDL::CompositionDef::_narrow((*contained_seq)[i]);
			std::string id = a_composition->id();
			std::string::size_type pos = id.find_last_of("/");
			if(pos != std::string::npos) 
			{
				id.replace(pos, std::string::npos, ":1.0");
				if(!id.compare(a_module->id())) 
				{
					check_for_generation(a_composition);
				}
			}
		}
		
		// valuetypes
		contained_seq = a_module->contents(CORBA__::dk_Value, true);
		ulLen = contained_seq->length();
		for(i=0; i<ulLen; i++)
		{
			IR__::ValueDef_ptr value = IR__::ValueDef::_narrow((*contained_seq)[i]);
			lValueTypes_.push_back(value);
		}

		break;
	}
	case CORBA__::dk_Composition : {
		CIDL::CompositionDef_var a_composition = CIDL::CompositionDef::_narrow(item);
		this->insert_to_generate(item);

		// home and storage home
		if( a_composition->lifecycle()==CIDL::lc_Entity || 
			a_composition->lifecycle()==CIDL::lc_Process )
		{
			IR__::HomeDef_var home = a_composition->ccm_home();
			if( !CORBA::is_nil(home) )
				check_for_generation(home);

			IR__::StorageHomeDef_var storagehome = a_composition->home_executor()->binds_to();
			if( !CORBA::is_nil(storagehome) )
				check_for_generation(storagehome);
		}
		
		break;
	}
	case CORBA__::dk_Home :
	{
		IR__::HomeDef_var home = IR__::HomeDef::_narrow(item);
		IR__::PrimaryKeyDef_var pk = IR__::PrimaryKeyDef::_duplicate(home->primary_key());
		
		if( !CORBA::is_nil(pk) )
		{
            IR__::ValueDef_ptr value = pk->primary_key();
			lValueTypes_.push_back(value);
		}

		break;
	}
	case CORBA__::dk_StorageHome : 
	{
		IR__::StorageHomeDef_var storagehome = IR__::StorageHomeDef::_narrow(item);

		// supported interfaces
		IR__::InterfaceDefSeq_var inf_seq = storagehome->supported_interfaces();
		ulLen = inf_seq->length();
		for(i=0; i<ulLen; i++)
			check_for_generation((*inf_seq)[i]);

		// base storage home
		IR__::StorageHomeDef_var base_storagehome = storagehome->base_storagehome();
		if( !CORBA::is_nil(base_storagehome) )
			this->check_for_generation(base_storagehome);

		// self
		// insert this interface in generation list
		this->insert_to_generate(item);

		// managed storage type
		IR__::StorageTypeDef_var storagetype = storagehome->managed_storagetype();
		this->check_for_generation(storagetype);

		break;
	}
	case CORBA__::dk_AbstractStorageHome :
	{
		IR__::AbstractStorageHomeDef_var abs_storagehome = IR__::AbstractStorageHomeDef::_narrow(item);

		// managed abstract storage type
		//IR__::AbstractStorageTypeDef_var abs_storagetype = abs_storagehome->managed_abstract_storagetype();
		//this->check_for_generation(abs_storagetype);

		// supported interfaces
		IR__::InterfaceDefSeq_var inf_seq = abs_storagehome->base_abstract_storagehomes();
		ulLen = inf_seq->length();
		for(i=0; i<ulLen; i++)
			check_for_generation((*inf_seq)[i]);

		// self
		// insert this interface in generation list
		this->insert_to_generate(item);

		break;
	}
	case CORBA__::dk_StorageType :
	{
		IR__::StorageTypeDef_var storagetype = IR__::StorageTypeDef::_narrow(item);

		// supported interfaces
		IR__::InterfaceDefSeq_var inf_seq = storagetype->supported_interfaces();
		ulLen = inf_seq->length();
		for(i=0; i<ulLen; i++)
			check_for_generation((*inf_seq)[i]);

		// base type
		IR__::StorageTypeDef_var base_storagetype = storagetype->base_storagetype();
		if( !CORBA::is_nil(base_storagetype) )
			check_for_generation(base_storagetype);

		// self
		// insert this interface in generation list
		this->insert_to_generate(item);

		break;
	}
	case CORBA__::dk_AbstractStorageType :
	{
		IR__::AbstractStorageTypeDef_var abs_storagetype = IR__::AbstractStorageTypeDef::_narrow(item);

		// supported interfaces
		IR__::InterfaceDefSeq_var inf_seq = abs_storagetype->base_abstract_storagetypes();
		ulLen = inf_seq->length();
		for(i=0; i<ulLen; i++)
			check_for_generation((*inf_seq)[i]);

		// self
		// insert this interface in generation list
		this->insert_to_generate(item);

		break;
	}
	default:
		break;
	};

	sRecursion_.erase(item->id());
};

void
GeneratorPersistenceC::doComposition(CIDL::CompositionDef_ptr composition)
{
	//
	// determine the componentDef and HomeDef
	//
	composition_ = CIDL::CompositionDef::_duplicate(composition);
	IR__::ComponentDef_var component = composition->ccm_component();
	IR__::HomeDef_var home = composition->ccm_home();

	//
	// determine lifecycle
	//
	CIDL::LifecycleCategory lc = composition->lifecycle();
	
	//
	// generate persistence for home
	//
	out << "\n\n";
	open_module(out, component, "");
	out << "\n\n";
	genHomePersistence(home, lc);
	close_module(out, component);
	out << "\n\n";

	//
	// generate persistence for component
	//
	open_module(out, component, "");
	out << "\n\n";
	genComponentPersistence(home, component, lc);
	close_module(out, component);
}

void
GeneratorPersistenceC::genDuplAndDown(std::string strClassName)
{
	//generate _duplicate and _downcast operation
	out << strClassName << "*\n";
	out << strClassName << "::_duplicate(const " << strClassName << "* obj)\n";
	out << "{\n";
	out.indent();
	out << "if( obj!=NULL )\n";
	out.indent();
	out << "obj->_add_ref();\n";
	out.unindent();
	out << "return obj;\n";
	out.unindent();
	out << "}\n\n";

	out << strClassName << "*\n";
	out << strClassName << "::_downcast(const " << strClassName << "* obj)\n";
	out << "{\n";
	out.indent();
	out << "return obj;\n";
	out.unindent();
	out << "}\n";
}

void
GeneratorPersistenceC::genAttributeWithNomalType(IR__::AttributeDef_ptr attribute, CORBA::TCKind att_type_kind)
{
	std::string attribute_name = mapName(attribute);
	IR__::IDLType_var attr_type = attribute->type_def();

	switch ( att_type_kind )
	{
		case CORBA::tk_string:
		case CORBA::tk_wstring:
			out << map_psdl_return_type(attr_type, false) << "\n";
			out << strClassname_;
			if(bRef_) out << "Ref";
			out << "::" << attribute_name << "(";
			out << map_psdl_parameter_type(attr_type, false) << " param)\n";
			out << "{\n";
			out.indent();
			out << attribute_name << "_ = param;\n";
			out << "setModified(true);\n";
			out.unindent();
			out << "}\n\n";
	}

	out << "void\n";
	out << strClassname_;
	if(bRef_) out << "Ref";
	out << "::" << attribute_name << "(";
	out << map_psdl_parameter_type(attr_type, true) << " param)\n";
	out << "{\n";
	out.indent();
	out << attribute_name << "_ = param;\n";
	out << "setModified(true);\n";
	out.unindent();
	out << "}\n\n";

	// the fourth operation only for string and wstring
	if(attr_type->type()->kind()==CORBA::tk_string)
	{
		out << "void\n";
		out << strClassname_;
		if(bRef_) out << "Ref";
		out << "::" << attribute_name << "(CORBA::String_var& param)\n";
		out << "{\n";
		out.indent();
		out << attribute_name << "_ = param.in();\n";
		out << "setModified(true);\n";
		out.unindent();
		out << "}\n\n";
	}
	else if(attr_type->type()->kind()==CORBA::tk_wstring)
	{
		out << "void\n";
		out << strClassname_;
		if(bRef_) out << "Ref";
		out << "::" << attribute_name << "(CORBA::WString_var& param)\n";
		out << "{\n";
		out.indent();
		out << attribute_name << "_ = param.in();\n";
		out << "setModified(true);\n";
		out.unindent();
		out << "}\n\n";
	}
}

void
GeneratorPersistenceC::genAttributeWithOtherType(IR__::AttributeDef_ptr attribute, CORBA::TCKind att_type_kind)
{
	std::string attribute_name = mapName(attribute);
	IR__::IDLType_var attr_type = attribute->type_def();
	
	out << map_psdl_return_type(attr_type, false) << "\n";
	out << strClassname_;
	if(bRef_) out << "Ref";
	out << "::" << attribute_name << "(";
	out << map_psdl_parameter_type(attr_type, false) << " param)\n";
	out << "{\n";
	out.indent();
	out << "return " << attribute_name << "_;\n";
	out.unindent();
	out << "}\n\n";
	
	out << "void\n";
	out << strClassname_;
	if(bRef_) out << "Ref";
	out << "::" << attribute_name << "(";
	out << map_psdl_parameter_type(attr_type, true) << " param)\n";
	out << "{\n";
	out.indent();
	if( attr_type->type()->kind() == CORBA::tk_value )
	{/*
		std::list<IR__::ValueDef_var>::iterator valuetype_iter;
		for(valuetype_iter = lValueTypes_.begin();
			valuetype_iter != lValueTypes_.end();
			valuetype_iter++)
		{
			IR__::ValueDef_var value = IR__::ValueDef::_narrow(*valuetype_iter);
			std::string attr_type_name = map_attribute_type(attribute->type_def());
			if(attr_type_name.find(mapName(value))!=std::string::npos)
			{
				IR__::ContainedSeq_var contained_seq = value->contents(CORBA__::dk_ValueMember, true);
				for(CORBA::ULong j = 0; j < contained_seq->length(); j++)
				{
					IR__::ValueMemberDef_var vMember = IR__::ValueMemberDef::_narrow((*contained_seq)[j]);

					switch(psdl_check_type(vMember->type_def()))
					{
					case CPPBase::_SHORT:
					case CPPBase::_INT:
					case CPPBase::_LONG:
					case CPPBase::_STRING:
						out << attribute_name << "_->" << mapName(vMember) << "( param." << mapName(vMember) << "() );\n";
						break;
					}
				}
				break;
			}
		}*/
		IR__::Contained_var contained = IR__::Contained::_narrow(attr_type.in());
		out << attribute_name << "_ = (" << getAbsoluteName(contained.in()) << "*)param;\n";
	}
	else
	{
		out << attribute_name << "_ = param;\n";
	}
	out << "setModified(true);\n";
	out.unindent();
	out << "}\n\n";
}

void
GeneratorPersistenceC::doAttribute(IR__::AttributeDef_ptr attribute)
{
	out << "\n//\n// " << attribute->id() << "\n//\n";
	std::string attribute_name = mapName(attribute);
	IR__::IDLType_var attr_type = attribute->type_def();
	
	// read only
	out << map_psdl_return_type(attr_type, true) << "\n";
	out << strClassname_;
	if(bRef_) out << "Ref";
	out << "::" << attribute_name << "() const\n";
	out << "{\n";
	out.indent();
	if(attr_type->type()->kind()==CORBA::tk_string || attr_type->type()->kind()==CORBA::tk_wstring)
        out << "return " << attribute_name << "_.c_str();\n";
	else
		out << "return " << attribute_name << "_;\n";
	out.unindent();
	out << "}\n\n";

	// not read only
	if(attribute->mode() == IR__::ATTR_NORMAL)
	{
		CORBA::TCKind att_type_kind = attr_type->type()->kind();
		switch ( att_type_kind )
		{
			case CORBA::tk_short:
			case CORBA::tk_long:
			case CORBA::tk_longlong:
			case CORBA::tk_ushort:
			case CORBA::tk_ulong:
			case CORBA::tk_ulonglong:
			case CORBA::tk_float:
			case CORBA::tk_double:
			case CORBA::tk_longdouble:
			case CORBA::tk_boolean:
			case CORBA::tk_char:
			case CORBA::tk_wchar:
			case CORBA::tk_octet:
			case CORBA::tk_string:
			case CORBA::tk_wstring:
				genAttributeWithNomalType(attribute, att_type_kind);
				break;
			default:
				genAttributeWithOtherType(attribute, att_type_kind);
		}
	}
}

void
GeneratorPersistenceC::genOperation(IR__::OperationDef_ptr operation, IR__::IDLType_ptr ret_type)
{
	out << "\n//\n// " << operation->id() << "\n//\n";
	out << map_psdl_return_type(ret_type, false) << "\n";
	out << strClassname_;
	if(bRef_) out << "Ref";
	out << "::" << mapName(operation) << "(";

	// parameters
	IR__::ParDescriptionSeq_var pards = operation->params();
	for( CORBA::ULong i=0; i<pards->length(); i++)
	{
		IR__::ParameterDescription pardescr = (*pards)[i];
		if (pardescr.mode == IR__::PARAM_IN) {
			out << map_in_parameter_type (pardescr.type_def) << " " << std::string(pardescr.name);
		};
		if (pardescr.mode == IR__::PARAM_OUT) {
			out << map_out_parameter_type (pardescr.type_def) << " " << std::string(pardescr.name);
		};
		if (pardescr.mode == IR__::PARAM_INOUT) {
			out << map_inout_parameter_type (pardescr.type_def) << " " << std::string(pardescr.name);
		};
		if((i+1)!=pards->length()) { out << ", "; }
	};

	out << ")\n";
	out << "{\n}\n\n";
}

void
GeneratorPersistenceC::doOperation(IR__::OperationDef_ptr operation)
{
	genOperation(operation, operation->result_def());
}

void
GeneratorPersistenceC::genFactory(IR__::OperationDef_ptr operation, IR__::InterfaceDef_ptr inf_type, IR__::InterfaceDef_ptr inf_home )
{
	int iLength = 0;	
	bool bFound = false;
	std::string strTemp = "";
	std::string strDummy = "";
	stringstream strDisplay;
	IR__::AttributeDef_var attribute = IR__::AttributeDef::_nil();

	out << "\n//\n// " << operation->id() << "\n//\n";
	IR__::IDLType_var ret_type = IR__::IDLType::_narrow(inf_type);

	out << map_psdl_return_type(ret_type, false) << "\n";
	strDisplay << strClassname_ << "::" << mapName(operation) << "(";
	out << strDisplay.str();

	iLength = strDisplay.str().length();
	strDummy.append(iLength, ' ');
	
	out << "Pid* pid,\n";
	out << strDummy.c_str();
	out << "ShortPid* shortPid,\n";

	// parameters
	IR__::ParDescriptionSeq_var pards = operation->params();
	for( CORBA::ULong i=0; i<pards->length(); i++)
	{
		out << strDummy.c_str();
		IR__::ParameterDescription pardescr = (*pards)[i];
		if (pardescr.mode == IR__::PARAM_IN) {
			out << map_in_parameter_type (pardescr.type_def) << " " << std::string(pardescr.name);
		};
		if (pardescr.mode == IR__::PARAM_OUT) {
			out << map_out_parameter_type (pardescr.type_def) << " " << std::string(pardescr.name);
		};
		if (pardescr.mode == IR__::PARAM_INOUT) {
			out << map_inout_parameter_type (pardescr.type_def) << " " << std::string(pardescr.name);
		};
		if((i+1)!=pards->length()) { out << ",\n"; }
	};

	out << ")\n";
	out << "{\n";
	out.indent();

	//++++++++++++++++++++++++++++++++++++++++
	// INSERT sentence for FACTORY
	//++++++++++++++++++++++++++++++++++++++++
	IR__::AttributeDefSeq state_members = collectStateMembers(inf_type, CORBA__::dk_Create);
	out << "std::stringstream strFactory;\n\n";
	out << "CatalogBase_ptr pCatalogBase = get_catalog();\n";
	out << "CatalogBaseImpl* pCatalogBaseImpl = dynamic_cast <CatalogBaseImpl*> (pCatalogBase);\n\n";
	strName_ = "strFactory";

	out << strName_ << " << \"INSERT INTO pid_content (pid, home) VALUES ( \";\n";
	strContent_ = "\\'";
	out << genSQLLine(strName_, strContent_, false, false, false);
	strContent_ = "convertPidToString(pid)";
	out << genSQLLine(strContent_, false, false, false, true);
	strContent_ = "\\'";
	out << genSQLLine(strContent_, true, true, true);
	out << strName_ << " << \"\\\'" << inf_home->name() << "\\\' );\";\n\n";
	out << "if(!pCatalogBaseImpl->ExecuteSQL(" << strName_ << ".str().c_str()))\n";
	out.indent();
	out << "throw CORBA::BAD_PARAM();\n\n";
	out.unindent();

	out << "strFactory.str(\"\");\n";
	out << strName_ << " << \"INSERT INTO " << inf_home->name() << " ( pid, spid, ";

	CORBA::ULong ulLen = state_members.length();
	for(i=0; i<ulLen; i++)
	{
		attribute = IR__::AttributeDef::_narrow(state_members[i]);
		if( attribute->type_def()->type()->kind() == CORBA::tk_value )
		{
			std::list<IR__::ValueDef_var>::iterator valuetype_iter;
			for(valuetype_iter = lValueTypes_.begin();
				valuetype_iter != lValueTypes_.end();
				valuetype_iter++)
			{
				IR__::ValueDef_var value = IR__::ValueDef::_narrow(*valuetype_iter);
				std::string attr_type_name = map_attribute_type(attribute->type_def());
				if(attr_type_name.find(mapName(value))!=std::string::npos)
				{
					IR__::ContainedSeq_var contained_seq = value->contents(CORBA__::dk_ValueMember, true);
					for(CORBA::ULong j = 0; j < contained_seq->length(); j++)
					{
						IR__::ValueMemberDef_var vMember = IR__::ValueMemberDef::_narrow((*contained_seq)[j]);
						out << "value_" << mapName(vMember);
						( (i+1)!=ulLen ) ? out << ", " : out << " ) \";\n";
					}
					break;
				}
			}
		}
		else
		{
			out << mapName(attribute);
			( (i+1)!=ulLen ) ? out << ", " : out << " ) \";\n";
		}
	}

	strContent_ = "VALUES (";
	out << genSQLLine(strName_, strContent_, true, false, true);
	strContent_ = "\\'";
	out << genSQLLine(strName_, strContent_, false, false, false);
	strContent_ = "convertPidToString(pid)";
	out << genSQLLine(strContent_, false, false, false, true);
	strContent_ = "\\'";
	out << genSQLLine(strContent_, true, true, true);
	strContent_ = "\\'";
	out << genSQLLine(strName_, strContent_, false, false, false);
	strContent_ = "convertSpidToString(shortPid)";
	out << genSQLLine(strContent_, false, false, false, true);
	strContent_ = "\\'";
	out << genSQLLine(strContent_, true, true, true);

	for(i=0; i<ulLen; i++)
	{
		bFound = false;
		strTemp = "";
		attribute = IR__::AttributeDef::_narrow(state_members[i]);
		
		for(CORBA::ULong j=0; j<pards->length(); j++)
		{
			IR__::ParameterDescription pardescr = (*pards)[j];	
			strTemp = std::string(pardescr.name);
			if(strTemp.compare(attribute->name())==0)
			{
				bFound = true;
				break;
			}
		}
		
		if(bFound)
		{
			if( attribute->type_def()->type()->kind() == CORBA::tk_value )
			{
				std::list<IR__::ValueDef_var>::iterator valuetype_iter;
				for(valuetype_iter = lValueTypes_.begin();
					valuetype_iter != lValueTypes_.end();
					valuetype_iter++)
				{
					IR__::ValueDef_var value = IR__::ValueDef::_narrow(*valuetype_iter);
					std::string attr_type_name = map_attribute_type(attribute->type_def());
					if(attr_type_name.find(mapName(value))!=std::string::npos)
					{
						IR__::ContainedSeq_var contained_seq = value->contents(CORBA__::dk_ValueMember, true);
						for(CORBA::ULong j = 0; j < contained_seq->length(); j++)
						{
							IR__::ValueMemberDef_var vMember = IR__::ValueMemberDef::_narrow((*contained_seq)[j]);
							switch(psdl_check_type(vMember->type_def()))
							{
							case CPPBase::_SHORT:
							case CPPBase::_INT:
							case CPPBase::_LONG:
								strContent_ = strTemp + "->";
								strContent_ += mapName(vMember) + "()";
								out << genSQLLine(strName_, strContent_, false, false, false, true);
								strContent_ = "";
								out << genSQLLine(strContent_, true, ((i+1)!=ulLen), true);
								break;
							case CPPBase::_STRING:
								strContent_ = "\\'";
								out << genSQLLine(strName_, strContent_, false, false, false);
								strContent_ = strTemp + "->";
								strContent_ += mapName(vMember) + "()";
								out << genSQLLine(strContent_, false, false, false, true);
								strContent_ = "\\'";
								out << genSQLLine(strContent_, true, ((i+1)!=ulLen), true);
								break;
							}
						}
						break;
					}
				}
			}
			else
			{
				switch(psdl_check_type(attribute->type_def()))
				{
				case CPPBase::_SHORT:
				case CPPBase::_INT:
				case CPPBase::_LONG:
				case CPPBase::_FLOAT:
				case CPPBase::_DOUBLE:
				case CPPBase::_LONGDOUBLE:
					strContent_ = strTemp;
					out << genSQLLine(strName_, strContent_, false, false, false, true);
					strContent_ = "";
					out << genSQLLine(strContent_, true, ((i+1)!=ulLen), true);
					break;
				case CPPBase::_STRING:
					strContent_ = "\\'";
					out << genSQLLine(strName_, strContent_, false, false, false);
					strContent_ = strTemp;
					out << genSQLLine(strContent_, false, false, false, true);
					strContent_ = "\\'";
					out << genSQLLine(strContent_, true, ((i+1)!=ulLen), true);
					break;
				case CPPBase::_BOOL:
					strContent_ = "convertBool2String(" + strTemp + ")";
					out << genSQLLine(strName_, strContent_, false, false, false, true);
					strContent_ = "";
					out << genSQLLine(strContent_, true, ((i+1)!=ulLen), true);
					break;
				}
			}
		}
		else
		{
			if( attribute->type_def()->type()->kind() == CORBA::tk_value )
			{
				std::list<IR__::ValueDef_var>::iterator valuetype_iter;
				for(valuetype_iter = lValueTypes_.begin();
					valuetype_iter != lValueTypes_.end();
					valuetype_iter++)
				{
					IR__::ValueDef_var value = IR__::ValueDef::_narrow(*valuetype_iter);
					std::string attr_type_name = map_attribute_type(attribute->type_def());
					if(attr_type_name.find(mapName(value))!=std::string::npos)
					{
						IR__::ContainedSeq_var contained_seq = value->contents(CORBA__::dk_ValueMember, true);
						for(CORBA::ULong j = 0; j < contained_seq->length(); j++)
						{
							strContent_ = "NULL";
							out << genSQLLine(strName_, strContent_, true, ((i+1)!=ulLen), true);
						}
					}
				}	
			}
			else
			{
				strContent_ = "NULL";
				out << genSQLLine(strName_, strContent_, true, ((i+1)!=ulLen), true);
			}
		}
	}
	strContent_ = ");";
	out << genSQLLine(strName_, strContent_, true, false, false);
	//++++++++++++++++++++++++++++++++++++++++
	// end of INSERT sentence for FACTORY !!!!
	//++++++++++++++++++++++++++++++++++++++++
	
	out << "\nif(pCatalogBaseImpl->ExecuteSQL(" << strName_ << ".str().c_str()))\n";
	out << "{\n";
	out.indent();
	out << "//use factory to create a storage object\n";
	out << "StorageObjectFactory factory = NULL;\n";
	out << "factory = pCatalogBaseImpl->getConnector()->register_storage_object_factory(\"\", factory);\n";
	out << "StorageObjectImpl* pObjectImpl = factory->create();\n";
	out << "//factory->_remove_ref();\n";
	out << map_psdl_return_type(ret_type, false) << " pActObject = dynamic_cast <" << map_psdl_return_type(ret_type, false) << "> (pObjectImpl);\n";
	out << "\n//set values to current storageobject incarnation\n";
	out << "//How to handle with pid, spid and the other member variables not given?\n";
	for(CORBA::ULong j=0; j<pards->length(); j++)
	{
		IR__::ParameterDescription pardescr = (*pards)[j];
		ret_type = pardescr.type_def;
		out << "pActObject->" << std::string(pardescr.name) << "(";
		if( ret_type->type()->kind() == CORBA::tk_value )
			out << "*"; // special for valuetype
		out << std::string(pardescr.name) << ");\n";
	}
	out << "lObjectes_.push_back(pActObject);\n";
	out << "\nreturn pActObject;\n";
	out.unindent();
	out << "}\n";
	out << "else\n";
	out.indent();
	out << "throw CORBA::BAD_PARAM();\n";
	out.unindent();

	out.unindent();
	out << "}\n\n";
}

void
GeneratorPersistenceC::doFactory(IR__::FactoryDef_ptr factory, IR__::InterfaceDef_ptr inf_def)
{
	if(bAbstract_)
	{
		IR__::AbstractStorageTypeDef_var abs_storagetype;
		IR__::AbstractStorageHomeDef_var abs_storagehome = IR__::AbstractStorageHomeDef::_narrow(inf_def);
		if(!CORBA::is_nil(abs_storagehome))
			abs_storagetype = abs_storagehome->managed_abstract_storagetype();
		if(!CORBA::is_nil(abs_storagetype))
			genFactory(factory, abs_storagetype, abs_storagehome);
	}
	else
	{
		IR__::StorageTypeDef_var storagetype;
		IR__::StorageHomeDef_var storagehome = IR__::StorageHomeDef::_narrow(inf_def);
		if(!CORBA::is_nil(storagehome))
			storagetype = storagehome->managed_storagetype();
		if(!CORBA::is_nil(storagetype))
			genFactory(factory, storagetype, storagehome);
	}
}

void
GeneratorPersistenceC::genKey(IR__::OperationDef_ptr operation, IR__::InterfaceDef_ptr inf_type, IR__::InterfaceDef_ptr inf_home, bool isRef)
{
	IR__::IDLType_var ret_type = IR__::IDLType::_narrow(inf_type);

	if(!isRef)
		out << "\n//\n// " << operation->id() << "\n//\n";
	char* szReturnType = map_psdl_return_type(ret_type, false);
	char* szOriginalType = map_psdl_return_type(ret_type, false);

	//since the definition of a abstract stoage type is not yet supported, 
	//we have to replcace the "*" with "Ref" for operation find_by_ref_... 
	if(isRef)
	{
		char* pdest = strstr( szReturnType, "*" );
		if( pdest != NULL )
		{
			memset(pdest, '\0', 1);
			strcat(szReturnType, "Ref");
		}
	}
	
	out << szReturnType << "\n" << strClassname_ << "::";
	isRef ? out << "find_ref_by_" : out << "find_by_";
	out << mapName(operation) << "(";

	// parameters
	IR__::ParDescriptionSeq_var pards = operation->params();
	for( CORBA::ULong i=0; i<pards->length(); i++)
	{
		IR__::ParameterDescription pardescr = (*pards)[i];
		if (pardescr.mode == IR__::PARAM_IN) {
			out << map_in_parameter_type (pardescr.type_def) << " " << std::string(pardescr.name);
		};
		if (pardescr.mode == IR__::PARAM_OUT) {
			out << map_out_parameter_type (pardescr.type_def) << " " << std::string(pardescr.name);
		};
		if (pardescr.mode == IR__::PARAM_INOUT) {
			out << map_inout_parameter_type (pardescr.type_def) << " " << std::string(pardescr.name);
		};

		if((i+1)!=pards->length()) { out << ", "; }
	};

	out << ")";
	
	if(!isRef)
	{
		out << "\n";
		out.indent();
		out << "throw(CosPersistentState::NotFound";
		handleException(operation);
		out << ")";
		out.unindent();
	}
	
	out << "\n{\n";
	out.indent();

	//++++++++++++++++++++++++++++++++++++++++
	// SELECT sentence for KEY
	//++++++++++++++++++++++++++++++++++++++++
	if(!isRef)
		out << szReturnType << " pActObject = NULL;\n";
	else
		out << szOriginalType << " pActObject = NULL;\n";
	out << "std::stringstream strKey;\n\n";
	strName_ = "strKey";
	strContent_ = "SELECT pid FROM ";
	strContent_ += inf_home->name();
	out << genSQLLine(strName_, strContent_, true, false, true);
	strContent_ = "WHERE";
	out << genSQLLine(strName_, strContent_, true, false, true);

	CORBA::ULong ulLen = pards->length();

	for( i=0; i<ulLen; i++ )
	{
		IR__::ParameterDescription pardescr = (*pards)[i];
	
		if( pardescr.type_def->type()->kind() == CORBA::tk_value )
		{
			std::list<IR__::ValueDef_var>::iterator valuetype_iter;
			for(valuetype_iter = lValueTypes_.begin();
				valuetype_iter != lValueTypes_.end();
				valuetype_iter++)
			{
				IR__::ValueDef_var value = IR__::ValueDef::_narrow(*valuetype_iter);
				std::string attr_type_name = map_attribute_type(pardescr.type_def);
				if(attr_type_name.find(mapName(value))!=std::string::npos)
				{
					IR__::ContainedSeq_var contained_seq = value->contents(CORBA__::dk_ValueMember, true);
					for(CORBA::ULong j = 0; j < contained_seq->length(); j++)
					{
						IR__::ValueMemberDef_var vMember = IR__::ValueMemberDef::_narrow((*contained_seq)[j]);
						strContent_ = "value_" + mapName(vMember);
						if(psdl_check_type(vMember->type_def())!=CPPBase::_STRING)
							strContent_ += " =";
						else
							strContent_ += " LIKE";
						out << genSQLLine(strName_, strContent_, true, false, true);

						switch(psdl_check_type(vMember->type_def()))
						{
						case CPPBase::_SHORT:
						case CPPBase::_INT:
						case CPPBase::_LONG:
							strContent_ = std::string(pardescr.name) + "->";
							strContent_ += mapName(vMember) + "()";
							out << genSQLLine(strName_, strContent_, false, false, false, true);
							strContent_ = "";
							out << genSQLLine(strContent_, true, ((i+1)!=ulLen), true);
							break;
						case CPPBase::_STRING:
							strContent_ = "\\'";
							out << genSQLLine(strName_, strContent_, false, false, false);
							strContent_ = std::string(pardescr.name) + "->";
							strContent_ += mapName(vMember) + "()";
							out << genSQLLine(strContent_, false, false, false, true);
							strContent_ = "\\'";
							out << genSQLLine(strContent_, true, ((i+1)!=ulLen), true);
							break;
						}
					}
					break;
				}
			}
		}
		else
		{
			strContent_ = std::string(pardescr.name);

			if(psdl_check_type(pardescr.type_def)!=CPPBase::_STRING)
				strContent_ += " =";
			else
				strContent_ += " LIKE";
			out << genSQLLine(strName_, strContent_, true, false, true);

			switch(psdl_check_type(pardescr.type_def))
			{
			case CPPBase::_SHORT:
			case CPPBase::_INT:
			case CPPBase::_LONG:
			case CPPBase::_FLOAT:
			case CPPBase::_DOUBLE:
			case CPPBase::_LONGDOUBLE:
				strContent_ = std::string(pardescr.name);
				out << genSQLLine(strName_, strContent_, false, false, false, true);
				strContent_ = "";
				out << genSQLLine(strContent_, true, ((i+1)!=ulLen), true);
				break;
			case CPPBase::_STRING:
				strContent_ = "\\'";
				out << genSQLLine(strName_, strContent_, false, false, false);
				strContent_ = std::string(pardescr.name);
				out << genSQLLine(strContent_, false, false, false, true);
				strContent_ = "\\'";
				out << genSQLLine(strContent_, true, ((i+1)!=ulLen), true);
				break;
			case CPPBase::_BOOL:
				strContent_ = "convertBool2String(" + std::string(pardescr.name) + ")";
				out << genSQLLine(strName_, strContent_, false, false, false, true);
				strContent_ = "";
				out << genSQLLine(strContent_, true, ((i+1)!=ulLen), true);
				break;
			}
		}
	}
	strContent_ = ");";
	out << genSQLLine(strName_, strContent_, true, false, false);
	//++++++++++++++++++++++++++++++++++++++++
	// end of SELECT sentence for KEY !!!!!!!!
	//++++++++++++++++++++++++++++++++++++++++

	out << "\nif(!Open(" << strName_ << ".str().c_str()))\n";
	out.indent();
	out << "throw CosPersistentState::NotFound();\n\n";
	out.unindent();
	out << "if (GetFieldCount()<=0)\n{\n";
	out.indent();
	out << "Close();\n";
	out << "throw CosPersistentState::NotFound();\n";
	out.unindent();
	out << "}\n\n";
	out << "unsigned char* szPid = new unsigned char[254];\n";
	out << "memset(szPid, \'\\0\', 254);\n";
	out << "GetFieldValue(0, szPid);\n";
	out << "Close();\n\n";
	out << "std::string strPid = \"\";\n";
	out << "strPid.append((const char*)szPid);\n";
	out << "StorageObjectBase pObject = find_by_pid(strPid);\n";
	if(!isRef)
	{
		out << "pActObject = dynamic_cast <" << szReturnType << "> (pObject);\n\n";
		out << "return pActObject;\n";
	}
	else
	{
		out << "pActObject = dynamic_cast <" << szOriginalType << "> (pObject);\n";
		out << szReturnType << " ref = pActObject;\n\n";
		out << "return ref;\n";
	}

	out.unindent();
	out << "}\n\n";
}

void
GeneratorPersistenceC::doKey(IR__::KeyDef_ptr key, IR__::InterfaceDef_ptr inf_def)
{
	if(bAbstract_)
	{
		IR__::AbstractStorageTypeDef_var abs_storagetype;
		IR__::AbstractStorageHomeDef_var abs_storagehome = IR__::AbstractStorageHomeDef::_narrow(inf_def);
		if(!CORBA::is_nil(abs_storagehome))
			abs_storagetype = abs_storagehome->managed_abstract_storagetype();
		if(!CORBA::is_nil(abs_storagetype))
		{
			genKey(key, abs_storagetype, abs_storagehome, false);
			genKey(key, abs_storagetype, abs_storagehome, true);
		}
	}
	else
	{
		IR__::StorageTypeDef_var storagetype;
		IR__::StorageHomeDef_var storagehome = IR__::StorageHomeDef::_narrow(inf_def);
		if(!CORBA::is_nil(storagehome))
			storagetype = storagehome->managed_storagetype();
		if(!CORBA::is_nil(storagetype))
		{
			genKey(key, storagetype, storagehome, false);
			genKey(key, storagetype, storagehome, true);
		}
	}
}

void 
GeneratorPersistenceC::doException(IR__::ExceptionDef_ptr except)
{
	out << ", " << mapFullName(except);
}

void
GeneratorPersistenceC::genAbstractObjsForConcreteType(IR__::AbstractStorageTypeDef_ptr abs_storagetype)
{
	IR__::InterfaceDefSeq_var abs_storagetype_seq = abs_storagetype->base_abstract_storagetypes();
	
	for(CORBA::ULong i=0; i<abs_storagetype_seq->length(); i++) 
	{
		handleAttribute((*abs_storagetype_seq)[i]);
		handleOperation((*abs_storagetype_seq)[i]);
	}

	handleAttribute(abs_storagetype);
	handleOperation(abs_storagetype);
}

void
GeneratorPersistenceC::genStorageTypeBody(IR__::StorageTypeDef_ptr storagetype/*, bool isRef*/)
{
	std::string strStoragehomeName = "";
	strClassname_ = std::string(storagetype->name());

	IR__::InterfaceDefSeq_var supported_infs = storagetype->supported_interfaces();
	homeIter_ = homeMap_.find(storagetype->name());
	if( homeIter_!=homeMap_.end() )
		strStoragehomeName = homeMap_[storagetype->name()];

	out << strClassname_;
	//if(isRef) out << "Ref";
	out << "::" << strClassname_;
	//if(isRef) out << "Ref";
	out	<< "()\n";
	out << "{\n";

	IR__::AttributeDef_var attribute = 0;
	IR__::AttributeDefSeq state_members = collectStateMembers(storagetype, CORBA__::dk_Create);
	CORBA::ULong ulLen = state_members.length();

	out << "}\n\n";
	out << strClassname_;
	//if(isRef) out << "Ref";
	out << "::~" << strClassname_;
	//if(isRef) out << "Ref";
	out << "()\n";
	out << "{\n}\n\n";

	//bRef_ = isRef;
	//genAbstractObjsForConcreteType(abs_storagetype);
	for(CORBA::ULong i = 0; i < supported_infs->length(); i++) 
	{
		IR__::AbstractStorageTypeDef_var abs_storage_type_inh;
		abs_storage_type_inh = IR__::AbstractStorageTypeDef::_narrow((*supported_infs)[i]);
		genAbstractObjsForConcreteType(abs_storage_type_inh);
	};
	handleAttribute(storagetype);
	handleOperation(storagetype);

	out << "void\n";
	out << strClassname_ << "::write_state()\n";
	out << "{\n";
	out.indent();
	state_members = collectStateMembers(storagetype, CORBA__::dk_Create);
	ulLen = state_members.length();
	out << "std::stringstream strstream;\n";
	strName_ = "strstream";
	strContent_ = "UPDATE ";
	strContent_ += strNamespace_ + "_";
	strContent_ += strStoragehomeName;
	strContent_ += " SET";
	out << genSQLLine(strName_, strContent_, true, false, true);

	for(CORBA::ULong i=0; i<ulLen; i++)
	{
		attribute = IR__::AttributeDef::_narrow(state_members[i]);

		if( attribute->type_def()->type()->kind() == CORBA::tk_value )
		{/*
			std::list<IR__::ValueDef_var>::iterator valuetype_iter;
			for(valuetype_iter = lValueTypes_.begin();
				valuetype_iter != lValueTypes_.end();
				valuetype_iter++)
			{
				IR__::ValueDef_var value = IR__::ValueDef::_narrow(*valuetype_iter);
				std::string attr_type_name = map_attribute_type(attribute->type_def());
				if(attr_type_name.find(mapName(value))!=std::string::npos)
				{
					IR__::ContainedSeq_var contained_seq = value->contents(CORBA__::dk_ValueMember, true);
					for(CORBA::ULong j = 0; j < contained_seq->length(); j++)
					{
						IR__::ValueMemberDef_var vMember = IR__::ValueMemberDef::_narrow((*contained_seq)[j]);
						strContent_ = "value_" + mapName(vMember) + " = ";

						switch(psdl_check_type(vMember->type_def()))
						{
						case CPPBase::_SHORT:
						case CPPBase::_INT:
						case CPPBase::_LONG:
							out << genSQLLine(strName_, strContent_, false, false, false, false);
							strContent_ = mapName(attribute) + "_->";
							strContent_ += mapName(vMember) + "()";
							out << genSQLLine(strContent_, false, false, false, true);
							strContent_ = "";
							out << genSQLLine(strContent_, true, ((i+1)!=ulLen), true);
							break;
						case CPPBase::_STRING:
							out << genSQLLine(strName_, strContent_, false, false, false, false);
							strContent_ = "\\'";
							out << genSQLLine(strContent_, false, false, false);
							strContent_ = mapName(attribute) + "_->";
							strContent_ += mapName(vMember) + "()";
							out << genSQLLine(strContent_, false, false, false, true);
							strContent_ = "\\'";
							out << genSQLLine(strContent_, true, ((i+1)!=ulLen), true);
							break;
						}
					}
					break;
				}
			}*/
		}
		else
		{
			strContent_ = mapName(attribute) + " = ";

			switch(psdl_check_type(attribute->type_def()))
			{
			case CPPBase::_SHORT:
			case CPPBase::_INT:
			case CPPBase::_LONG:
			case CPPBase::_FLOAT:
			case CPPBase::_DOUBLE:
			case CPPBase::_LONGDOUBLE:
				out << genSQLLine(strName_, strContent_, false, false, false);
				strContent_ = mapName(attribute) + "_";
				out << genSQLLine(strContent_, false, false, false, true);
				strContent_ = "";
				out << genSQLLine(strContent_, true, ((i+1)!=ulLen), true);
				break;
			case CPPBase::_STRING:
				out << genSQLLine(strName_, strContent_, false, false, false);
				strContent_ = "\\'";
				out << genSQLLine(strContent_, false, false, false);
				strContent_ =  mapName(attribute) + "_";
				out << genSQLLine(strContent_, false, false, false, true);
				strContent_ = "\\'";
				out << genSQLLine(strContent_, true, ((i+1)!=ulLen), true);
				break;
			case CPPBase::_BOOL:
				out << genSQLLine(strName_, strContent_, false, false, false);
				strContent_ = "convertBool2String(" +  mapName(attribute) + "_)";
				out << genSQLLine(strContent_, false, false, false, true);
				strContent_ = "";
				out << genSQLLine(strContent_, true, ((i+1)!=ulLen), true);
				break;
			}
		}
	}

	strContent_ = "WHERE pid LIKE \\'";
	out << genSQLLine(strName_, strContent_, false, false, false);
	strContent_ = "convertPidToString(get_pid())";
	out << genSQLLine(strContent_, false, false, false, true);
	strContent_ = "\\';";
	out << genSQLLine(strContent_, true, false, false);
	out << "StorageHomeBaseImpl* pHomeBaseImpl = dynamic_cast <StorageHomeBaseImpl*> (get_storage_home());\n";
	out << "pHomeBaseImpl->write_state(strstream.str());\n";
	out.unindent();
	out << "}\n\n";

	out << "void\n";
	out << strClassname_ << "::read_state()\n";
	out << "{\n";
	out.indent();
	/*
	out << "std::stringstream strstream;\n\n";
	out << "// for CatalogBase::refresh()\n";
	strName_ = "strstream";
	strContent_ = "SELECT * FROM ";
	strContent_ += strStoragehomeName;
	out << genSQLLine(strName_, strContent_, true, false, true);
	strContent_ = "WHERE pid LIKE \\'";
	out << genSQLLine(strName_, strContent_, false, false, false);
	strContent_ = "convertPidToString(pPid_)";
	out << genSQLLine(strContent_, false, false, false, true);
	strContent_ = "\\';";
	out << genSQLLine(strContent_, true, false, false);
	out << "strSelect_ = strstream.str();\n";
	out << "\n";*/
	out.unindent();
	out << "}\n\n";

	out << "void\n";
	out << strClassname_;
	//if(isRef) out << "Ref";
	out << "::setValue(std::map<std::string, CORBA::Any>& valueMap)\n";
	out << "{\n";
	out.indent();
	out << "char* szTemp;\n";
	out << "bool bTemp = false;\n";
	out << "std::map <std::string, CORBA::Any> :: const_iterator colIter;\n\n";
	out << "colIter = valueMap.find(\"pid\");\n";
	out << "colIter->second >>= szTemp;\n";
	out << "set_pid(szTemp);\n\n";
	out << "colIter = valueMap.find(\"spid\");\n";
	out << "colIter->second >>= szTemp;\n";
	out << "set_short_pid(szTemp);\n\n";

	for(CORBA::ULong i=0; i<ulLen; i++)
	{
		attribute = IR__::AttributeDef::_narrow(state_members[i]);

		if( attribute->type_def()->type()->kind() == CORBA::tk_value )
		{/*
			std::list<IR__::ValueDef_var>::iterator valuetype_iter;
			for(valuetype_iter = lValueTypes_.begin();
				valuetype_iter != lValueTypes_.end();
				valuetype_iter++)
			{
				IR__::ValueDef_var value = IR__::ValueDef::_narrow(*valuetype_iter);
				std::string attr_type_name = map_attribute_type(attribute->type_def());
				if(attr_type_name.find(mapName(value))!=std::string::npos)
				{
					IR__::ContainedSeq_var contained_seq = value->contents(CORBA__::dk_ValueMember, true);
					for(CORBA::ULong j = 0; j < contained_seq->length(); j++)
					{
						IR__::ValueMemberDef_var vMember = IR__::ValueMemberDef::_narrow((*contained_seq)[j]);
						out << "colIter = valueMap.find(\"value_" << mapName(vMember) << "\");\n";

						switch(psdl_check_type(vMember->type_def()))
						{
						case CPPBase::_SHORT:
						case CPPBase::_INT:
						case CPPBase::_LONG:
						case CPPBase::_FLOAT:
						case CPPBase::_DOUBLE:
						case CPPBase::_LONGDOUBLE:
						case CPPBase::_STRING:
							out << "colIter->second >>= szTemp;\n";
							out << mapName(attribute) << "_->" << mapName(vMember) << "(szTemp);\n\n";
							break;
						case CPPBase::_BOOL:
							out << "colIter->second >>= CORBA::Any::to_boolean(bTemp);\n";
							out << mapName(attribute) << "_->" << mapName(vMember) << "(bTemp);\n\n";
							break;
						}
					}
					break;
				}
			}*/
		}
		else
		{
			out << "colIter = valueMap.find(\"" << mapName(attribute) << "\");\n";

			switch(psdl_check_type(attribute->type_def()))
			{
			case CPPBase::_SHORT:
			case CPPBase::_INT:
			case CPPBase::_LONG:
			case CPPBase::_FLOAT:
			case CPPBase::_DOUBLE:
			case CPPBase::_LONGDOUBLE:
				out << "colIter->second >>= " << mapName(attribute) << "_;\n\n";
				break;
			case CPPBase::_STRING:
				out << "colIter->second >>= szTemp;\n";
				out << mapName(attribute) << "_ = szTemp;\n\n";
				break;
			case CPPBase::_BOOL:
				out << "colIter->second >>= CORBA::Any::to_boolean(" << mapName(attribute) << "_);\n\n";
				break;
			}
		}
	}
	out.unindent();
	out << "}\n\n";
	//genDuplAndDown(strClassname_);
	//out << "\n";
}

void
GeneratorPersistenceC::genBaseRefBody(std::string strTypeName)
{
	out << strTypeName << "Ref::" << strTypeName << "Ref() :\n";
	out.indent();
	out << "pObj_(NULL)\n";
	out.unindent();
	out << "{\n";
	out << "}\n\n";

	out << strTypeName << "Ref::" << strTypeName << "Ref(" << strTypeName << "* obj) :\n";
	out.indent();
	out << "pObj_(NULL)\n";
	out.unindent();
	out << "{\n";
	out.indent();
	out << "if( obj!= NULL )\n";
	out.indent();
	out << "pObj_ = obj;\n";
	out.unindent();
	out.unindent();
	out << "}\n\n";

	out << strTypeName << "Ref::" << strTypeName << "Ref(const " << strTypeName << "Ref& ref) :\n";
	out.indent();
	out << "pObj_(NULL)\n";
	out.unindent();
	out << "{\n";
	out.indent();
	out << "pObj_ = ref.deref();\n";
	out.unindent();
	out << "}\n\n";

	out << strTypeName << "Ref::~" << strTypeName << "Ref()\n";
	out << "{\n";
	out.indent();
	out << "if( pObj_!=NULL )\n";
	out.indent();
	out << "pObj_->_remove_ref();\n";
	out.unindent();
	out << "pObj_ = NULL;\n";
	out.unindent();
	out << "}\n\n";

	out << strTypeName << "Ref&\n";
	out << strTypeName << "Ref::operator=(const " << strTypeName << "Ref& ref)\n";
	out << "{\n";
	out.indent();
	out << "if( pObj_!=ref.pObj_ )\n";
	out << "{\n";
	out.indent();
	out << "if( pObj_!=NULL )\n";
	out.indent();
	out << "pObj_->_remove_ref();\n\n";
	out.unindent();
	out << "pObj_ = ref.pObj_;\n\n";
	out << "if( pObj_!=NULL )\n";
	out.indent();
	out << "pObj_->_add_ref();\n";
	out.unindent();
	out.unindent();
	out << "}\n\n";
	out << "return *this;\n";
	out.unindent();
	out << "}\n\n";
	
	out << strTypeName << "Ref&\n";
	out << strTypeName << "Ref::operator=(" << strTypeName << "* obj)\n";
	out << "{\n";
	out.indent();
	out << "if( pObj_!=NULL )\n";
	out.indent();
	out << "pObj_->_remove_ref();\n\n";
	out.unindent();
	out << "pObj_ = obj;\n\n";
	out << "return *this;\n";
	out.unindent();
	out << "}\n\n";

	out << strTypeName << "*\n";
	out << strTypeName << "Ref::operator->() const\n";
	out.indent();
	out << "throw(CORBA::SystemException)\n";
	out.unindent();
	out << "{\n";
	out.indent();
	out << "return pObj_;\n";
	out.unindent();
	out << "}\n\n";

	out << strTypeName << "*\n";
	out << strTypeName << "Ref::deref() const\n";
	out.indent();
	out << "throw(CORBA::SystemException)\n";
	out.unindent();
	out << "{\n";
	out.indent();
	out << "return pObj_;\n";
	out.unindent();
	out << "}\n\n";


	out << "void\n";
	out << strTypeName << "Ref::release()\n";
	out << "{\n";
	out.indent();
	out << "if( pObj_!=NULL )\n";
	out.indent();
	out << "pObj_->_remove_ref();\n";
	out.unindent();
	out << "pObj_ = NULL;\n";
	out.unindent();
	out << "}\n\n";

	out << "void\n";
	out << strTypeName << "Ref::destroy_object()\n";
	out.indent();
	out << "throw(CORBA::SystemException)\n";
	out.unindent();
	out << "{\n";
	out.indent();
	out << "if( pObj_!=NULL )\n";
	out.indent();
	out << "pObj_->destroy_object();\n";
	out.unindent();
	out.unindent();
	out << "}\n\n";

	out << "Pid*\n";
	out << strTypeName << "Ref::get_pid() const\n";
	out.indent();
	out << "throw(CORBA::SystemException)\n";
	out.unindent();
	out << "{\n";
	out.indent();
	out << "Pid* pPid = NULL;\n\n";
	out << "if( pObj_!=NULL )\n";
	out.indent();
	out << "pPid = pObj_->get_pid();\n\n";
	out.unindent();
	out << "return pPid;\n";
	out.unindent();
	out << "}\n\n";

	out << "ShortPid*\n";
	out << strTypeName << "Ref::get_short_pid() const\n";
	out.indent();
	out << "throw(CORBA::SystemException)\n";
	out.unindent();
	out << "{\n";
	out.indent();
	out << "ShortPid* pSpid = NULL;\n\n";
	out << "if( pObj_!=NULL )\n";
	out.indent();
	out << "pSpid = pObj_->get_short_pid();\n\n";
	out.unindent();
	out << "return pSpid;\n";
	out.unindent();
	out << "}\n\n";

	out << "CORBA::Boolean\n";
	out << strTypeName << "Ref::is_null() const\n";
	out << "{\n";
	out.indent();
	out << "return ( pObj_==NULL );\n";
	out.unindent();
	out << "}\n\n";

	out << strActBasename_ << "*\n";
	out << strTypeName << "Ref::get_storage_home() const\n";
	out.indent();
	out << "throw(CORBA::SystemException)\n";
	out.unindent();
	out << "{\n";
	out.indent();
	out << "StorageHomeBase_var pHomeBase = StorageHomeBase::_nil();\n";
	out << strActBasename_ << "* pHome = NULL;\n\n";
	out << "if( pObj_!=NULL )\n";
	out << "{\n";
	out.indent();
	out << "pHomeBase = pObj_->get_storage_home();\n";
	out << "pHome = dynamic_cast <" << strActBasename_ << "*> (pHomeBase._retn());\n";
	out.unindent();
	out << "}\n\n";
	out << "return pHome;\n";
	out.unindent();
	out << "}\n\n";

	out << strTypeName << "Ref\n";
	out << strTypeName << "Ref::_duplicate(const " << strTypeName << "Ref ref)\n";
	out << "{\n";
	out.indent();
	out << "return " << strTypeName << "Ref( ref );\n";
	out.unindent();
	out << "}\n\n";

	out << strTypeName << "Ref\n";
	out << strTypeName << "Ref::_downcast(const " << strTypeName << "Ref ref)\n";
	out << "{\n";
	out.indent();
	out << "return ref;\n";
	out.unindent();
	out << "}\n\n";
}

void
GeneratorPersistenceC::genRefBody(IR__::StorageTypeDef_ptr storagetype)
{
	std::string strClassName = std::string(storagetype->name());
	genBaseRefBody(strClassName);
	
	// generate conversion operators
	out << "//conversion operators\n";
	out << "//... to do ...\n\n";
}

void
GeneratorPersistenceC::genAbstractRefBody(IR__::AbstractStorageTypeDef_ptr abs_storagetype)
{
	std::string strClassName = std::string(abs_storagetype->name());
	genBaseRefBody(strClassName);
	
	// generate conversion operators
	out << "//conversion operators\n";
	out << "//... to do ...\n\n";
}

void 
GeneratorPersistenceC::doAbstractStorageType(IR__::AbstractStorageTypeDef_ptr abs_storagetype)
{
	out << "\n\n";	
	open_module(out, abs_storagetype, "");
	out << "\n\n";

	//std::string strClassName = std::string(abs_storagetype->name());
	//genDuplAndDown(strClassName);
	//out << "\n";

	// generate ref class
	// Don't known how to build a Ref-class :-(
	//genStorageTypeBody(storagetype, true);
	genAbstractRefBody(abs_storagetype); // Hopefully it's right!
	
	out << "\n\n";
	close_module(out, abs_storagetype);
}

void 
GeneratorPersistenceC::doStorageType(IR__::StorageTypeDef_ptr storagetype)
{
	out << "\n\n";	
	open_module(out, storagetype, "");
	out << "\n\n";

	// generate normal class
	genStorageTypeBody(storagetype/*, false*/);
	// generate ref class
	// Don't known how to build a Ref-class :-(
	//genStorageTypeBody(storagetype, true);
	genRefBody(storagetype); // Hopefully it's right!

	close_module(out, storagetype);
}

void
GeneratorPersistenceC::genAbstractObjsForConcreteHome(IR__::AbstractStorageHomeDef_ptr abs_storagehome)
{
	IR__::InterfaceDefSeq_var abs_storagehome_seq = abs_storagehome->base_abstract_storagehomes();

	for(CORBA::ULong i=0; i<abs_storagehome_seq->length(); i++) 
	{
		IR__::AbstractStorageHomeDef_var abs_storagehome_inh;
		abs_storagehome_inh = IR__::AbstractStorageHomeDef::_narrow((*abs_storagehome_seq)[i]);
		bAbstract_ = true;
		handleAttribute(abs_storagehome_inh);
		handleOperation(abs_storagehome_inh);
		handleFactory(abs_storagehome_inh);
		handleKey(abs_storagehome_inh);
	}

	bAbstract_ = true;
	handleAttribute(abs_storagehome);
	handleOperation(abs_storagehome);
	handleFactory(abs_storagehome);
	handleKey(abs_storagehome);
}

void
GeneratorPersistenceC::genCreateOperation(IR__::StorageHomeDef_ptr storagehome, bool isRef)
{
	IR__::InterfaceDefSeq_var supported_infs = storagehome->supported_interfaces();

	std::string strDummy = "";
	int iLength = strClassname_.length() + 10;
	char* szRetType = map_psdl_return_type(storagehome->managed_storagetype(), false);
	char* szOriginalType = map_psdl_return_type(storagehome->managed_storagetype(), false);
	IR__::AttributeDef_var attribute = IR__::AttributeDef::_nil();
	
	if(isRef)
	{
		char* pdest = strstr( szRetType, "*" );
		if( pdest != NULL )
		{
			memset(pdest, '\0', 1);
			strcat(szRetType, "Ref");
		}
	}
	
	out << szRetType << "\n" << strClassname_ << "::_create(";
	out << "Pid* pid,\n";
	strDummy.append(iLength, ' ');
	out << strDummy.c_str();
	out << "ShortPid* shortPid,\n";

	IR__::AttributeDefSeq state_members = 
		collectStateMembers(storagehome->managed_storagetype(), CORBA__::dk_Create);

	CORBA::ULong ulLen = state_members.length();

	for(CORBA::ULong i=0; i<ulLen; i++)
	{
		strDummy = "";
		strDummy.append(iLength, ' ');
		out << strDummy.c_str();

		attribute = IR__::AttributeDef::_narrow(state_members[i]);
		out << map_in_parameter_type(attribute->type_def()) << " " << mapName(attribute);
		if( (i+1)!=ulLen )
			out << ",\n";
	}
	
	if(isRef)
	{
		strDummy = "";
		strDummy.append(iLength, ' ');
		out << ",\n" << strDummy.c_str() << "CosPersistentState::YieldRef yr";
	}

	out << ")\n"; 
	out << "{\n";
	out.indent();

	//+++++++++++++++++++++++++++++++++++++++++++
	// INSERT sentence for _create in storagehome
	//+++++++++++++++++++++++++++++++++++++++++++
	out << "std::stringstream strInsert;\n\n";
	out << "CatalogBase_ptr pCatalogBase = get_catalog();\n";
	out << "CatalogBaseImpl* pCatalogBaseImpl = dynamic_cast <CatalogBaseImpl*> (pCatalogBase);\n\n";
	strName_ = "strInsert";

	out << strName_ << " << \"INSERT INTO pid_content (pid, home, type) VALUES ( \";\n";
	strContent_ = "\\'";
	out << genSQLLine(strName_, strContent_, false, false, false);
	strContent_ = "convertPidToString(pid)";
	out << genSQLLine(strContent_, false, false, false, true);
	strContent_ = "\\'";
	out << genSQLLine(strContent_, true, true, true);
	out << strName_ << " << \"\\\'" << strNamespace_ << "_" << storagehome->name() << "\\\', ";
	out << "\\\'" << strNamespace_ << "_" << storagehome->managed_storagetype()->name() << "\\\' );\";\n\n";
	out << "if(!pCatalogBaseImpl->ExecuteSQL(" << strName_ << ".str().c_str()))\n";
	out.indent();
	out << "throw CORBA::BAD_PARAM();\n\n";
	out.unindent();

	out << "strInsert.str(\"\");\n";
	out << strName_ << " << \"INSERT INTO " << strNamespace_ << "_" << storagehome->name() << " ( pid, spid, ";
	
	for(i=0; i<ulLen; i++)
	{
		attribute = IR__::AttributeDef::_narrow(state_members[i]);
		if( attribute->type_def()->type()->kind() == CORBA::tk_value )
		{
			std::list<IR__::ValueDef_var>::iterator valuetype_iter;
			for(valuetype_iter = lValueTypes_.begin();
				valuetype_iter != lValueTypes_.end();
				valuetype_iter++)
			{
				IR__::ValueDef_var value = IR__::ValueDef::_narrow(*valuetype_iter);
				std::string attr_type_name = map_attribute_type(attribute->type_def());
				if(attr_type_name.find(mapName(value))!=std::string::npos)
				{
					IR__::ContainedSeq_var contained_seq = value->contents(CORBA__::dk_ValueMember, true);
					for(CORBA::ULong j = 0; j < contained_seq->length(); j++)
					{
						IR__::ValueMemberDef_var vMember = IR__::ValueMemberDef::_narrow((*contained_seq)[j]);
						out << "value_" << mapName(vMember);
						( (i+1)!=ulLen ) ? out << ", " : out << " ) \";\n";
					}
					break;
				}
			}
		}
		else
		{
			out << mapName(attribute);
			( (i+1)!=ulLen ) ? out << ", " : out << " ) \";\n";
		}
	}
	
	strContent_ = "VALUES (";
	out << genSQLLine(strName_, strContent_, true, false, true);
	strContent_ = "\\'";
	out << genSQLLine(strName_, strContent_, false, false, false);
	strContent_ = "convertPidToString(pid)";
	out << genSQLLine(strContent_, false, false, false, true);
	strContent_ = "\\'";
	out << genSQLLine(strContent_, true, true, true);
	strContent_ = "\\'";
	out << genSQLLine(strName_, strContent_, false, false, false);
	strContent_ = "convertSpidToString(shortPid)";
	out << genSQLLine(strContent_, false, false, false, true);
	strContent_ = "\\'";
	out << genSQLLine(strContent_, true, true, true);

	for(CORBA::ULong i=0; i<ulLen; i++)
	{
		attribute = IR__::AttributeDef::_narrow(state_members[i]);
		// parse valuemember from valuetype
		if( attribute->type_def()->type()->kind() == CORBA::tk_value )
		{
			std::list<IR__::ValueDef_var>::iterator valuetype_iter;
			for(valuetype_iter = lValueTypes_.begin();
				valuetype_iter != lValueTypes_.end();
				valuetype_iter++)
			{
				IR__::ValueDef_var value = IR__::ValueDef::_narrow(*valuetype_iter);
				std::string attr_type_name = map_attribute_type(attribute->type_def());
				if(attr_type_name.find(mapName(value))!=std::string::npos)
				{
					IR__::ContainedSeq_var contained_seq = value->contents(CORBA__::dk_ValueMember, true);
					for(CORBA::ULong j = 0; j < contained_seq->length(); j++)
					{
						IR__::ValueMemberDef_var vMember = IR__::ValueMemberDef::_narrow((*contained_seq)[j]);
						switch(psdl_check_type(vMember->type_def()))
						{
						case CPPBase::_SHORT:
						case CPPBase::_INT:
						case CPPBase::_LONG:
							strContent_ = mapName(attribute) + "->";
							strContent_ += mapName(vMember) + "()";
							out << genSQLLine(strName_, strContent_, false, false, false, true);
							strContent_ = "";
							out << genSQLLine(strContent_, true, ((i+1)!=ulLen), true);
							break;
						case CPPBase::_STRING:
							strContent_ = "\\'";
							out << genSQLLine(strName_, strContent_, false, false, false);
							strContent_ = mapName(attribute) + "->";
							strContent_ += mapName(vMember) + "()";
							out << genSQLLine(strContent_, false, false, false, true);
							strContent_ = "\\'";
							out << genSQLLine(strContent_, true, ((i+1)!=ulLen), true);
							break;
						}
					}
					break;
				}
			}
		}
		else // for normal state member with normal data type
		{
			switch(psdl_check_type(attribute->type_def()))
			{
			case CPPBase::_SHORT:
			case CPPBase::_INT:
			case CPPBase::_LONG:
			case CPPBase::_FLOAT:
			case CPPBase::_DOUBLE:
			case CPPBase::_LONGDOUBLE:
				strContent_ = mapName(attribute);
				out << genSQLLine(strName_, strContent_, false, false, false, true);
				strContent_ = "";
				out << genSQLLine(strContent_, true, ((i+1)!=ulLen), true);
				break;
			case CPPBase::_STRING:
				strContent_ = "\\'";
				out << genSQLLine(strName_, strContent_, false, false, false);
				strContent_ = mapName(attribute);
				out << genSQLLine(strContent_, false, false, false, true);
				strContent_ = "\\'";
				out << genSQLLine(strContent_, true, ((i+1)!=ulLen), true);
				break;
			case CPPBase::_BOOL:
				strContent_ = "convertBool2String(" + mapName(attribute) + ")";
				out << genSQLLine(strName_, strContent_, false, false, false, true);
				strContent_ = "";
				out << genSQLLine(strContent_, true, ((i+1)!=ulLen), true);
				break;
			}
		}
	}
	strContent_ = ");";
	out << genSQLLine(strName_, strContent_, true, false, false);
	//++++++++++++++++++++++++++++++++++++++++++++++++++
	// end of INSERT sentence for _create in storagehome
	//++++++++++++++++++++++++++++++++++++++++++++++++++
	
	out << "\nif(pCatalogBaseImpl->ExecuteSQL(" << strName_ << ".str().c_str()))\n";
	out << "{\n";
	out.indent();
	
	out << "//use factory to create a storage object\n";
	out << "StorageObjectFactory factory = NULL;\n";
	out << "factory = pCatalogBaseImpl->getConnector()->register_storage_object_factory(\"" << strNamespace_ << "_" << storagehome->managed_storagetype()->name() << "\", factory);\n";
	out << "StorageObjectImpl* pObjectImpl = factory->create();\n";
	out << "//factory->_remove_ref();\n";
	if(!isRef)
		out << szRetType << " pActObject = dynamic_cast <" << szRetType << "> (pObjectImpl);\n";
	else
		out << szOriginalType << " pActObject = dynamic_cast <" << szOriginalType << "> (pObjectImpl);\n";
	out << "\n//set values to current storageobject incarnation\n";
	out << "pActObject->set_pid(pid);\n";
	out << "pActObject->set_short_pid(shortPid);\n";
	for(CORBA::ULong i=0; i<ulLen; i++)
	{
		attribute = IR__::AttributeDef::_narrow(state_members[i]);
		out << "pActObject->" << mapName(attribute) << "(";
		//if( attribute->type_def()->type()->kind() == CORBA::tk_value )
		//	out << "*"; // special for valuetype :-(
		out << mapName(attribute) << ");\n";
	}
	out << "pActObject->setStorageHome(this);\n\n";
	out << "lObjectes_.push_back(pActObject);\n\n";
	if(!isRef)
	{
		out << "return pActObject;\n";
	}
	else
	{
		out << szRetType << " ref = pActObject;\n";
		out << "return ref;\n";
	}
	
	out.unindent();
	out << "}\n";
	out << "else\n";
	out.indent();
	out << "throw CORBA::BAD_PARAM();\n";
	out.unindent();
	out.unindent();
	out << "}\n\n";
}

void 
GeneratorPersistenceC::doAbstractStorageHome(IR__::AbstractStorageHomeDef_ptr abs_storagehome)
{
	strActBasename_ = std::string(abs_storagehome->name());
}

void
GeneratorPersistenceC::doStorageHome(IR__::StorageHomeDef_ptr storagehome)
{
	strClassname_ = std::string(storagehome->name());
	strActBasename_ = strClassname_;

	IR__::StorageHomeDef_var base_storagehome = storagehome->base_storagehome();
	IR__::InterfaceDefSeq_var supported_infs = storagehome->supported_interfaces();
	IR__::StorageTypeDef_var storagetype = storagehome->managed_storagetype();
	
	CORBA::ULong ulLenSupportedInf = supported_infs->length();

	homeMap_[storagetype->name()] = storagehome->name();

	IR__::AttributeDefSeq state_members = collectStateMembers(storagetype, CORBA__::dk_Self);

	CORBA::ULong ulLen = state_members.length();
	IR__::AttributeDef_var attribute = IR__::AttributeDef::_nil();

	// achtung: wenn kein modul, sollte vielleicht PSS_ der prefix fr alle pss sein?
	out << "\n\n";
	open_module(out, storagetype, "");
	out << "\n\n";

	out << strClassname_ << "::" << strClassname_ << "()\n";
	out << "{\n}\n\n";
	out << strClassname_ << "::~" << strClassname_ << "()\n";
	out << "{\n}\n\n";
	
	genCreateOperation(storagehome, false);
	genCreateOperation(storagehome, true);
	
	//
	//generate find_(ref)_by_primary_key, which is appropriate to find_by_primary_key from home
	//
	if( composition_->lifecycle()==CIDL::lc_Entity )
	{
		IR__::HomeDef_var home = composition_->ccm_home();
		IR__::PrimaryKeyDef_var pkey = IR__::PrimaryKeyDef::_duplicate(home->primary_key());
		if( !CORBA::is_nil(pkey) )
		{
			out << map_psdl_return_type(storagetype, false) << "\n";
			out << strClassname_ << "::find_by_primary_key(" << mapFullNamePK(pkey) << "* pkey)\n"; 
			out.indent();
			out << "throw(CosPersistentState::NotFound)\n";
			out.unindent();
			out << "{\n";
			out.indent();
			//++++++++++++++++++++++++++++++++++++++++
			// SELECT sentence for find_by_primary_key
			//++++++++++++++++++++++++++++++++++++++++
			out << storagetype->name() << "* pActObject = NULL;\n";
			out << "std::stringstream strKey;\n\n";
			strName_ = "strKey";
			strContent_ = "SELECT spid FROM ";
			strContent_ += strNamespace_ + "_"; 
			strContent_ += storagehome->name();
			out << genSQLLine(strName_, strContent_, true, false, true);
			strContent_ = "WHERE";
			out << genSQLLine(strName_, strContent_, true, false, true);

			IR__::ValueDef_var value = pkey->primary_key();
			IR__::ContainedSeq_var contained_seq = value->contents(CORBA__::dk_ValueMember, true);
			CORBA::ULong ulLen = contained_seq->length();

			for( CORBA::ULong i=0; i<ulLen; i++ )
			{
				IR__::ValueMemberDef_var a_vMember = IR__::ValueMemberDef::_narrow((*contained_seq)[i]);

				strContent_ = "value_" + mapName(a_vMember);
				if(psdl_check_type(a_vMember->type_def())!=CPPBase::_STRING)
					strContent_ += " =";
				else
					strContent_ += " LIKE";
				out << genSQLLine(strName_, strContent_, true, false, true);

				switch(psdl_check_type(a_vMember->type_def()))
				{
				case CPPBase::_SHORT:
				case CPPBase::_INT:
				case CPPBase::_LONG:
					strContent_ = "pkey->";
					strContent_ += mapName(a_vMember) + "()";
					out << genSQLLine(strName_, strContent_, false, false, false, true);
					strContent_ = "";
					out << genSQLLine(strContent_, true, ((i+1)!=ulLen), true);
					break;
				case CPPBase::_STRING:
					strContent_ = "\\'";
					out << genSQLLine(strName_, strContent_, false, false, false);
					strContent_ = "pkey->";
					strContent_ += mapName(a_vMember) + "()";
					out << genSQLLine(strContent_, false, false, false, true);
					strContent_ = "\\'";
					out << genSQLLine(strContent_, true, ((i+1)!=ulLen), true);
					break;
				}
			}
			strContent_ = ";";
			out << genSQLLine(strName_, strContent_, true, false, false);
			//++++++++++++++++++++++++++++++++++++++++
			// end of SELECT sentence for KEY !!!!!!!!
			//++++++++++++++++++++++++++++++++++++++++

			out << "\nif(!Open(" << strName_ << ".str().c_str()))\n";
			out.indent();
			out << "throw CosPersistentState::NotFound();\n\n";
			out.unindent();
			out << "if (GetFieldCount()<=0)\n{\n";
			out.indent();
			out << "Close();\n";
			out << "throw CosPersistentState::NotFound();\n";
			out.unindent();
			out << "}\n\n";
			out << "unsigned char* szSpid = new unsigned char[254];\n";
			out << "memset(szSpid, \'\\0\', 254);\n";
			out << "GetFieldValue(0, szSpid);\n";
			out << "Close();\n\n";
			out << "std::string strSpid = \"\";\n";
			out << "strSpid.append((const char*)szSpid);\n";
			out << "ShortPid* pSpid = new ShortPid;\n";
			out << "convertStringToSpid(strSpid.c_str(), *pSpid);\n\n";
			out << "StorageObjectBase pObject = find_by_short_pid(*pSpid);\n\n";
			out << "pActObject = dynamic_cast <" << storagetype->name() << "*> (pObject);\n";
			out << "pActObject->setStorageHome(this);\n\n";
			out << "return pActObject;\n";
			out.unindent();
			out << "}\n\n";
		}
	}

	bRef_ = false;
	for( CORBA::ULong i=0; i<ulLenSupportedInf; i++ )
	{
		IR__::AbstractStorageHomeDef_var abs_storagehome;
		abs_storagehome = IR__::AbstractStorageHomeDef::_narrow((*supported_infs)[i]);
		genAbstractObjsForConcreteHome(abs_storagehome);
	};

	bAbstract_ = false;
	handleAttribute(storagehome);
	handleOperation(storagehome);
	handleFactory(storagehome);
	handleKey(storagehome);
	//genDuplAndDown(strClassname_);
	//out << "\n\n";
	close_module(out, storagetype);
}

IR__::AttributeDefSeq 
GeneratorPersistenceC::collectStateMembers(IR__::InterfaceDef_ptr inf_def, CORBA__::CollectStyle style)
{
	IR__::AttributeDefSeq state_members;

	IR__::AbstractStorageTypeDef_var abs_storagetype =
		IR__::AbstractStorageTypeDef::_narrow(inf_def);
	if(!CORBA::is_nil(abs_storagetype))
		abs_storagetype->get_state_members(state_members, style);

	IR__::StorageTypeDef_var storagetype = 
		IR__::StorageTypeDef::_narrow(inf_def);
	if(!CORBA::is_nil(storagetype))
		storagetype->get_state_members(state_members, style);

	return state_members;
}

std::string
GeneratorPersistenceC::genSQLLine(std::string strName, std::string strContent, bool end, bool comma, bool space, bool func)
{
	std::string strRet = strName;

	strRet += " << ";
	if(!func) strRet += "\"";
	strRet += strContent;
	if(comma) strRet += ",";
	if(space) strRet += " ";
	if(!func) strRet += "\"";
	if(end) strRet += ";\n";

	return strRet;
}

std::string
GeneratorPersistenceC::genSQLLine(std::string strContent, bool end, bool comma, bool space, bool func)
{
	std::string strRet = "";

	strRet += " << ";
	if(!func) strRet += "\"";
	strRet += strContent;
	if(comma) strRet += ",";
	if(space) strRet += " ";
	if(!func) strRet += "\"";
	if(end) strRet += ";\n";

	return strRet;
}

void
GeneratorPersistenceC::genComponentPersistence(IR__::HomeDef_ptr home, IR__::ComponentDef_ptr component, CIDL::LifecycleCategory lc)
{
	if( lc!=CIDL::lc_Entity && lc!=CIDL::lc_Process )
		return;

	// handle base component
	IR__::ComponentDef_var base_component = component->base_component();
	if(base_component)
		genComponentPersistence(home, base_component, lc);

	out << "// ================================================\n";
	out << "// " << "component persistence" << "\n";
	out << "// ================================================\n\n";
	out << component->name() << "Persistence::" << component->name() << "Persistence()\n";
	out << "{\n}\n\n";
	out << component->name() << "Persistence::~" << component->name() << "Persistence()\n";
	out << "{\n}\n\n";
	
	// handle attributes
	strClassname_ = component->name();
	strClassname_ +=  "Persistence";
	handleAttribute(component);
	
	IR__::AttributeDef_var attribute = IR__::AttributeDef::_nil();
	IR__::AttributeDefSeq state_members;
	component->get_state_members(state_members, CORBA__::dk_Create);
	CORBA::ULong ulLen = state_members.length();

	out << "void\n";
	out << strClassname_ << "::write_state()\n";
	out << "{\n";
	out.indent();
	out << "std::stringstream strstream;\n";
	strName_ = "strstream";
	strContent_ = "UPDATE ";
	strContent_ += strNamespace_ + "_";
	strContent_ += home->name();
	strContent_ += "Persistence SET";
	out << genSQLLine(strName_, strContent_, true, false, true);

	for(CORBA::ULong i=0; i<ulLen; i++)
	{
		attribute = IR__::AttributeDef::_narrow(state_members[i]);

		if( attribute->type_def()->type()->kind() == CORBA::tk_value )
		{/*
			std::list<IR__::ValueDef_var>::iterator valuetype_iter;
			for(valuetype_iter = lValueTypes_.begin();
				valuetype_iter != lValueTypes_.end();
				valuetype_iter++)
			{
				IR__::ValueDef_var value = IR__::ValueDef::_narrow(*valuetype_iter);
				std::string attr_type_name = map_attribute_type(attribute->type_def());
				if(attr_type_name.find(mapName(value))!=std::string::npos)
				{
					IR__::ContainedSeq_var contained_seq = value->contents(CORBA__::dk_ValueMember, true);
					for(CORBA::ULong j = 0; j < contained_seq->length(); j++)
					{
						IR__::ValueMemberDef_var vMember = IR__::ValueMemberDef::_narrow((*contained_seq)[j]);
						strContent_ = "value_" + mapName(vMember) + " = ";

						switch(psdl_check_type(vMember->type_def()))
						{
						case CPPBase::_SHORT:
						case CPPBase::_INT:
						case CPPBase::_LONG:
							out << genSQLLine(strName_, strContent_, false, false, false, false);
							strContent_ = mapName(attribute) + "_->";
							strContent_ += mapName(vMember) + "()";
							out << genSQLLine(strContent_, false, false, false, true);
							strContent_ = "";
							out << genSQLLine(strContent_, true, ((i+1)!=ulLen), true);
							break;
						case CPPBase::_STRING:
							out << genSQLLine(strName_, strContent_, false, false, false, false);
							strContent_ = "\\'";
							out << genSQLLine(strContent_, false, false, false);
							strContent_ = mapName(attribute) + "_->";
							strContent_ += mapName(vMember) + "()";
							out << genSQLLine(strContent_, false, false, false, true);
							strContent_ = "\\'";
							out << genSQLLine(strContent_, true, ((i+1)!=ulLen), true);
							break;
						}
					}
					break;
				}
			}*/
		}
		else
		{
			strContent_ = mapName(attribute) + " = ";

			switch(psdl_check_type(attribute->type_def()))
			{
			case CPPBase::_SHORT:
			case CPPBase::_INT:
			case CPPBase::_LONG:
			case CPPBase::_FLOAT:
			case CPPBase::_DOUBLE:
			case CPPBase::_LONGDOUBLE:
				out << genSQLLine(strName_, strContent_, false, false, false);
				strContent_ = mapName(attribute) + "_";
				out << genSQLLine(strContent_, false, false, false, true);
				strContent_ = "";
				out << genSQLLine(strContent_, true, ((i+1)!=ulLen), true);
				break;
			case CPPBase::_STRING:
				out << genSQLLine(strName_, strContent_, false, false, false);
				strContent_ = "\\'";
				out << genSQLLine(strContent_, false, false, false);
				strContent_ =  mapName(attribute) + "_";
				out << genSQLLine(strContent_, false, false, false, true);
				strContent_ = "\\'";
				out << genSQLLine(strContent_, true, ((i+1)!=ulLen), true);
				break;
			case CPPBase::_BOOL:
				out << genSQLLine(strName_, strContent_, false, false, false);
				strContent_ = "convertBool2String(" +  mapName(attribute) + "_)";
				out << genSQLLine(strContent_, false, false, false, true);
				strContent_ = "";
				out << genSQLLine(strContent_, true, ((i+1)!=ulLen), true);
				break;
			}
		}
	}

	strContent_ = "WHERE pid LIKE \\'";
	out << genSQLLine(strName_, strContent_, false, false, false);
	strContent_ = "convertPidToString(get_pid())";
	out << genSQLLine(strContent_, false, false, false, true);
	strContent_ = "\\';";
	out << genSQLLine(strContent_, true, false, false);
	out << "StorageHomeBaseImpl* pHomeBaseImpl = dynamic_cast <StorageHomeBaseImpl*> (get_storage_home());\n";
	out << "pHomeBaseImpl->write_state(strstream.str());\n";
	out.unindent();
	out << "}\n\n";

	out << "void\n";
	out << strClassname_ << "::read_state()\n";
	out << "{\n";
	out.indent();
	/*
	out << "std::stringstream strstream;\n\n";
	out << "// for CatalogBase::refresh()\n";
	strName_ = "strstream";
	strContent_ = "SELECT * FROM ";
	strContent_ += strStoragehomeName;
	out << genSQLLine(strName_, strContent_, true, false, true);
	strContent_ = "WHERE pid LIKE \\'";
	out << genSQLLine(strName_, strContent_, false, false, false);
	strContent_ = "convertPidToString(pPid_)";
	out << genSQLLine(strContent_, false, false, false, true);
	strContent_ = "\\';";
	out << genSQLLine(strContent_, true, false, false);
	out << "strSelect_ = strstream.str();\n";
	out << "\n";*/
	out.unindent();
	out << "}\n\n";

	// create operation 'setValue(...)'
	out << "\nvoid\n";
	out << component->name() << "Persistence::" << "setValue(std::map<std::string, CORBA::Any>& valueMap)\n";
	out << "{\n";
	out.indent();
	out << "char* szTemp;\n";
	out << "bool bTemp = false;\n";
	out << "std::map <std::string, CORBA::Any> :: const_iterator colIter;\n\n";
	out << "colIter = valueMap.find(\"pid\");\n";
	out << "colIter->second >>= szTemp;\n";
	out << "set_pid(szTemp);\n\n";
	out << "colIter = valueMap.find(\"spid\");\n";
	out << "colIter->second >>= szTemp;\n";
	out << "set_short_pid(szTemp);\n\n";

	for(CORBA::ULong i=0; i<ulLen; i++)
	{
		attribute = IR__::AttributeDef::_narrow(state_members[i]);

		if( attribute->type_def()->type()->kind() == CORBA::tk_value )
		{/*
			std::list<IR__::ValueDef_var>::iterator valuetype_iter;
			for(valuetype_iter = lValueTypes_.begin();
				valuetype_iter != lValueTypes_.end();
				valuetype_iter++)
			{
				IR__::ValueDef_var value = IR__::ValueDef::_narrow(*valuetype_iter);
				std::string attr_type_name = map_attribute_type(attribute->type_def());
				if(attr_type_name.find(mapName(value))!=std::string::npos)
				{
					IR__::ContainedSeq_var contained_seq = value->contents(CORBA__::dk_ValueMember, true);
					for(CORBA::ULong j = 0; j < contained_seq->length(); j++)
					{
						IR__::ValueMemberDef_var vMember = IR__::ValueMemberDef::_narrow((*contained_seq)[j]);
						out << "colIter = valueMap.find(\"value_" << mapName(vMember) << "\");\n";

						switch(psdl_check_type(vMember->type_def()))
						{
						case CPPBase::_SHORT:
						case CPPBase::_INT:
						case CPPBase::_LONG:
						case CPPBase::_FLOAT:
						case CPPBase::_DOUBLE:
						case CPPBase::_LONGDOUBLE:
						case CPPBase::_STRING:
							out << "colIter->second >>= szTemp;\n";
							out << mapName(attribute) << "_->" << mapName(vMember) << "(szTemp);\n\n";
							break;
						case CPPBase::_BOOL:
							out << "colIter->second >>= CORBA::Any::to_boolean(bTemp);\n";
							out << mapName(attribute) << "_->" << mapName(vMember) << "(bTemp);\n\n";
							break;
						}
					}
					break;
				}
			}*/
		}
		else
		{
			out << "colIter = valueMap.find(\"" << mapName(attribute) << "\");\n";

			switch(psdl_check_type(attribute->type_def()))
			{
			case CPPBase::_SHORT:
			case CPPBase::_INT:
			case CPPBase::_LONG:
			case CPPBase::_FLOAT:
			case CPPBase::_DOUBLE:
			case CPPBase::_LONGDOUBLE:
				out << "colIter->second >>= " << mapName(attribute) << "_;\n\n";
				break;
			case CPPBase::_STRING:
				out << "colIter->second >>= szTemp;\n";
				out << mapName(attribute) << "_ = szTemp;\n\n";
				break;
			case CPPBase::_BOOL:
				out << "colIter->second >>= CORBA::Any::to_boolean(" << mapName(attribute) << "_);\n\n";
				break;
			}
		}
	}
	out.unindent();
	out << "}\n\n";
	
	//generate _duplicate and _downcast operation
	//genDuplAndDown(strClassName);
}

void
GeneratorPersistenceC::genFactory(IR__::FactoryDef_ptr factory, IR__::HomeDef_ptr home)
{
	CORBA::ULong ulLen = 0;
	bool bFound = false;
	std::string strTemp = "";
	std::string strDummy = "";
	stringstream strDisplay;
	IR__::AttributeDefSeq state_members;

	IR__::AttributeDef_var attribute = IR__::AttributeDef::_nil();
	IR__::ComponentDef_var component = home->managed_component();
	std::string strComponentName = component->name();
	IR__::IDLType_var ret_type = IR__::IDLType::_narrow(component);
	out << strComponentName << "Persistence*\n";
	strDisplay << home->name() << "Persistence::" << mapName(factory) << "(";
	out << strDisplay.str();

	ulLen = strDisplay.str().length();
	strDummy.append(ulLen, ' ');
	
	out << "Pid* pid,\n";
	out << strDummy.c_str();
	out << "ShortPid* shortPid,\n";

	// parameters
	IR__::ParDescriptionSeq_var pards = factory->params();
	for( CORBA::ULong i=pards->length(); i>0; i--)
	{
		out << strDummy.c_str();
		IR__::ParameterDescription pardescr = (*pards)[i-1];
		if (pardescr.mode == IR__::PARAM_IN) {
			out << map_in_parameter_type (pardescr.type_def) << " " << std::string(pardescr.name);
		};
		if (pardescr.mode == IR__::PARAM_OUT) {
			out << map_out_parameter_type (pardescr.type_def) << " " << std::string(pardescr.name);
		};
		if (pardescr.mode == IR__::PARAM_INOUT) {
			out << map_inout_parameter_type (pardescr.type_def) << " " << std::string(pardescr.name);
		};
		if((i-1)!=0) { out << ",\n"; }
	};

	out << ")\n{\n";
	out.indent();

	//++++++++++++++++++++++++++++++++++++++++
	// INSERT sentence for FACTORY
	//++++++++++++++++++++++++++++++++++++++++
	component->get_state_members(state_members, CORBA__::dk_Create);
	out << "std::stringstream strFactory;\n\n";
	out << "CatalogBase_ptr pCatalogBase = get_catalog();\n";
	out << "CatalogBaseImpl* pCatalogBaseImpl = dynamic_cast <CatalogBaseImpl*> (pCatalogBase);\n\n";
	strName_ = "strFactory";

	out << strName_ << " << \"INSERT INTO pid_content (pid, home, type) VALUES ( \";\n";
	strContent_ = "\\'";
	out << genSQLLine(strName_, strContent_, false, false, false);
	strContent_ = "convertPidToString(pid)";
	out << genSQLLine(strContent_, false, false, false, true);
	strContent_ = "\\'";
	out << genSQLLine(strContent_, true, true, true);
	out << strName_ << " << \"\\\'" << strNamespace_ << "_" << home->name() << "Persistence\\\', ";
	out << "\\\'" << strNamespace_ << "_" << strComponentName << "Persistence\\\' );\";\n\n";
	out << "if(!pCatalogBaseImpl->ExecuteSQL(" << strName_ << ".str().c_str()))\n";
	out.indent();
	out << "throw CORBA::BAD_PARAM();\n\n";
	out.unindent();

	out << "strFactory.str(\"\");\n";
	out << strName_ << " << \"INSERT INTO " << strNamespace_ << "_" << home->name() << "Persistence ( pid, spid, ";

	ulLen = state_members.length();
	for(i=0; i<ulLen; i++)
	{
		attribute = IR__::AttributeDef::_narrow(state_members[i]);
		if( attribute->type_def()->type()->kind() == CORBA::tk_value )
		{
			std::list<IR__::ValueDef_var>::iterator valuetype_iter;
			for(valuetype_iter = lValueTypes_.begin();
				valuetype_iter != lValueTypes_.end();
				valuetype_iter++)
			{
				IR__::ValueDef_var value = IR__::ValueDef::_narrow(*valuetype_iter);
				std::string attr_type_name = map_attribute_type(attribute->type_def());
				if(attr_type_name.find(mapName(value))!=std::string::npos)
				{
					IR__::ContainedSeq_var contained_seq = value->contents(CORBA__::dk_ValueMember, true);
					for(CORBA::ULong j = 0; j < contained_seq->length(); j++)
					{
						IR__::ValueMemberDef_var vMember = IR__::ValueMemberDef::_narrow((*contained_seq)[j]);
						out << "value_" << mapName(vMember);
						( (i+1)!=ulLen ) ? out << ", " : out << " ) \";\n";
					}
					break;
				}
			}
		}
		else
		{
			out << mapName(attribute);
			( (i+1)!=ulLen ) ? out << ", " : out << " ) \";\n";
		}
	}

	strContent_ = "VALUES (";
	out << genSQLLine(strName_, strContent_, true, false, true);
	strContent_ = "\\'";
	out << genSQLLine(strName_, strContent_, false, false, false);
	strContent_ = "convertPidToString(pid)";
	out << genSQLLine(strContent_, false, false, false, true);
	strContent_ = "\\'";
	out << genSQLLine(strContent_, true, true, true);
	strContent_ = "\\'";
	out << genSQLLine(strName_, strContent_, false, false, false);
	strContent_ = "convertSpidToString(shortPid)";
	out << genSQLLine(strContent_, false, false, false, true);
	strContent_ = "\\'";
	out << genSQLLine(strContent_, true, true, true);

	for(i=0; i<ulLen; i++)
	{
		bFound = false;
		strTemp = "";
		attribute = IR__::AttributeDef::_narrow(state_members[i]);
		
		for(CORBA::ULong j=0; j<pards->length(); j++)
		{
			IR__::ParameterDescription pardescr = (*pards)[j];
			strTemp = std::string(pardescr.name);
			if(strTemp.compare(attribute->name())==0)
			{
				bFound = true;
				break;
			}
		}
		
		if(bFound)
		{
			if( attribute->type_def()->type()->kind() == CORBA::tk_value )
			{
				std::list<IR__::ValueDef_var>::iterator valuetype_iter;
				for(valuetype_iter = lValueTypes_.begin();
					valuetype_iter != lValueTypes_.end();
					valuetype_iter++)
				{
					IR__::ValueDef_var value = IR__::ValueDef::_narrow(*valuetype_iter);
					std::string attr_type_name = map_attribute_type(attribute->type_def());
					if(attr_type_name.find(mapName(value))!=std::string::npos)
					{
						IR__::ContainedSeq_var contained_seq = value->contents(CORBA__::dk_ValueMember, true);
						for(CORBA::ULong j = 0; j < contained_seq->length(); j++)
						{
							IR__::ValueMemberDef_var vMember = IR__::ValueMemberDef::_narrow((*contained_seq)[j]);
							switch(psdl_check_type(vMember->type_def()))
							{
							case CPPBase::_SHORT:
							case CPPBase::_INT:
							case CPPBase::_LONG:
								strContent_ = strTemp + "->";
								strContent_ += mapName(vMember) + "()";
								out << genSQLLine(strName_, strContent_, false, false, false, true);
								strContent_ = "";
								out << genSQLLine(strContent_, true, ((i+1)!=ulLen), true);
								break;
							case CPPBase::_STRING:
								strContent_ = "\\'";
								out << genSQLLine(strName_, strContent_, false, false, false);
								strContent_ = strTemp + "->";
								strContent_ += mapName(vMember) + "()";
								out << genSQLLine(strContent_, false, false, false, true);
								strContent_ = "\\'";
								out << genSQLLine(strContent_, true, ((i+1)!=ulLen), true);
								break;
							}
						}
						break;
					}
				}
			}
			else
			{
				switch(psdl_check_type(attribute->type_def()))
				{
				case CPPBase::_SHORT:
				case CPPBase::_INT:
				case CPPBase::_LONG:
				case CPPBase::_FLOAT:
				case CPPBase::_DOUBLE:
				case CPPBase::_LONGDOUBLE:
					strContent_ = strTemp;
					out << genSQLLine(strName_, strContent_, false, false, false, true);
					strContent_ = "";
					out << genSQLLine(strContent_, true, ((i+1)!=ulLen), true);
					break;
				case CPPBase::_STRING:
					strContent_ = "\\'";
					out << genSQLLine(strName_, strContent_, false, false, false);
					strContent_ = strTemp;
					out << genSQLLine(strContent_, false, false, false, true);
					strContent_ = "\\'";
					out << genSQLLine(strContent_, true, ((i+1)!=ulLen), true);
					break;
				case CPPBase::_BOOL:
					strContent_ = "convertBool2String(" + strTemp + ")";
					out << genSQLLine(strName_, strContent_, false, false, false, true);
					strContent_ = "";
					out << genSQLLine(strContent_, true, ((i+1)!=ulLen), true);
					break;
				}
			}
		}
		else
		{
			if( attribute->type_def()->type()->kind() == CORBA::tk_value )
			{
				std::list<IR__::ValueDef_var>::iterator valuetype_iter;
				for(valuetype_iter = lValueTypes_.begin();
					valuetype_iter != lValueTypes_.end();
					valuetype_iter++)
				{
					IR__::ValueDef_var value = IR__::ValueDef::_narrow(*valuetype_iter);
					std::string attr_type_name = map_attribute_type(attribute->type_def());
					if(attr_type_name.find(mapName(value))!=std::string::npos)
					{
						IR__::ContainedSeq_var contained_seq = value->contents(CORBA__::dk_ValueMember, true);
						for(CORBA::ULong j = 0; j < contained_seq->length(); j++)
						{
							strContent_ = "NULL";
							out << genSQLLine(strName_, strContent_, true, ((i+1)!=ulLen), true);
						}
					}
				}	
			}
			else
			{
				strContent_ = "NULL";
				out << genSQLLine(strName_, strContent_, true, ((i+1)!=ulLen), true);
			}
		}
	}
	strContent_ = ");";
	out << genSQLLine(strName_, strContent_, true, false, false);
	//++++++++++++++++++++++++++++++++++++++++
	// end of INSERT sentence for FACTORY !!!!
	//++++++++++++++++++++++++++++++++++++++++
	
	out << "\nif(pCatalogBaseImpl->ExecuteSQL(" << strName_ << ".str().c_str()))\n";
	out << "{\n";
	out.indent();
	out << "//use factory to create a storage object\n";
	out << "StorageObjectFactory factory = NULL;\n";
	out << "factory = pCatalogBaseImpl->getConnector()->register_storage_object_factory(\"" << strNamespace_ << "_" << strComponentName << "Persistence\", factory);\n";
	out << "StorageObjectImpl* pObjectImpl = factory->create();\n";
	out << "//factory->_remove_ref();\n";
	out << strComponentName << "Persistence* pActObject = dynamic_cast <" << strComponentName << "Persistence*> (pObjectImpl);\n";
	out << "\n//set values to current storageobject incarnation\n";
	out << "pActObject->set_pid(pid);\n";
	out << "pActObject->set_short_pid(shortPid);\n";
	for(CORBA::ULong j=0; j<pards->length(); j++)
	{
		IR__::ParameterDescription pardescr = (*pards)[j];
		ret_type = pardescr.type_def;
		out << "pActObject->" << std::string(pardescr.name) << "(";
		out << std::string(pardescr.name) << ");\n";
	}
	out << "pActObject->setStorageHome(this);\n\n";
	out << "lObjectes_.push_back(pActObject);\n\n";
	out << "return pActObject;\n";
	out.unindent();
	out << "}\n";
	out << "else\n";
	out.indent();
	out << "throw CORBA::BAD_PARAM();\n";
	out.unindent();
	out.unindent();
	out << "}\n\n";
}

void
GeneratorPersistenceC::genFinder(IR__::FinderDef_ptr key, IR__::HomeDef_ptr home)
{
	IR__::IDLType_var ret_type = IR__::IDLType::_narrow(key);
	IR__::ComponentDef_var component = home->managed_component();

	out << component->name() << "Persistence*\n";
	out << home->name() << "Persistence::" << mapName(key) << "(";

	// parameters
	IR__::ParDescriptionSeq_var pards = key->params();
	for( CORBA::ULong i=pards->length(); i>0; i--)
	{
		IR__::ParameterDescription pardescr = (*pards)[i-1];
		if (pardescr.mode == IR__::PARAM_IN) {
			out << map_in_parameter_type (pardescr.type_def) << " " << std::string(pardescr.name);
		};
		if (pardescr.mode == IR__::PARAM_OUT) {
			out << map_out_parameter_type (pardescr.type_def) << " " << std::string(pardescr.name);
		};
		if (pardescr.mode == IR__::PARAM_INOUT) {
			out << map_inout_parameter_type (pardescr.type_def) << " " << std::string(pardescr.name);
		};

		if((i-1)!=0) { out << ", "; }
	};

	out << ")";
	
	out << "\n";
	out.indent();
	out << "throw(CosPersistentState::NotFound";
	handleException(key);
	out << ")";
	out.unindent();
	
	out << "\n{\n";
	out.indent();

	//++++++++++++++++++++++++++++++++++++++++
	// SELECT sentence for KEY
	//++++++++++++++++++++++++++++++++++++++++
	out << component->name() << "Persistence* pActObject = NULL;\n";
	out << "std::stringstream strKey;\n\n";
	strName_ = "strKey";
	strContent_ = "SELECT spid FROM ";
	strContent_ += home->name();
	strContent_ += "Persistence";
	out << genSQLLine(strName_, strContent_, true, false, true);
	strContent_ = "WHERE";
	out << genSQLLine(strName_, strContent_, true, false, true);

	CORBA::ULong ulLen = pards->length();

	for( i=0; i<ulLen; i++ )
	{
		IR__::ParameterDescription pardescr = (*pards)[i];
	
		if( pardescr.type_def->type()->kind() == CORBA::tk_value )
		{
			std::list<IR__::ValueDef_var>::iterator valuetype_iter;
			for(valuetype_iter = lValueTypes_.begin();
				valuetype_iter != lValueTypes_.end();
				valuetype_iter++)
			{
				IR__::ValueDef_var value = IR__::ValueDef::_narrow(*valuetype_iter);
				std::string attr_type_name = map_attribute_type(pardescr.type_def);
				if(attr_type_name.find(mapName(value))!=std::string::npos)
				{
					IR__::ContainedSeq_var contained_seq = value->contents(CORBA__::dk_ValueMember, true);
					for(CORBA::ULong j = 0; j < contained_seq->length(); j++)
					{
						IR__::ValueMemberDef_var vMember = IR__::ValueMemberDef::_narrow((*contained_seq)[j]);
						strContent_ = "value_" + mapName(vMember);
						if(psdl_check_type(vMember->type_def())!=CPPBase::_STRING)
							strContent_ += " =";
						else
							strContent_ += " LIKE";
						out << genSQLLine(strName_, strContent_, true, false, true);

						switch(psdl_check_type(vMember->type_def()))
						{
						case CPPBase::_SHORT:
						case CPPBase::_INT:
						case CPPBase::_LONG:
							strContent_ = std::string(pardescr.name) + "->";
							strContent_ += mapName(vMember) + "()";
							out << genSQLLine(strName_, strContent_, false, false, false, true);
							strContent_ = "";
							out << genSQLLine(strContent_, true, ((i+1)!=ulLen), true);
							break;
						case CPPBase::_STRING:
							strContent_ = "\\'";
							out << genSQLLine(strName_, strContent_, false, false, false);
							strContent_ = std::string(pardescr.name) + "->";
							strContent_ += mapName(vMember) + "()";
							out << genSQLLine(strContent_, false, false, false, true);
							strContent_ = "\\'";
							out << genSQLLine(strContent_, true, ((i+1)!=ulLen), true);
							break;
						}
					}
					break;
				}
			}
		}
		else
		{
			strContent_ = std::string(pardescr.name);

			if(psdl_check_type(pardescr.type_def)!=CPPBase::_STRING)
				strContent_ += " =";
			else
				strContent_ += " LIKE";
			out << genSQLLine(strName_, strContent_, true, false, true);

			switch(psdl_check_type(pardescr.type_def))
			{
			case CPPBase::_SHORT:
			case CPPBase::_INT:
			case CPPBase::_LONG:
			case CPPBase::_FLOAT:
			case CPPBase::_DOUBLE:
			case CPPBase::_LONGDOUBLE:
				strContent_ = std::string(pardescr.name);
				out << genSQLLine(strName_, strContent_, false, false, false, true);
				strContent_ = "";
				out << genSQLLine(strContent_, true, ((i+1)!=ulLen), true);
				break;
			case CPPBase::_STRING:
				strContent_ = "\\'";
				out << genSQLLine(strName_, strContent_, false, false, false);
				strContent_ = std::string(pardescr.name);
				out << genSQLLine(strContent_, false, false, false, true);
				strContent_ = "\\'";
				out << genSQLLine(strContent_, true, ((i+1)!=ulLen), true);
				break;
			case CPPBase::_BOOL:
				strContent_ = "convertBool2String(" + std::string(pardescr.name) + ")";
				out << genSQLLine(strName_, strContent_, false, false, false, true);
				strContent_ = "";
				out << genSQLLine(strContent_, true, ((i+1)!=ulLen), true);
				break;
			}
		}
	}
	strContent_ = ");";
	out << genSQLLine(strName_, strContent_, true, false, false);
	//++++++++++++++++++++++++++++++++++++++++
	// end of SELECT sentence for KEY !!!!!!!!
	//++++++++++++++++++++++++++++++++++++++++

	out << "\nif(!Open(" << strName_ << ".str().c_str()))\n";
	out.indent();
	out << "throw CosPersistentState::NotFound();\n\n";
	out.unindent();
	out << "if (GetFieldCount()<=0)\n{\n";
	out.indent();
	out << "Close();\n";
	out << "throw CosPersistentState::NotFound();\n";
	out.unindent();
	out << "}\n\n";
	out << "unsigned char* szSpid = new unsigned char[254];\n";
	out << "memset(szSpid, \'\\0\', 254);\n";
	out << "GetFieldValue(0, szSpid);\n";
	out << "Close();\n\n";
	out << "std::string strSpid = \"\";\n";
	out << "strSpid.append((const char*)szSpid);\n";
	out << "ShortPid* pSpid = new ShortPid;\n";
	out << "convertStringToSpid(strSpid.c_str(), *pSpid);\n\n";
	out << "StorageObjectBase pObject = find_by_short_pid(*pSpid);\n\n";
	out << "pActObject = dynamic_cast <" << component->name() << "Persistence*> (pObject);\n";
	out << "pActObject->setStorageHome(this);\n\n";
	out << "return pActObject;\n";
	out.unindent();
	out << "}\n\n";
}

void
GeneratorPersistenceC::genHomePersistence(IR__::HomeDef_ptr home, CIDL::LifecycleCategory lc)
{
	if( lc!=CIDL::lc_Entity && lc!=CIDL::lc_Process )
		return;

	// handle base home
	IR__::HomeDef_var base_home = home->base_home();
	if(base_home)
		genHomePersistence(base_home, lc);

	int iLength = 0;
	std::string strDummy = "";
	IR__::AttributeDefSeq state_members;

	std::string strHomeName = home->name();
	out << "// ================================================\n";
	out << "// " << "home persistence" << "\n";
	out << "// ================================================\n\n";
	out << strHomeName << "Persistence::" << strHomeName << "Persistence()\n";
	out << "{\n}\n\n";
	out << strHomeName << "Persistence::~" << strHomeName << "Persistence()\n";
	out << "{\n}\n\n";

	// get managed component
	IR__::ComponentDef_var component = home->managed_component();
	std::string strComponentName = component->name();

	strDummy = home->name();
	iLength = strDummy.length() + 21;
	
	strDummy = "";
	out << strComponentName << "Persistence*\n";
	out << strHomeName << "Persistence::_create(" << "Pid* pid,\n";
	strDummy.append(iLength, ' ');
	out << strDummy.c_str();
	out << "ShortPid* shortPid,\n";
	
	component->get_state_members(state_members, CORBA__::dk_Create);
	CORBA::ULong ulLen = state_members.length();
	for(CORBA::ULong i=0; i<ulLen; i++)
	{
		IR__::AttributeDef_var attribute = IR__::AttributeDef::_narrow(state_members[i]);
		out << strDummy.c_str() << map_in_parameter_type(attribute->type_def()) << " " << mapName(attribute);
		if( (i+1)!=ulLen )
			out << ",\n";
	}
	
	out << ")\n{\n";
	out.indent();
	//+++++++++++++++++++++++++++++++++++++++++++
	// INSERT sentence for _create in storagehome
	//+++++++++++++++++++++++++++++++++++++++++++
	IR__::AttributeDef_var attribute = IR__::AttributeDef::_nil();
	out << "std::stringstream strInsert;\n\n";
	out << "CatalogBase_ptr pCatalogBase = get_catalog();\n";
	out << "CatalogBaseImpl* pCatalogBaseImpl = dynamic_cast <CatalogBaseImpl*> (pCatalogBase);\n\n";
	strName_ = "strInsert";

	out << strName_ << " << \"INSERT INTO pid_content (pid, home, type) VALUES ( \";\n";
	strContent_ = "\\'";
	out << genSQLLine(strName_, strContent_, false, false, false);
	strContent_ = "convertPidToString(pid)";
	out << genSQLLine(strContent_, false, false, false, true);
	strContent_ = "\\'";
	out << genSQLLine(strContent_, true, true, true);
	out << strName_ << " << \"\\\'" << strNamespace_ << "_" << strHomeName << "Persistence\\\', ";
	out << "\\\'" << strNamespace_ << "_" << strComponentName << "Persistence\\\' );\";\n\n";
	out << "if(!pCatalogBaseImpl->ExecuteSQL(" << strName_ << ".str().c_str()))\n";
	out.indent();
	out << "throw CORBA::BAD_PARAM();\n\n";
	out.unindent();

	out << strName_ << ".str(\"\");\n";
	out << strName_ << " << \"INSERT INTO " << strNamespace_ << "_" << strHomeName << "Persistence ( pid, spid, ";
	
	for(i=0; i<ulLen; i++)
	{
		attribute = IR__::AttributeDef::_narrow(state_members[i]);
		if( attribute->type_def()->type()->kind() == CORBA::tk_value )
		{
			std::list<IR__::ValueDef_var>::iterator valuetype_iter;
			for(valuetype_iter = lValueTypes_.begin();
				valuetype_iter != lValueTypes_.end();
				valuetype_iter++)
			{
				IR__::ValueDef_var value = IR__::ValueDef::_narrow(*valuetype_iter);
				std::string attr_type_name = map_attribute_type(attribute->type_def());
				if(attr_type_name.find(mapName(value))!=std::string::npos)
				{
					IR__::ContainedSeq_var contained_seq = value->contents(CORBA__::dk_ValueMember, true);
					for(CORBA::ULong j = 0; j < contained_seq->length(); j++)
					{
						IR__::ValueMemberDef_var vMember = IR__::ValueMemberDef::_narrow((*contained_seq)[j]);
						out << "value_" << mapName(vMember);
						( (i+1)!=ulLen ) ? out << ", " : out << " ) \";\n";
					}
					break;
				}
			}
		}
		else
		{
			out << mapName(attribute);
			( (i+1)!=ulLen ) ? out << ", " : out << " ) \";\n";
		}
	}
	
	strContent_ = "VALUES (";
	out << genSQLLine(strName_, strContent_, true, false, true);
	strContent_ = "\\'";
	out << genSQLLine(strName_, strContent_, false, false, false);
	strContent_ = "convertPidToString(pid)";
	out << genSQLLine(strContent_, false, false, false, true);
	strContent_ = "\\'";
	out << genSQLLine(strContent_, true, true, true);
	strContent_ = "\\'";
	out << genSQLLine(strName_, strContent_, false, false, false);
	strContent_ = "convertSpidToString(shortPid)";
	out << genSQLLine(strContent_, false, false, false, true);
	strContent_ = "\\'";
	out << genSQLLine(strContent_, true, true, true);

	for(CORBA::ULong i=0; i<ulLen; i++)
	{
		attribute = IR__::AttributeDef::_narrow(state_members[i]);
		// parse valuemember from valuetype
		if( attribute->type_def()->type()->kind() == CORBA::tk_value )
		{
			std::list<IR__::ValueDef_var>::iterator valuetype_iter;
			for(valuetype_iter = lValueTypes_.begin();
				valuetype_iter != lValueTypes_.end();
				valuetype_iter++)
			{
				IR__::ValueDef_var value = IR__::ValueDef::_narrow(*valuetype_iter);
				std::string attr_type_name = map_attribute_type(attribute->type_def());
				if(attr_type_name.find(mapName(value))!=std::string::npos)
				{
					IR__::ContainedSeq_var contained_seq = value->contents(CORBA__::dk_ValueMember, true);
					for(CORBA::ULong j = 0; j < contained_seq->length(); j++)
					{
						IR__::ValueMemberDef_var vMember = IR__::ValueMemberDef::_narrow((*contained_seq)[j]);
						switch(psdl_check_type(vMember->type_def()))
						{
						case CPPBase::_SHORT:
						case CPPBase::_INT:
						case CPPBase::_LONG:
							strContent_ = mapName(attribute) + "->";
							strContent_ += mapName(vMember) + "()";
							out << genSQLLine(strName_, strContent_, false, false, false, true);
							strContent_ = "";
							out << genSQLLine(strContent_, true, ((i+1)!=ulLen), true);
							break;
						case CPPBase::_STRING:
							strContent_ = "\\'";
							out << genSQLLine(strName_, strContent_, false, false, false);
							strContent_ = mapName(attribute) + "->";
							strContent_ += mapName(vMember) + "()";
							out << genSQLLine(strContent_, false, false, false, true);
							strContent_ = "\\'";
							out << genSQLLine(strContent_, true, ((i+1)!=ulLen), true);
							break;
						}
					}
					break;
				}
			}
		}
		else // for normal state member with normal data type
		{
			switch(psdl_check_type(attribute->type_def()))
			{
			case CPPBase::_SHORT:
			case CPPBase::_INT:
			case CPPBase::_LONG:
			case CPPBase::_FLOAT:
			case CPPBase::_DOUBLE:
			case CPPBase::_LONGDOUBLE:
				strContent_ = mapName(attribute);
				out << genSQLLine(strName_, strContent_, false, false, false, true);
				strContent_ = "";
				out << genSQLLine(strContent_, true, ((i+1)!=ulLen), true);
				break;
			case CPPBase::_STRING:
				strContent_ = "\\'";
				out << genSQLLine(strName_, strContent_, false, false, false);
				strContent_ = mapName(attribute);
				out << genSQLLine(strContent_, false, false, false, true);
				strContent_ = "\\'";
				out << genSQLLine(strContent_, true, ((i+1)!=ulLen), true);
				break;
			case CPPBase::_BOOL:
				strContent_ = "convertBool2String(" + mapName(attribute) + ")";
				out << genSQLLine(strName_, strContent_, false, false, false, true);
				strContent_ = "";
				out << genSQLLine(strContent_, true, ((i+1)!=ulLen), true);
				break;
			}
		}
	}
	strContent_ = ");";
	out << genSQLLine(strName_, strContent_, true, false, false);
	//++++++++++++++++++++++++++++++++++++++++++++++++++
	// end of INSERT sentence for _create in storagehome
	//++++++++++++++++++++++++++++++++++++++++++++++++++
	
	out << "\nif(pCatalogBaseImpl->ExecuteSQL(" << strName_ << ".str().c_str()))\n";
	out << "{\n";
	out.indent();
	
	out << "//use factory to create a storage object\n";
	out << "StorageObjectFactory factory = NULL;\n";
	out << "factory = pCatalogBaseImpl->getConnector()->register_storage_object_factory(\"" << strNamespace_ << "_" << strComponentName << "Persistence\", factory);\n";
	out << "StorageObjectImpl* pObjectImpl = factory->create();\n";
	out << "//factory->_remove_ref();\n";
	out << strComponentName << "Persistence* pActObject = dynamic_cast <" << strComponentName << "Persistence*> (pObjectImpl);\n";
	out << "\n//set values to current storageobject incarnation\n";
	out << "pActObject->set_pid(pid);\n";
	out << "pActObject->set_short_pid(shortPid);\n";
	for(CORBA::ULong i=0; i<ulLen; i++)
	{
		attribute = IR__::AttributeDef::_narrow(state_members[i]);
		out << "pActObject->" << mapName(attribute) << "(";
		out << mapName(attribute) << ");\n";
	}
	out << "pActObject->setStorageHome(this);\n\n";
	out << "lObjectes_.push_back(pActObject);\n\n";
	out << "return pActObject;\n";
	
	out.unindent();
	out << "}\n";
	out << "else\n";
	out.indent();
	out << "throw CORBA::BAD_PARAM();\n";
	out.unindent();
	out.unindent();
	out << "}\n\n";

	// handel factory
	IR__::ContainedSeq_var contained_seq = home->contents(CORBA__::dk_Factory, false);
	ulLen = contained_seq->length();
	for(CORBA::ULong i = 0; i < ulLen; i++)
	{
		IR__::FactoryDef_var a_factory = IR__::FactoryDef::_narrow(((*contained_seq)[i]));
		genFactory(a_factory, home);
	}

	// handel finder
	contained_seq = home->contents(CORBA__::dk_Finder, false);
	ulLen = contained_seq->length();
	for(i = 0; i < ulLen; i++)
	{
		IR__::FinderDef_var a_finder = IR__::FinderDef::_narrow(((*contained_seq)[i]));
		genFinder(a_finder, home);
	}

	//
	//generate appropriate finder for find_by_primary_key(...)
	//
	out << strComponentName << "Persistence*\n";
	out << home->name() << "Persistence::find_by_primary_key(" << mapFullNamePK(home->primary_key()) << "* pkey)\n";
	out.indent();
	out << "throw(CosPersistentState::NotFound)\n";
	out.unindent();
	out << "{\n";
	out.indent();
	//++++++++++++++++++++++++++++++++++++++++
	// SELECT sentence for find_by_primary_key
	//++++++++++++++++++++++++++++++++++++++++
	out << strComponentName << "Persistence* pActObject = NULL;\n";
	out << "std::stringstream strKey;\n\n";
	strName_ = "strKey";
	strContent_ = "SELECT spid FROM ";
	strContent_ += strNamespace_ + "_";
	strContent_ += home->name();
	strContent_ += "Persistence";
	out << genSQLLine(strName_, strContent_, true, false, true);
	strContent_ = "WHERE";
	out << genSQLLine(strName_, strContent_, true, false, true);

	IR__::ValueDef_var value = home->primary_key()->primary_key();
	contained_seq = value->contents(CORBA__::dk_ValueMember, true);
	ulLen = contained_seq->length();

	for( i=0; i<ulLen; i++ )
	{
		IR__::ValueMemberDef_var a_vMember = IR__::ValueMemberDef::_narrow((*contained_seq)[i]);

		strContent_ = "value_" + mapName(a_vMember);
		if(psdl_check_type(a_vMember->type_def())!=CPPBase::_STRING)
			strContent_ += " =";
		else
			strContent_ += " LIKE";
		out << genSQLLine(strName_, strContent_, true, false, true);

		switch(psdl_check_type(a_vMember->type_def()))
		{
		case CPPBase::_SHORT:
		case CPPBase::_INT:
		case CPPBase::_LONG:
			strContent_ = "pkey->";
			strContent_ += mapName(a_vMember) + "()";
			out << genSQLLine(strName_, strContent_, false, false, false, true);
			strContent_ = "";
			out << genSQLLine(strContent_, true, ((i+1)!=ulLen), true);
			break;
		case CPPBase::_STRING:
			strContent_ = "\\'";
			out << genSQLLine(strName_, strContent_, false, false, false);
			strContent_ = "pkey->";
			strContent_ += mapName(a_vMember) + "()";
			out << genSQLLine(strContent_, false, false, false, true);
			strContent_ = "\\'";
			out << genSQLLine(strContent_, true, ((i+1)!=ulLen), true);
			break;
		}
	}
	strContent_ = ";";
	out << genSQLLine(strName_, strContent_, true, false, false);
	//++++++++++++++++++++++++++++++++++++++++
	// end of SELECT sentence for KEY !!!!!!!!
	//++++++++++++++++++++++++++++++++++++++++

	out << "\nif(!Open(" << strName_ << ".str().c_str()))\n";
	out.indent();
	out << "throw CosPersistentState::NotFound();\n\n";
	out.unindent();
	out << "if (GetFieldCount()<=0)\n{\n";
	out.indent();
	out << "Close();\n";
	out << "throw CosPersistentState::NotFound();\n";
	out.unindent();
	out << "}\n\n";
	out << "unsigned char* szSpid = new unsigned char[254];\n";
	out << "memset(szSpid, \'\\0\', 254);\n";
	out << "GetFieldValue(0, szSpid);\n";
	out << "Close();\n\n";
	out << "std::string strSpid = \"\";\n";
	out << "strSpid.append((const char*)szSpid);\n";
	out << "ShortPid* pSpid = new ShortPid;\n";
	out << "convertStringToSpid(strSpid.c_str(), *pSpid);\n\n";
	out << "StorageObjectBase pObject = find_by_short_pid(*pSpid);\n\n";
	out << "pActObject = dynamic_cast <" << strComponentName << "Persistence*> (pObject);\n";
	out << "pActObject->setStorageHome(this);\n\n";
	out << "return pActObject;\n";
	out.unindent();
	out << "}\n\n";
}

} // namespace
