/*****************************************************************************/
/* Qedo - Quality of Service Enabled Distributed Objects                     */
/*                                                                           */
/* Copyright (c) 2002/2003 by the Qedo Team                                  */
/*                                                                           */
/* http://qedo.berlios.de                                                    */
/*                                                                           */
/* This file is part of Qedo Generator                                       */
/*                                                                           */
/* Qedo Generator is free software; you can redistribute it and/or modify    */
/* it under the terms of the GNU General Public License as published by      */
/* the Free Software Foundation; either version 2 of the License, or         */
/* (at your option) any later version.                                       */
/*                                                                           */
/* Qedo Generator is distributed in the hope that it will be useful,         */
/* but WITHOUT ANY WARRANTY; without even the implied warranty of            */
/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             */
/* GNU General Public License for more details.                              */
/*                                                                           */
/* You should have received a copy of the GNU General Public License         */
/* along with Foobar; if not, write to the Free Software                     */
/* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA */
/*                                                                           */
/*****************************************************************************/
#include "GeneratorPSSFD.h"


namespace QEDO_CIDL_Generator {

GeneratorPSSFD::GeneratorPSSFD
( QEDO_ComponentRepository::CIDLRepository_impl *repository)
: CPPBase(repository),
  strFilename_("")
{
}

GeneratorPSSFD::~GeneratorPSSFD
()
{
}

void
GeneratorPSSFD::generate(std::string target, std::string fileprefix)
{
	try { initialize(target, fileprefix); }
	catch (InitializeError) { return; }
	
	strFilename_ = file_prefix_ + "_FD.h";
	
	out.open(strFilename_.c_str());
	out << "//\n";
	out << "// generated by Qedo\n";
	out << "//\n\n";
	out << "#ifndef _" << file_prefix_ << "_FD_\n";
	out << "#define _" << file_prefix_ << "_FD_\n\n\n";
	out << "// BEGIN USER INSERT SECTION file_pre\n";
	out << "// END USER INSERT SECTION file_pre\n\n";
	out << "namespace " << file_prefix_ << "\n";
	out << "{\n";
	out.indent();
	doGenerate();
	out.unindent();
	out << "};\n\n";
	out << "// BEGIN USER INSERT SECTION file_post\n";
	out << "// END USER INSERT SECTION file_post\n\n";
	out << "#endif\n";
	out.close();
}

void
GeneratorPSSFD::check_for_generation(IR__::Contained_ptr item)
{
	// check if item is already known
	if (item_well_known(item))
		return;

	// check if item is already in the list or currently processed
	if ((this->sRecursion_.find(item->id())) != sRecursion_.end() || this->already_included (item))
		return;
	else
		sRecursion_.insert(item->id());
	
	CORBA::ULong i;
	CORBA::ULong ulLen;

	switch (item->def_kind()) 
	{
	case CORBA__::dk_Module :
	{
		IR__::ModuleDef_var a_module = IR__::ModuleDef::_narrow(item);

		// modules
		IR__::ContainedSeq_var contained_seq = a_module->contents(CORBA__::dk_Module, true);
		ulLen = contained_seq->length();
		for(i=0; i<ulLen; i++)
			check_for_generation((*contained_seq)[i]);
		
		// abstract storagehomes
		contained_seq = a_module->contents(CORBA__::dk_AbstractStorageHome, true);
		ulLen = contained_seq->length();
		for(i=0; i<ulLen; i++)
			check_for_generation((*contained_seq)[i]);

		// storagehomes
		contained_seq = a_module->contents(CORBA__::dk_StorageHome, true);
		ulLen = contained_seq->length();
		for(i=0; i<ulLen; i++)
			check_for_generation((*contained_seq)[i]);

		break;
	}
	case CORBA__::dk_AbstractStorageType :
	{
		IR__::AbstractStorageTypeDef_var abs_storagetype = IR__::AbstractStorageTypeDef::_narrow(item);
		// insert this interface in generation list
		this->insert_to_generate(item);

		break;
	}
	case CORBA__::dk_StorageType :
	{
		IR__::StorageTypeDef_var storagetype = IR__::StorageTypeDef::_narrow(item);
		// insert this interface in generation list
		this->insert_to_generate(item);

		break;
	}
	case CORBA__::dk_AbstractStorageHome :
	{
		IR__::AbstractStorageHomeDef_var abs_storagehome = IR__::AbstractStorageHomeDef::_narrow(item);
		// insert this interface in generation list
		this->insert_to_generate(item);

		// managed abstract storage type
		IR__::AbstractStorageTypeDef_var abs_storagetype = abs_storagehome->managed_abstract_storagetype();
		this->check_for_generation(abs_storagetype);

		break;
	}
	case CORBA__::dk_StorageHome :
	{
		IR__::StorageHomeDef_var storagehome = IR__::StorageHomeDef::_narrow(item);	
		// insert this interface in generation list
		this->insert_to_generate(item);

		// managed storage type
		IR__::StorageTypeDef_var storagetype = storagehome->managed_storagetype();
		this->check_for_generation(storagetype);

		break; 
	}
	default:
		break;
	};

	sRecursion_.erase(item->id());
};

void 
GeneratorPSSFD::doAbstractStorageType(IR__::AbstractStorageTypeDef_ptr abs_storagetype)
{
	out << "class " << std::string(abs_storagetype->name()) << ";\n";
	out << "class " << std::string(abs_storagetype->name()) << "Ref;\n";
}

void 
GeneratorPSSFD::doStorageType(IR__::StorageTypeDef_ptr storagetype)
{
	out << "class " << std::string(storagetype->name()) << ";\n";
	out << "class " << std::string(storagetype->name()) << "Ref;\n";
}

void 
GeneratorPSSFD::doAbstractStorageHome(IR__::AbstractStorageHomeDef_ptr abs_storagehome)
{
	out << "class " << std::string(abs_storagehome->name()) << ";\n";
}

void 
GeneratorPSSFD::doStorageHome(IR__::StorageHomeDef_ptr storagehome)
{
	out << "class " << std::string(storagehome->name()) << ";\n";
}

} // namespace
